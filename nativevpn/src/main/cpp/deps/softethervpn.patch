diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0a622ab..17ea9d3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -27,7 +27,7 @@ project("SoftEther VPN"
 
 set(CMAKE_C_STANDARD 99)
 
-set(TOP_DIRECTORY ${CMAKE_SOURCE_DIR})
+set(TOP_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
 set(BUILD_DIRECTORY ${CMAKE_BINARY_DIR})
 
 # We define a dedicated variable because CMAKE_BUILD_TYPE can have different
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index c49a3c7..a7a8ec3 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -136,41 +136,35 @@ add_subdirectory(Cedar)
 add_subdirectory(Mayaqua)
 
 # vpnserver
-add_subdirectory(vpnserver)
+#add_subdirectory(vpnserver)
 
 # vpnclient
 add_subdirectory(vpnclient)
 
 # vpnbridge
-add_subdirectory(vpnbridge)
+#add_subdirectory(vpnbridge)
 
 # vpncmd
-add_subdirectory(vpncmd)
+#add_subdirectory(vpncmd)
 
 # vpntest
-add_subdirectory(vpntest)
+#add_subdirectory(vpntest)
 
 # libhamcore
 add_subdirectory(libhamcore)
 
 # hamcorebuilder utility
-add_subdirectory(hamcorebuilder)
+#add_subdirectory(hamcorebuilder)
 
 # hamcore.se2 archive file
+configure_file("$ENV{HAMCORE_SE2}/hamcore.se2"
+  "${BUILD_DIRECTORY}/hamcore.se2"   COPYONLY
+)
 add_custom_target(hamcore-archive-build
   ALL
   DEPENDS "${BUILD_DIRECTORY}/hamcore.se2"
 )
 
-add_custom_command(
-  COMMENT "Building hamcore.se2 archive file..."
-  COMMAND hamcorebuilder "hamcore.se2" "${TOP_DIRECTORY}/src/bin/hamcore"
-  DEPENDS hamcorebuilder "${TOP_DIRECTORY}/src/bin/hamcore/"
-  OUTPUT "${BUILD_DIRECTORY}/hamcore.se2"
-  WORKING_DIRECTORY "${BUILD_DIRECTORY}"
-  VERBATIM
-)
-
 if(WIN32)
   # PenCore
   add_subdirectory(PenCore)
diff --git a/src/Cedar/CMakeLists.txt b/src/Cedar/CMakeLists.txt
index 7818d79..6b83b43 100644
--- a/src/Cedar/CMakeLists.txt
+++ b/src/Cedar/CMakeLists.txt
@@ -21,10 +21,28 @@ set_target_properties(cedar
 
 target_link_libraries(cedar PUBLIC mayaqua)
 
-cmake_host_system_information(RESULT HAS_SSE2 QUERY HAS_SSE2)
 
-set(BLAKE2_SRC_PATH $<IF:$<BOOL:${HAS_SSE2}>,${TOP_DIRECTORY}/3rdparty/BLAKE2/sse,${TOP_DIRECTORY}/3rdparty/BLAKE2/ref>)
-set(BLAKE2_SRC $<IF:$<BOOL:${HAS_SSE2}>,${BLAKE2_SRC_PATH}/blake2s.c,${BLAKE2_SRC_PATH}/blake2s-ref.c>)
+if(ANDROID_ABI STREQUAL "arm64-v8a")
+    set(HAS_NEON TRUE)
+elseif(ANDROID_ABI STREQUAL "armeabi-v7a")
+    set(HAS_NEON TRUE)
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mfpu=neon")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mfpu=neon")
+elseif(ANDROID_ABI MATCHES "^(x86_64|x86)")
+    include(CheckIncludeFiles)
+    check_include_files("emmintrin.h" HAS_SSE2)
+endif()
+
+if(HAS_SSE2)
+    set(BLAKE2_SRC_PATH ${TOP_DIRECTORY}/3rdparty/BLAKE2/sse)
+    set(BLAKE2_SRC ${BLAKE2_SRC_PATH}/blake2s.c)
+elseif(HAS_NEON)
+    set(BLAKE2_SRC_PATH ${TOP_DIRECTORY}/3rdparty/BLAKE2/neon)
+    set(BLAKE2_SRC ${BLAKE2_SRC_PATH}/blake2s.c)
+else()
+    set(BLAKE2_SRC_PATH ${TOP_DIRECTORY}/3rdparty/BLAKE2/ref)
+    set(BLAKE2_SRC ${BLAKE2_SRC_PATH}/blake2s-ref.c)
+endif()
 
 target_include_directories(cedar PUBLIC ${BLAKE2_SRC_PATH})
 target_sources(cedar PRIVATE ${BLAKE2_SRC})
diff --git a/src/Cedar/Console.c b/src/Cedar/Console.c
index 45bab42..796d949 100644
--- a/src/Cedar/Console.c
+++ b/src/Cedar/Console.c
@@ -1,2485 +1,2495 @@
-// SoftEther VPN Source Code - Developer Edition Master Branch
-// Cedar Communication Module
-
-
-// Console.c
-// Console Service
-
-#include "Console.h"
-
-#include "Cedar.h"
-
-#include "Mayaqua/Cfg.h"
-#include "Mayaqua/FileIO.h"
-#include "Mayaqua/Internat.h"
-#include "Mayaqua/Mayaqua.h"
-#include "Mayaqua/Memory.h"
-#include "Mayaqua/Microsoft.h"
-#include "Mayaqua/Object.h"
-#include "Mayaqua/Str.h"
-#include "Mayaqua/Table.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#ifdef OS_WIN32
-#include <conio.h>
-#else
-#include <termios.h>
-#include <sys/ioctl.h>
-
-#include <readline/readline.h>
-#include <readline/history.h>
-#endif
-
-// Display the help for the command
-void PrintCmdHelp(CONSOLE *c, char *cmd_name, TOKEN_LIST *param_list)
-{
-	wchar_t tmp[MAX_SIZE];
-	wchar_t *buf;
-	UINT buf_size;
-	wchar_t *description, *args, *help;
-	UNI_TOKEN_LIST *t;
-	UINT width;
-	UINT i;
-	char *space;
-	// Validate arguments
-	if (c == NULL || cmd_name == NULL || param_list == NULL)
-	{
-		return;
-	}
-
-	width = GetConsoleWidth(c) - 2;
-
-	buf_size = sizeof(wchar_t) * (width + 32);
-	buf = Malloc(buf_size);
-
-	GetCommandHelpStr(cmd_name, &description, &args, &help);
-
-	space = MakeCharArray(' ', 2);
-
-	// Title
-	UniFormat(tmp, sizeof(tmp), _UU("CMD_HELP_TITLE"), cmd_name);
-	c->Write(c, tmp);
-	c->Write(c, L"");
-
-	// Purpose
-	c->Write(c, _UU("CMD_HELP_DESCRIPTION"));
-	t = SeparateStringByWidth(description, width - 2);
-	for (i = 0;i < t->NumTokens;i++)
-	{
-		UniFormat(buf, buf_size, L"%S%s", space, t->Token[i]);
-		c->Write(c, buf);
-	}
-	UniFreeToken(t);
-	c->Write(c, L"");
-
-	// Description
-	c->Write(c, _UU("CMD_HELP_HELP"));
-	t = SeparateStringByWidth(help, width - 2);
-	for (i = 0;i < t->NumTokens;i++)
-	{
-		UniFormat(buf, buf_size, L"%S%s", space, t->Token[i]);
-		c->Write(c, buf);
-	}
-	UniFreeToken(t);
-	c->Write(c, L"");
-
-	// Usage
-	c->Write(c, _UU("CMD_HELP_USAGE"));
-	t = SeparateStringByWidth(args, width - 2);
-	for (i = 0;i < t->NumTokens;i++)
-	{
-		UniFormat(buf, buf_size, L"%S%s", space, t->Token[i]);
-		c->Write(c, buf);
-	}
-	UniFreeToken(t);
-
-	// Arguments
-	if (param_list->NumTokens >= 1)
-	{
-		c->Write(c, L"");
-		c->Write(c, _UU("CMD_HELP_ARGS"));
-		PrintCandidateHelp(c, cmd_name, param_list, 2);
-	}
-
-	Free(space);
-
-	Free(buf);
-}
-
-// Evaluate whether it is SafeStr
-bool CmdEvalSafe(CONSOLE *c, wchar_t *str, void *param)
-{
-	wchar_t *p = (param == NULL) ? _UU("CMD_EVAL_SAFE") : (wchar_t *)param;
-
-	if (IsSafeUniStr(str))
-	{
-		return true;
-	}
-
-	c->Write(c, p);
-
-	return false;
-}
-
-// String input prompt
-wchar_t *CmdPrompt(CONSOLE *c, void *param)
-{
-	wchar_t *p = (param == NULL) ? _UU("CMD_PROMPT") : (wchar_t *)param;
-
-	return c->ReadLine(c, p, true);
-}
-
-// Evaluation whether the specified file exists
-bool CmdEvalIsFile(CONSOLE *c, wchar_t *str, void *param)
-{
-	wchar_t tmp[MAX_PATH];
-	// Validate arguments
-	if (c == NULL || str == NULL)
-	{
-		return false;
-	}
-
-	UniStrCpy(tmp, sizeof(tmp), str);
-
-	if (IsEmptyUniStr(tmp))
-	{
-		c->Write(c, _UU("CMD_FILE_NAME_EMPTY"));
-		return false;
-	}
-
-	if (IsFileExistsW(tmp) == false)
-	{
-		wchar_t tmp2[MAX_SIZE];
-
-		UniFormat(tmp2, sizeof(tmp2), _UU("CMD_FILE_NOT_FOUND"), tmp);
-		c->Write(c, tmp2);
-
-		return false;
-	}
-
-	return true;
-}
-
-// Evaluation of integer
-bool CmdEvalInt1(CONSOLE *c, wchar_t *str, void *param)
-{
-	wchar_t *p = (param == NULL) ? _UU("CMD_EVAL_INT") : (wchar_t *)param;
-
-	if (UniToInt(str) == 0)
-	{
-		c->Write(c, p);
-
-		return false;
-	}
-
-	return true;
-}
-
-// Evaluation of the parameters that a blank cannot be specified to
-bool CmdEvalNotEmpty(CONSOLE *c, wchar_t *str, void *param)
-{
-	wchar_t *p = (param == NULL) ? _UU("CMD_EVAL_NOT_EMPTY") : (wchar_t *)param;
-
-	if (UniIsEmptyStr(str) == false)
-	{
-		return true;
-	}
-
-	c->Write(c, p);
-
-	return false;
-}
-
-// Evaluation function for minimum / maximum value of the parameter
-bool CmdEvalMinMax(CONSOLE *c, wchar_t *str, void *param)
-{
-	CMD_EVAL_MIN_MAX *e;
-	wchar_t *tag;
-	UINT v;
-	// Validate arguments
-	if (param == NULL)
-	{
-		return false;
-	}
-
-	e = (CMD_EVAL_MIN_MAX *)param;
-
-	if (e->StrName == NULL)
-	{
-		tag = _UU("CMD_EVAL_MIN_MAX");
-	}
-	else
-	{
-		tag = _UU(e->StrName);
-	}
-
-	v = UniToInt(str);
-
-	if (v >= e->MinValue && v <= e->MaxValue)
-	{
-		return true;
-	}
-	else
-	{
-		wchar_t tmp[MAX_SIZE];
-
-		UniFormat(tmp, sizeof(tmp), tag, e->MinValue, e->MaxValue);
-		c->Write(c, tmp);
-
-		return false;
-	}
-}
-
-// Get the help string of command
-void GetCommandHelpStr(char *command_name, wchar_t **description, wchar_t **args, wchar_t **help)
-{
-	char tmp1[128], tmp2[128], tmp3[128];
-
-	Format(tmp1, sizeof(tmp1), "CMD_%s", command_name);
-	Format(tmp2, sizeof(tmp2), "CMD_%s_ARGS", command_name);
-	Format(tmp3, sizeof(tmp3), "CMD_%s_HELP", command_name);
-
-	if (description != NULL)
-	{
-		*description = _UU(tmp1);
-		if (UniIsEmptyStr(*description))
-		{
-			*description = _UU("CMD_UNKNOWM");
-		}
-	}
-
-	if (args != NULL)
-	{
-		*args = _UU(tmp2);
-		if (UniIsEmptyStr(*args))
-		{
-			*args = _UU("CMD_UNKNOWN_ARGS");
-		}
-	}
-
-	if (help != NULL)
-	{
-		*help = _UU(tmp3);
-		if (UniIsEmptyStr(*help))
-		{
-			*help = _UU("CMD_UNKNOWN_HELP");
-		}
-	}
-}
-
-// Get the help string for parameter
-void GetCommandParamHelpStr(char *command_name, char *param_name, wchar_t **description)
-{
-	char tmp[160];
-	if (description == NULL)
-	{
-		return;
-	}
-
-	Format(tmp, sizeof(tmp), "CMD_%s_%s", command_name, param_name);
-
-	*description = _UU(tmp);
-
-	if (UniIsEmptyStr(*description))
-	{
-		*description = _UU("CMD_UNKNOWN_PARAM");
-	}
-}
-
-// String comparison function
-int CompareCandidateStr(void *p1, void *p2)
-{
-	char *s1, *s2;
-	if (p1 == NULL || p2 == NULL)
-	{
-		return 0;
-	}
-	s1 = *(char **)p1;
-	s2 = *(char **)p2;
-	if (s1 == NULL || s2 == NULL)
-	{
-		return 0;
-	}
-
-	if (s1[0] == '[' && s2[0] != '[')
-	{
-		return -1;
-	}
-	else if (s2[0] == '[' && s1[0] != '[')
-	{
-		return 1;
-	}
-
-	return StrCmp(s1, s2);
-}
-
-// Display the help of the candidate list
-void PrintCandidateHelp(CONSOLE *c, char *cmd_name, TOKEN_LIST *candidate_list, UINT left_space)
-{
-	UINT console_width;
-	UINT max_keyword_width;
-	LIST *o;
-	UINT i;
-	wchar_t *tmpbuf;
-	UINT tmpbuf_size;
-	char *left_space_array;
-	char *max_space_array;
-	// Validate arguments
-	if (c == NULL || candidate_list == NULL)
-	{
-		return;
-	}
-
-	// Get the width of the screen
-	console_width = GetConsoleWidth(c) - 1;
-
-	tmpbuf_size = sizeof(wchar_t) * (console_width + 32);
-	tmpbuf = Malloc(tmpbuf_size);
-
-	left_space_array = MakeCharArray(' ', left_space);
-
-	// Sort and enlist the command name
-	// no need to sort the parameter name
-	o = NewListFast(cmd_name == NULL ? CompareCandidateStr : NULL);
-
-	max_keyword_width = 0;
-
-	for (i = 0;i < candidate_list->NumTokens;i++)
-	{
-		UINT keyword_width;
-
-		// Get the width of each keyword
-		Insert(o, candidate_list->Token[i]);
-
-		keyword_width = StrWidth(candidate_list->Token[i]);
-		if (cmd_name != NULL)
-		{
-			if (candidate_list->Token[i][0] != '[')
-			{
-				keyword_width += 1;
-			}
-			else
-			{
-				keyword_width -= 2;
-			}
-		}
-
-		max_keyword_width = MAX(max_keyword_width, keyword_width);
-	}
-
-	max_space_array = MakeCharArray(' ', max_keyword_width);
-
-	// Display the candidate
-	for (i = 0;i < LIST_NUM(o);i++)
-	{
-		char tmp[128];
-		char *name = LIST_DATA(o, i);
-		UNI_TOKEN_LIST *t;
-		wchar_t *help;
-		UINT j;
-		UINT keyword_start_width = left_space;
-		UINT descript_start_width = left_space + max_keyword_width + 1;
-		UINT descript_width;
-		char *space;
-
-		if (console_width >= (descript_start_width + 5))
-		{
-			descript_width = console_width - descript_start_width - 3;
-		}
-		else
-		{
-			descript_width = 2;
-		}
-
-		// Generate the name
-		if (cmd_name != NULL && name[0] != '[')
-		{
-			// Prepend a "/" in the case of a parameter
-			Format(tmp, sizeof(tmp), "/%s", name);
-		}
-		else
-		{
-			// Use the characters as it is in the case of a command name
-			if (cmd_name == NULL)
-			{
-				StrCpy(tmp, sizeof(tmp), name);
-			}
-			else
-			{
-				StrCpy(tmp, sizeof(tmp), name + 1);
-				if (StrLen(tmp) >= 1)
-				{
-					tmp[StrLen(tmp) - 1] = 0;
-				}
-			}
-		}
-
-		// Get the help string
-		if (cmd_name == NULL)
-		{
-			GetCommandHelpStr(name, &help, NULL, NULL);
-		}
-		else
-		{
-			GetCommandParamHelpStr(cmd_name, name, &help);
-		}
-
-		space = MakeCharArray(' ', max_keyword_width - StrWidth(name) - (cmd_name == NULL ? 0 : (name[0] != '[' ? 1 : -2)));
-
-		t = SeparateStringByWidth(help, descript_width);
-
-		for (j = 0;j < t->NumTokens;j++)
-		{
-			if (j == 0)
-			{
-				UniFormat(tmpbuf, tmpbuf_size, L"%S%S%S - %s",
-					left_space_array, tmp, space, t->Token[j]);
-			}
-			else
-			{
-				UniFormat(tmpbuf, tmpbuf_size, L"%S%S   %s",
-					left_space_array, max_space_array, t->Token[j]);
-			}
-
-			c->Write(c, tmpbuf);
-		}
-
-		Free(space);
-
-		UniFreeToken(t);
-	}
-
-	ReleaseList(o);
-
-	Free(max_space_array);
-	Free(tmpbuf);
-	Free(left_space_array);
-}
-
-// Acquisition whether word characters
-bool IsWordChar(wchar_t c)
-{
-	if (c >= L'a' && c <= 'z')
-	{
-		return true;
-	}
-	if (c >= L'A' && c <= 'Z')
-	{
-		return true;
-	}
-	if (c >= L'0' && c <= '9')
-	{
-		return true;
-	}
-	if (c == L'_')
-	{
-		return true;
-	}
-	if (c == L'.')
-	{
-		return true;
-	}
-	if (c == L'\"')
-	{
-		return true;
-	}
-	if (c == L'\'')
-	{
-		return true;
-	}
-	if (c == L',')
-	{
-		return true;
-	}
-	if (c == L')')
-	{
-		return true;
-	}
-	if (c == L']')
-	{
-		return true;
-	}
-
-	return false;
-}
-
-// Get the character width of the word that comes next
-UINT GetNextWordWidth(wchar_t *str)
-{
-	UINT i;
-	UINT ret;
-	// Validate arguments
-	if (str == NULL)
-	{
-		return 0;
-	}
-
-	ret = 0;
-
-	for (i = 0;;i++)
-	{
-		wchar_t c = str[i];
-
-		if (c == 0)
-		{
-			break;
-		}
-
-		if (IsWordChar(c) == false)
-		{
-			break;
-		}
-
-		ret++;
-	}
-
-	return ret;
-}
-
-// Split a string into specified width
-UNI_TOKEN_LIST *SeparateStringByWidth(wchar_t *str, UINT width)
-{
-	UINT wp;
-	wchar_t *tmp;
-	UINT len, i;
-	LIST *o;
-	UNI_TOKEN_LIST *ret;
-	// Validate arguments
-	if (str == NULL)
-	{
-		return UniNullToken();
-	}
-	if (width == 0)
-	{
-		width = 1;
-	}
-
-	o = NewListFast(NULL);
-
-	len = UniStrLen(str);
-	tmp = ZeroMalloc(sizeof(wchar_t) * (len + 32));
-	wp = 0;
-
-	for (i = 0;i < (len + 1);i++)
-	{
-		wchar_t c = str[i];
-		UINT next_word_width;
-		UINT remain_width;
-
-		switch (c)
-		{
-		case 0:
-		case L'\r':
-		case L'\n':
-			if (c == L'\r')
-			{
-				if (str[i + 1] == L'\n')
-				{
-					i++;
-				}
-			}
-
-			tmp[wp++] = 0;
-			wp = 0;
-
-			Insert(o, UniCopyStr(tmp));
-			break;
-
-		default:
-			next_word_width = GetNextWordWidth(&str[i]);
-			remain_width = (width - UniStrWidth(tmp));
-
-			if ((remain_width >= 1) && (next_word_width > remain_width) && (next_word_width <= width))
-			{
-				tmp[wp++] = 0;
-				wp = 0;
-
-				Insert(o, UniCopyStr(tmp));
-			}
-
-			tmp[wp++] = c;
-			tmp[wp] = 0;
-			if (UniStrWidth(tmp) >= width)
-			{
-				tmp[wp++] = 0;
-				wp = 0;
-
-				Insert(o, UniCopyStr(tmp));
-			}
-			break;
-		}
-	}
-
-	if (LIST_NUM(o) == 0)
-	{
-		Insert(o, CopyUniStr(L""));
-	}
-
-	ret = ZeroMalloc(sizeof(UNI_TOKEN_LIST));
-	ret->NumTokens = LIST_NUM(o);
-	ret->Token = ZeroMalloc(sizeof(wchar_t *) * ret->NumTokens);
-
-	for (i = 0;i < LIST_NUM(o);i++)
-	{
-		wchar_t *s = LIST_DATA(o, i);
-
-		UniTrimLeft(s);
-
-		ret->Token[i] = s;
-	}
-
-	ReleaseList(o);
-	Free(tmp);
-
-	return ret;
-}
-
-// Check whether the specified string means 'help'
-bool IsHelpStr(char *str)
-{
-	// Validate arguments
-	if (str == NULL)
-	{
-		return false;
-	}
-
-	if (StrCmpi(str, "help") == 0 || StrCmpi(str, "?") == 0 ||
-		StrCmpi(str, "man") == 0 || StrCmpi(str, "/man") == 0 ||
-		StrCmpi(str, "-man") == 0 || StrCmpi(str, "--man") == 0 ||
-		StrCmpi(str, "/help") == 0 || StrCmpi(str, "/?") == 0 ||
-		StrCmpi(str, "-help") == 0 || StrCmpi(str, "-?") == 0 ||
-		StrCmpi(str, "/h") == 0 || StrCmpi(str, "--help") == 0 ||
-		StrCmpi(str, "--?") == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-// Execution of the command
-bool DispatchNextCmd(CONSOLE *c, char *prompt, CMD cmd[], UINT num_cmd, void *param)
-{
-	return DispatchNextCmdEx(c, NULL, prompt, cmd, num_cmd, param);
-}
-bool DispatchNextCmdEx(CONSOLE *c, wchar_t *exec_command, char *prompt, CMD cmd[], UINT num_cmd, void *param)
-{
-	wchar_t *str;
-	wchar_t *tmp;
-	char *cmd_name;
-	bool b_exit = false;
-	wchar_t *cmd_param;
-	UINT ret = ERR_NO_ERROR;
-	TOKEN_LIST *t;
-	TOKEN_LIST *candidate;
-	bool no_end_crlf = false;
-	UINT i;
-	// Validate arguments
-	if (c == NULL || (num_cmd >= 1 && cmd == NULL))
-	{
-		return false;
-	}
-
-	if (exec_command == NULL)
-	{
-		// Show the prompt
-RETRY:
-		tmp = CopyStrToUni(prompt);
-
-		if (c->ProgrammingMode)
-		{
-			wchar_t tmp2[MAX_PATH];
-
-			UniFormat(tmp2, sizeof(tmp2), L"[PROMPT:%u:%s]\r\n", c->RetCode, tmp);
-
-			Free(tmp);
-
-			tmp = CopyUniStr(tmp2);
-		}
-
-		str = c->ReadLine(c, tmp, false);
-		Free(tmp);
-
-		if (str != NULL && IsEmptyUniStr(str))
-		{
-			Free(str);
-			goto RETRY;
-		}
-	}
-	else
-	{
-		wchar_t tmp[MAX_SIZE];
-		// Use exec_command
-		if (UniStartWith(exec_command, L"vpncmd") == false)
-		{
-			if (prompt != NULL)
-			{
-				if (c->ConsoleType != CONSOLE_CSV)
-				{
-					UniFormat(tmp, sizeof(tmp), L"%S%s", prompt, exec_command);
-					c->Write(c, tmp);
-				}
-			}
-		}
-		str = CopyUniStr(exec_command);
-	}
-
-	if (str == NULL)
-	{
-		// User canceled
-		return false;
-	}
-
-	UniTrimCrlf(str);
-	UniTrim(str);
-
-	if (UniIsEmptyStr(str))
-	{
-		// Do Nothing
-		Free(str);
-		return true;
-	}
-
-	// Divide into command name and parameter
-	if (SeparateCommandAndParam(str, &cmd_name, &cmd_param) == false)
-	{
-		// Do Nothing
-		Free(str);
-		return true;
-	}
-
-	if (StrLen(cmd_name) >= 2 && cmd_name[0] == '?' && cmd_name[1] != '?')
-	{
-		char tmp[MAX_SIZE];
-		wchar_t *s;
-
-		StrCpy(tmp, sizeof(tmp), cmd_name + 1);
-		StrCpy(cmd_name, 0, tmp);
-
-		s = UniCopyStr(L"/?");
-		Free(cmd_param);
-
-		cmd_param = s;
-	}
-
-	if (StrLen(cmd_name) >= 2 && EndWith(cmd_name, "?") && cmd_name[StrLen(cmd_name) - 2] != '?')
-	{
-		wchar_t *s;
-
-		cmd_name[StrLen(cmd_name) - 1] = 0;
-
-		s = UniCopyStr(L"/?");
-		Free(cmd_param);
-
-		cmd_param = s;
-	}
-
-	// Get the candidate of command
-	t = ZeroMalloc(sizeof(TOKEN_LIST));
-	t->NumTokens = num_cmd;
-	t->Token = ZeroMalloc(sizeof(char *) * t->NumTokens);
-	for (i = 0;i < t->NumTokens;i++)
-	{
-		t->Token[i] = CopyStr(cmd[i].Name);
-	}
-
-	if (IsHelpStr(cmd_name))
-	{
-		if (UniIsEmptyStr(cmd_param))
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			// Display the list of commands that can be used
-			UniFormat(tmp, sizeof(tmp), _UU("CMD_HELP_1"), t->NumTokens);
-			c->Write(c, tmp);
-
-			PrintCandidateHelp(c, NULL, t, 1);
-
-			c->Write(c, L"");
-			c->Write(c, _UU("CMD_HELP_2"));
-		}
-		else
-		{
-			char *cmd_name;
-
-			// Display the help for the specified command
-			if (SeparateCommandAndParam(cmd_param, &cmd_name, NULL))
-			{
-				bool b = true;
-
-				if (IsHelpStr(cmd_name))
-				{
-					b = false;
-				}
-
-				if (b)
-				{
-					wchar_t str[MAX_SIZE];
-
-					UniFormat(str, sizeof(str), L"%S /help", cmd_name);
-					DispatchNextCmdEx(c, str, NULL, cmd, num_cmd, param);
-					no_end_crlf = true;
-				}
-
-				Free(cmd_name);
-			}
-		}
-	}
-	else if (StrCmpi(cmd_name, "exit") == 0 || StrCmpi(cmd_name, "quit") == 0)
-	{
-		// Exit
-		b_exit = true;
-	}
-	else
-	{
-		candidate = GetRealnameCandidate(cmd_name, t);
-
-		if (candidate == NULL || candidate->NumTokens == 0)
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			// No candidate
-			UniFormat(tmp, sizeof(tmp), _UU("CON_UNKNOWN_CMD"), cmd_name);
-			c->Write(c, tmp);
-
-			c->RetCode = ERR_BAD_COMMAND_OR_PARAM;
-		}
-		else if (candidate->NumTokens >= 2)
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			// There is more than one candidate
-			UniFormat(tmp, sizeof(tmp), _UU("CON_AMBIGUOUS_CMD"), cmd_name);
-			c->Write(c, tmp);
-			c->Write(c, _UU("CON_AMBIGUOUS_CMD_1"));
-			PrintCandidateHelp(c, NULL, candidate, 1);
-			c->Write(c, _UU("CON_AMBIGUOUS_CMD_2"));
-
-			c->RetCode = ERR_BAD_COMMAND_OR_PARAM;
-		}
-		else
-		{
-			char *real_cmd_name;
-			UINT i;
-
-			// The candidate was shortlisted to one
-			real_cmd_name = candidate->Token[0];
-
-			for (i = 0;i < num_cmd;i++)
-			{
-				if (StrCmpi(cmd[i].Name, real_cmd_name) == 0)
-				{
-					if (cmd[i].Proc != NULL)
-					{
-						// Show the description of the command if it isn't in CSV mode
-						if(c->ConsoleType != CONSOLE_CSV)
-						{
-							wchar_t tmp[256];
-							wchar_t *note;
-
-							GetCommandHelpStr(cmd[i].Name, &note, NULL, NULL);
-							UniFormat(tmp, sizeof(tmp), _UU("CMD_EXEC_MSG_NAME"), cmd[i].Name, note);
-							c->Write(c, tmp);
-						}
-
-						// Call the procedure of the command
-						ret = cmd[i].Proc(c, cmd[i].Name, cmd_param, param);
-
-						if (ret == INFINITE)
-						{
-							// Exit command
-							b_exit = true;
-						}
-						else
-						{
-							c->RetCode = ret;
-						}
-					}
-				}
-			}
-		}
-
-		FreeToken(candidate);
-	}
-
-	FreeToken(t);
-	Free(str);
-	Free(cmd_name);
-	Free(cmd_param);
-
-	if (no_end_crlf == false)
-	{
-		//c->Write(c, L"");
-	}
-
-	if (b_exit)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Get the width of the current console
-UINT GetConsoleWidth(CONSOLE *c)
-{
-	UINT size;
-
-	size = c->GetWidth(c);
-
-	if (size == 0)
-	{
-		size = 80;
-	}
-
-	if (size < 32)
-	{
-		size = 32;
-	}
-
-	if (size > 65536)
-	{
-		size = 65535;
-	}
-
-	return size;
-}
-
-// Separate the command line into the command and the parameters
-bool SeparateCommandAndParam(wchar_t *src, char **cmd, wchar_t **param)
-{
-	UINT i, len, wp;
-	wchar_t *tmp;
-	wchar_t *src_tmp;
-	// Validate arguments
-	if (src == NULL)
-	{
-		return false;
-	}
-	if (cmd != NULL)
-	{
-		*cmd = NULL;
-	}
-	if (param != NULL)
-	{
-		*param = NULL;
-	}
-
-	src_tmp = UniCopyStr(src);
-	UniTrimCrlf(src_tmp);
-	UniTrim(src_tmp);
-
-	len = UniStrLen(src_tmp);
-	tmp = Malloc(sizeof(wchar_t) * (len + 32));
-	wp = 0;
-
-	for (i = 0;i < (len + 1);i++)
-	{
-		wchar_t c = src_tmp[i];
-
-		switch (c)
-		{
-		case 0:
-		case L' ':
-		case L'\t':
-			tmp[wp] = 0;
-			if (UniIsEmptyStr(tmp))
-			{
-				Free(tmp);
-				Free(src_tmp);
-				return false;
-			}
-			if (cmd != NULL)
-			{
-				*cmd = CopyUniToStr(tmp);
-				Trim(*cmd);
-			}
-			goto ESCAPE;
-
-		default:
-			tmp[wp++] = c;
-			break;
-		}
-	}
-
-ESCAPE:
-	if (param != NULL)
-	{
-		*param = CopyUniStr(&src_tmp[wp]);
-		UniTrim(*param);
-	}
-
-	Free(tmp);
-	Free(src_tmp);
-
-	return true;
-}
-
-// Get the candidates list of of the real command name whose abbreviation matches to the command specified by the user
-TOKEN_LIST *GetRealnameCandidate(char *input_name, TOKEN_LIST *real_name_list)
-{
-	TOKEN_LIST *ret;
-	LIST *o;
-	UINT i;
-	bool ok = false;
-	// Validate arguments
-	if (input_name == NULL || real_name_list == NULL)
-	{
-		return NullToken();
-	}
-
-	o = NewListFast(NULL);
-
-	for (i = 0;i < real_name_list->NumTokens;i++)
-	{
-		char *name = real_name_list->Token[i];
-
-		// Search for an exact match with the highest priority first
-		if (StrCmpi(name, input_name) == 0)
-		{
-			Insert(o, name);
-			ok = true;
-			break;
-		}
-	}
-
-	if (ok == false)
-	{
-		// If there is no command to exact match, check whether it matches to a short form command
-		for (i = 0;i < real_name_list->NumTokens;i++)
-		{
-			char *name = real_name_list->Token[i];
-
-			if (IsOmissionName(input_name, name) || IsNameInRealName(input_name, name))
-			{
-				// A abbreviation is found
-				Insert(o, name);
-				ok = true;
-			}
-		}
-	}
-
-	if (ok)
-	{
-		// One or more candidate is found
-		ret = ListToTokenList(o);
-	}
-	else
-	{
-		ret = NullToken();
-	}
-
-	ReleaseList(o);
-
-	return ret;
-}
-
-// Check whether the command specified by the user is a abbreviation of existing commands
-bool IsOmissionName(char *input_name, char *real_name)
-{
-	char oname[128];
-	// Validate arguments
-	if (input_name == NULL || real_name == NULL)
-	{
-		return false;
-	}
-
-	if (IsAllUpperStr(real_name))
-	{
-		// Command of all capital letters do not take abbreviations
-		return false;
-	}
-
-	GetOmissionName(oname, sizeof(oname), real_name);
-
-	if (IsEmptyStr(oname))
-	{
-		return false;
-	}
-
-	if (StartWith(oname, input_name))
-	{
-		// Example: The oname of AccountSecureCertSet is "ascs".
-		// But if the user enters "asc", returns true
-		return true;
-	}
-
-	if (StartWith(input_name, oname))
-	{
-		// Example: When two commands AccountCreate and AccountConnect exist,
-		// if the user enter "aconnect" , only AccountConnect is true
-
-		if (EndWith(real_name, &input_name[StrLen(oname)]))
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-// Get the short name of the specified command
-void GetOmissionName(char *dst, UINT size, char *src)
-{
-	UINT i, len;
-	// Validate arguments
-	if (dst == NULL || src == NULL)
-	{
-		return;
-	}
-
-	StrCpy(dst, size, "");
-	len = StrLen(src);
-
-	for (i = 0;i < len;i++)
-	{
-		char c = src[i];
-
-		if ((c >= '0' && c <= '9') ||
-			(c >= 'A' && c <= 'Z'))
-		{
-			char tmp[2];
-			tmp[0] = c;
-			tmp[1] = 0;
-
-			StrCat(dst, size, tmp);
-		}
-	}
-}
-
-// Check whether the command specified by the user matches the existing commands
-bool IsNameInRealName(char *input_name, char *real_name)
-{
-	// Validate arguments
-	if (input_name == NULL || real_name == NULL)
-	{
-		return false;
-	}
-
-	if (StartWith(real_name, input_name))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-// Parse the command list
-LIST *ParseCommandList(CONSOLE *c, char *cmd_name, wchar_t *command, PARAM param[], UINT num_param)
-{
-	UINT i;
-	LIST *o;
-	bool ok = true;
-	TOKEN_LIST *param_list;
-	TOKEN_LIST *real_name_list;
-	bool help_mode = false;
-	wchar_t *tmp;
-	// Validate arguments
-	if (c == NULL || command == NULL || (num_param >= 1 && param == NULL) || cmd_name == NULL)
-	{
-		return NULL;
-	}
-
-	// Initialization
-	for (i = 0;i < num_param;i++)
-	{
-		if (IsEmptyStr(param[i].Name) == false)
-		{
-			if (param[i].Name[0] == '[')
-			{
-				param[i].Tmp = "";
-			}
-			else
-			{
-				param[i].Tmp = NULL;
-			}
-		}
-		else
-		{
-			param[i].Tmp = "";
-		}
-	}
-
-	real_name_list = ZeroMalloc(sizeof(TOKEN_LIST));
-	real_name_list->NumTokens = num_param;
-	real_name_list->Token = ZeroMalloc(sizeof(char *) * real_name_list->NumTokens);
-
-	for (i = 0;i < real_name_list->NumTokens;i++)
-	{
-		real_name_list->Token[i] = CopyStr(param[i].Name);
-	}
-
-	// Generate a list of parameter name specified by the user
-	param_list = GetCommandNameList(command);
-
-	for (i = 0;i < param_list->NumTokens;i++)
-	{
-		char *s = param_list->Token[i];
-
-		if (StrCmpi(s, "help") == 0 || StrCmpi(s, "?") == 0)
-		{
-			help_mode = true;
-			break;
-		}
-	}
-
-	tmp = ParseCommand(command, L"");
-	if (tmp != NULL)
-	{
-		if (UniStrCmpi(tmp, L"?") == 0)
-		{
-			help_mode = true;
-		}
-		Free(tmp);
-	}
-
-	if (help_mode)
-	{
-		// Show the help
-		PrintCmdHelp(c, cmd_name, real_name_list);
-		FreeToken(param_list);
-		FreeToken(real_name_list);
-		return NULL;
-	}
-
-	for (i = 0;i < param_list->NumTokens;i++)
-	{
-		// Get the corresponding commands for all parameter names which is specified by the user
-		TOKEN_LIST *candidate = GetRealnameCandidate(param_list->Token[i], real_name_list);
-
-		if (candidate != NULL && candidate->NumTokens >= 1)
-		{
-			if (candidate->NumTokens >= 2)
-			{
-				wchar_t tmp[MAX_SIZE];
-
-				// There is more than one candidate
-				UniFormat(tmp, sizeof(tmp), _UU("CON_AMBIGUOUS_PARAM"), param_list->Token[i]);
-				c->Write(c, tmp);
-				UniFormat(tmp, sizeof(tmp), _UU("CON_AMBIGUOUS_PARAM_1"), cmd_name);
-				c->Write(c, tmp);
-
-				PrintCandidateHelp(c, cmd_name, candidate, 1);
-
-				c->Write(c, _UU("CON_AMBIGUOUS_PARAM_2"));
-
-				ok = false;
-			}
-			else
-			{
-				UINT j;
-				char *real_name = candidate->Token[0];
-
-				// There is only one candidate
-				for (j = 0;j < num_param;j++)
-				{
-					if (StrCmpi(param[j].Name, real_name) == 0)
-					{
-						param[j].Tmp = param_list->Token[i];
-					}
-				}
-			}
-		}
-		else
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			// No candidate
-			UniFormat(tmp, sizeof(tmp), _UU("CON_INVALID_PARAM"), param_list->Token[i], cmd_name, cmd_name);
-			c->Write(c, tmp);
-
-			ok = false;
-		}
-
-		FreeToken(candidate);
-	}
-
-	if (ok == false)
-	{
-		FreeToken(param_list);
-		FreeToken(real_name_list);
-
-		return NULL;
-	}
-
-	// Creating a list
-	o = NewParamValueList();
-
-	// Read all the parameters of the specified name in the parameter list
-	for (i = 0;i < num_param;i++)
-	{
-		bool prompt_input_value = false;
-		PARAM *p = &param[i];
-
-		if (p->Tmp != NULL || p->PromptProc != NULL)
-		{
-			wchar_t *name = CopyStrToUni(p->Name);
-			wchar_t *tmp;
-			wchar_t *str;
-
-			if (p->Tmp != NULL)
-			{
-				tmp = CopyStrToUni(p->Tmp);
-			}
-			else
-			{
-				tmp = CopyStrToUni(p->Name);
-			}
-
-			str = ParseCommand(command, tmp);
-			Free(tmp);
-			if (str != NULL)
-			{
-				wchar_t *unistr;
-				bool ret;
-EVAL_VALUE:
-				// Reading succeeded
-				unistr = str;
-
-				if (p->EvalProc != NULL)
-				{
-					// Evaluate the value if EvalProc is specified
-					ret = p->EvalProc(c, unistr, p->EvalProcParam);
-				}
-				else
-				{
-					// Accept any value if EvalProc is not specified
-					ret = true;
-				}
-
-				if (ret == false)
-				{
-					// The specified value is invalid
-					if (p->PromptProc == NULL)
-					{
-						// Cancel
-						ok = false;
-						Free(name);
-						Free(str);
-						break;
-					}
-					else if (c->ProgrammingMode)
-					{
-						// In the programming mode, return the error immediately.
-						ok = false;
-						Free(name);
-						Free(str);
-						break;
-					}
-					else
-					{
-						// Request to re-enter
-						Free(str);
-						str = NULL;
-						goto SHOW_PROMPT;
-					}
-				}
-				else
-				{
-					PARAM_VALUE *v;
-					// Finished loading, add it to the list
-					v = ZeroMalloc(sizeof(PARAM_VALUE));
-					v->Name = CopyStr(p->Name);
-					v->StrValue = CopyUniToStr(str);
-					v->UniStrValue = CopyUniStr(str);
-					v->IntValue = ToInt(v->StrValue);
-					Insert(o, v);
-				}
-			}
-			else
-			{
-				// Failed to read. The parameter is not specified
-				if (p->PromptProc != NULL)
-				{
-					wchar_t *tmp;
-SHOW_PROMPT:
-					// Prompt because it is a mandatory parameter
-					tmp = NULL;
-					if (c->ProgrammingMode == false)
-					{
-						tmp = p->PromptProc(c, p->PromptProcParam);
-					}
-					if (tmp == NULL)
-					{
-						// User canceled
-						ok = false;
-						Free(str);
-						Free(name);
-						break;
-					}
-					else
-					{
-						// Entered by the user
-						c->Write(c, L"");
-						str = tmp;
-						prompt_input_value = true;
-						goto EVAL_VALUE;
-					}
-				}
-			}
-
-			Free(str);
-			Free(name);
-		}
-	}
-
-	FreeToken(param_list);
-	FreeToken(real_name_list);
-
-	if (ok)
-	{
-		return o;
-	}
-	else
-	{
-		FreeParamValueList(o);
-		return NULL;
-	}
-}
-
-// Acquisition of [Yes] or [No]
-bool GetParamYes(LIST *o, char *name)
-{
-	char *s;
-	char tmp[64];
-	// Validate arguments
-	if (o == NULL)
-	{
-		return false;
-	}
-
-	s = GetParamStr(o, name);
-	if (s == NULL)
-	{
-		return false;
-	}
-
-	StrCpy(tmp, sizeof(tmp), s);
-	Trim(tmp);
-
-	if (StartWith(tmp, "y"))
-	{
-		return true;
-	}
-
-	if (StartWith(tmp, "t"))
-	{
-		return true;
-	}
-
-	if (ToInt(tmp) != 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-// Acquisition of parameter value Int
-UINT GetParamInt(LIST *o, char *name)
-{
-	PARAM_VALUE *v;
-	// Validate arguments
-	if (o == NULL)
-	{
-		return 0;
-	}
-
-	v = FindParamValue(o, name);
-	if (v == NULL)
-	{
-		return 0;
-	}
-	else
-	{
-		return v->IntValue;
-	}
-}
-
-// Acquisition of parameter value Unicode string
-wchar_t *GetParamUniStr(LIST *o, char *name)
-{
-	PARAM_VALUE *v;
-	// Validate arguments
-	if (o == NULL)
-	{
-		return NULL;
-	}
-
-	v = FindParamValue(o, name);
-	if (v == NULL)
-	{
-		return NULL;
-	}
-	else
-	{
-		return v->UniStrValue;
-	}
-}
-
-// Acquisition of the parameter value string
-char *GetParamStr(LIST *o, char *name)
-{
-	PARAM_VALUE *v;
-	// Validate arguments
-	if (o == NULL)
-	{
-		return NULL;
-	}
-
-	v = FindParamValue(o, name);
-	if (v == NULL)
-	{
-		return NULL;
-	}
-	else
-	{
-		return v->StrValue;
-	}
-}
-
-// Acquisition of parameter value
-PARAM_VALUE *FindParamValue(LIST *o, char *name)
-{
-	PARAM_VALUE t, *ret;
-	// Validate arguments
-	if (o == NULL)
-	{
-		return NULL;
-	}
-	if (name == NULL)
-	{
-		name = "";
-	}
-
-	Zero(&t, sizeof(t));
-	t.Name = name;
-
-	ret = Search(o, &t);
-
-	return ret;
-}
-
-// Release of the parameter value list
-void FreeParamValueList(LIST *o)
-{
-	UINT i;
-	// Validate arguments
-	if (o == NULL)
-	{
-		return;
-	}
-
-	for (i = 0;i < LIST_NUM(o);i++)
-	{
-		PARAM_VALUE *v = LIST_DATA(o, i);
-
-		Free(v->StrValue);
-		Free(v->UniStrValue);
-		Free(v->Name);
-		Free(v);
-	}
-
-	ReleaseList(o);
-}
-
-// Parameter value list sort function
-int CmpParamValue(void *p1, void *p2)
-{
-	PARAM_VALUE *v1, *v2;
-	if (p1 == NULL || p2 == NULL)
-	{
-		return 0;
-	}
-	v1 = *(PARAM_VALUE **)p1;
-	v2 = *(PARAM_VALUE **)p2;
-	if (v1 == NULL || v2 == NULL)
-	{
-		return 0;
-	}
-
-	if (IsEmptyStr(v1->Name) && IsEmptyStr(v2->Name))
-	{
-		return 0;
-	}
-	return StrCmpi(v1->Name, v2->Name);
-}
-
-// Generation of the parameter value list
-LIST *NewParamValueList()
-{
-	return NewListFast(CmpParamValue);
-}
-
-// Get the list of parameter names that were included in the entered command
-TOKEN_LIST *GetCommandNameList(wchar_t *str)
-{
-	TOKEN_LIST *t;
-	// Validate arguments
-	if (str == NULL)
-	{
-		return NullToken();
-	}
-
-	Free(ParseCommandEx(str, L"dummy_str", &t));
-
-	return t;
-}
-
-// Get the commands that start with the specified name
-wchar_t *ParseCommand(wchar_t *str, wchar_t *name)
-{
-	return ParseCommandEx(str, name, NULL);
-}
-wchar_t *ParseCommandEx(wchar_t *str, wchar_t *name, TOKEN_LIST **param_list)
-{
-	UNI_TOKEN_LIST *t;
-	UINT i;
-	wchar_t *tmp;
-	wchar_t *ret = NULL;
-	LIST *o;
-	// Validate arguments
-	if (str == NULL)
-	{
-		return NULL;
-	}
-	if (name != NULL && UniIsEmptyStr(name))
-	{
-		name = NULL;
-	}
-
-	o = NULL;
-	if (param_list != NULL)
-	{
-		o = NewListFast(CompareStr);
-	}
-
-	tmp = CopyUniStr(str);
-	UniTrim(tmp);
-
-	i = UniSearchStrEx(tmp, L"/CMD ", 0, false);
-
-	if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
-	{
-		i = INFINITE;
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"/CMD\t", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
-		{
-			i = INFINITE;
-		}
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"/CMD:", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
-		{
-			i = INFINITE;
-		}
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"/CMD=", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
-		{
-			i = INFINITE;
-		}
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"-CMD ", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
-		{
-			i = INFINITE;
-		}
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"-CMD\t", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
-		{
-			i = INFINITE;
-		}
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"-CMD:", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
-		{
-			i = INFINITE;
-		}
-	}
-	if (i == INFINITE)
-	{
-		i = UniSearchStrEx(tmp, L"-CMD=", 0, false);
-		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
-		{
-			i = INFINITE;
-		}
-	}
-
-	if (i != INFINITE)
-	{
-		char *s = CopyStr("CMD");
-		if (InsertStr(o, s) == false)
-		{
-			Free(s);
-		}
-		if (UniStrCmpi(name, L"CMD") == 0)
-		{
-			ret = CopyUniStr(&str[i + 5]);
-			UniTrim(ret);
-		}
-		else
-		{
-			tmp[i] = 0;
-		}
-	}
-
-	if (ret == NULL)
-	{
-		t = UniParseCmdLine(tmp);
-
-		if (t != NULL)
-		{
-			for (i = 0;i < t->NumTokens;i++)
-			{
-				wchar_t *token = t->Token[i];
-
-				if ((token[0] == L'-' && token[1] != L'-') ||
-					(UniStrCmpi(token, L"--help") == 0) ||
-					(token[0] == L'/' && token[1] != L'/'))
-				{
-					UINT i;
-
-					// Named parameter
-					// Examine whether there is a colon character
-
-					if (UniStrCmpi(token, L"--help") == 0)
-					{
-						token++;
-					}
-
-					i = UniSearchStrEx(token, L":", 0, false);
-					if (i == INFINITE)
-					{
-						i = UniSearchStrEx(token, L"=", 0, false);
-					}
-					if (i != INFINITE)
-					{
-						wchar_t *tmp;
-						char *a;
-
-						// There is a colon character
-						tmp = CopyUniStr(token);
-						tmp[i] = 0;
-
-						a = CopyUniToStr(&tmp[1]);
-						if (InsertStr(o, a) == false)
-						{
-							Free(a);
-						}
-
-						if (UniStrCmpi(name, &tmp[1]) == 0)
-						{
-							if (ret == NULL)
-							{
-								// Content
-								ret = UniCopyStr(&token[i + 1]);
-							}
-						}
-
-						Free(tmp);
-					}
-					else
-					{
-						// There is no colon character
-						char *a;
-
-						a = CopyUniToStr(&token[1]);
-						if (InsertStr(o, a) == false)
-						{
-							Free(a);
-						}
-
-						if (UniStrCmpi(name, &token[1]) == 0)
-						{
-							if (ret == NULL)
-							{
-								// Empty character
-								ret = UniCopyStr(L"");
-							}
-						}
-					}
-				}
-				else
-				{
-					// Nameless argument
-					if (name == NULL)
-					{
-						if (ret == NULL)
-						{
-							if (token[0] == L'-' && token[1] == L'-')
-							{
-								ret = UniCopyStr(&token[1]);
-							}
-							else if (token[0] == L'/' && token[1] == L'/')
-							{
-								ret = UniCopyStr(&token[1]);
-							}
-							else
-							{
-								ret = UniCopyStr(token);
-							}
-						}
-					}
-				}
-			}
-
-			UniFreeToken(t);
-		}
-	}
-
-	Free(tmp);
-
-	if (o != NULL)
-	{
-		TOKEN_LIST *t = ZeroMalloc(sizeof(TOKEN_LIST));
-		UINT i;
-
-		t->NumTokens = LIST_NUM(o);
-		t->Token = ZeroMalloc(sizeof(char *) * t->NumTokens);
-
-		for (i = 0;i < t->NumTokens;i++)
-		{
-			t->Token[i] = LIST_DATA(o, i);
-		}
-
-		ReleaseList(o);
-
-		*param_list = t;
-	}
-
-	if (UniStrCmpi(ret, L"none") == 0 || UniStrCmpi(ret, L"null") == 0)
-	{
-		// Null and none are reserved words
-		ret[0] = 0;
-	}
-
-	return ret;
-}
-char *ParseCommandA(wchar_t *str, char *name)
-{
-	wchar_t *tmp1, *tmp2;
-	char *ret;
-	// Validate arguments
-	if (str == NULL)
-	{
-		return NULL;
-	}
-
-	if (name != NULL)
-	{
-		tmp1 = CopyStrToUni(name);
-	}
-	else
-	{
-		tmp1 = NULL;
-	}
-
-	tmp2 = ParseCommand(str, tmp1);
-
-	if (tmp2 == NULL)
-	{
-		ret = NULL;
-	}
-	else
-	{
-		ret = CopyUniToStr(tmp2);
-		Free(tmp2);
-	}
-
-	Free(tmp1);
-
-	return ret;
-}
-
-// Password prompt
-bool PasswordPrompt(char *password, UINT size)
-{
-	UINT wp;
-	bool escape = false;
-	void *console;
-	// Validate arguments
-	if (password == NULL || size <= 1)
-	{
-		if (size >= 1)
-		{
-			password[0] = 0;
-		}
-		return false;
-	}
-
-	wp = 0;
-
-	Zero(password, size);
-
-	console = SetConsoleRaw();
-
-	while (true)
-	{
-		int c;
-
-#ifdef	OS_WIN32
-		c = _getch();
-#else	// OS_WIN32
-		c = getc(stdin);
-#endif	// OS_WIN32
-
-		if (c >= 0x20 && c <= 0x7E)
-		{
-			// Character
-			if ((wp + 1) < size)
-			{
-				password[wp++] = (char)c;
-				putc('*', stdout);
-			}
-		}
-		else if (c == 0x03)
-		{
-			// Break
-			exit(0);
-		}
-		else if (c == 0x04 || c == 0x1a || c == 0x0D || c==0x0A)
-		{
-			// Exit
-			if (c == 0x04 || c == 0x1a)
-			{
-				escape = true;
-			}
-			break;
-		}
-		else if (c == 0xE0)
-		{
-			// Read one more character
-#ifdef	OS_WIN32
-			c = _getch();
-#else	// OS_WIN32
-			c = getc(stdin);
-#endif	// OS_WIN32
-			if (c == 0x4B || c == 0x53)
-			{
-				// Backspace
-				goto BACKSPACE;
-			}
-		}
-		else if (c == 0x08)
-		{
-BACKSPACE:
-			// Backspace
-			if (wp >= 1)
-			{
-				password[--wp] = 0;
-				putc(0x08, stdout);
-				putc(' ', stdout);
-				putc(0x08, stdout);
-			}
-		}
-	}
-	Print("\n");
-
-	RestoreConsole(console);
-
-	return (escape ? false : true);
-}
-
-// Show the prompt
-wchar_t *Prompt(wchar_t *prompt_str)
-{
-	wchar_t *ret = NULL;
-	wchar_t *tmp = NULL;
-	// Validate arguments
-	if (prompt_str == NULL)
-	{
-		prompt_str = L"";
-	}
-
-#ifdef	OS_WIN32
-	UniPrint(L"%s", prompt_str);
-	tmp = Malloc(MAX_PROMPT_STRSIZE);
-	if (fgetws(tmp, MAX_PROMPT_STRSIZE - 1, stdin) != NULL)
-	{
-		bool escape = false;
-		UINT i, len;
-
-		len = UniStrLen(tmp);
-		for (i = 0;i < len;i++)
-		{
-			if (tmp[i] == 0x04 || tmp[i] == 0x1A)
-			{
-				escape = true;
-				break;
-			}
-		}
-
-		if (escape == false)
-		{
-			UniTrimCrlf(tmp);
-
-			ret = UniCopyStr(tmp);
-		}
-	}
-	Free(tmp);
-#else	// OS_WIN32
-	{
-		char *prompt = CopyUniToStr(prompt_str);
-		char *s = readline(prompt);
-		Free(prompt);
-
-		if (s != NULL)
-		{
-			TrimCrlf(s);
-			Trim(s);
-
-			if (IsEmptyStr(s) == false)
-			{
-				add_history(s);
-			}
-
-			ret = CopyStrToUni(s);
-
-			free(s);
-		}
-	}
-#endif	// OS_WIN32
-
-	if (ret == NULL)
-	{
-		Print("\n");
-	}
-
-	return ret;
-}
-char *PromptA(wchar_t *prompt_str)
-{
-	wchar_t *str = Prompt(prompt_str);
-
-	if (str == NULL)
-	{
-		return NULL;
-	}
-	else
-	{
-		char *ret = CopyUniToStr(str);
-
-		Free(str);
-		return ret;
-	}
-}
-
-// Set the console to raw mode
-void *SetConsoleRaw()
-{
-#ifdef	OS_UNIX
-	struct termios t, *ret;
-
-	Zero(&t, sizeof(t));
-	if (tcgetattr(0, &t) != 0)
-	{
-		// Failed
-		return NULL;
-	}
-
-	// Copy the current settings
-	ret = Clone(&t, sizeof(t));
-
-	// Change the settings
-	t.c_lflag &= (~ICANON);
-	t.c_lflag &= (~ECHO);
-	t.c_cc[VTIME] = 0;
-	t.c_cc[VMIN] = 1;
-	tcsetattr(0, TCSANOW, &t);
-
-	return ret;
-#else	// OS_UNIX
-	return Malloc(0);
-#endif	// OS_UNIX
-}
-
-// Restore the mode of the console
-void RestoreConsole(void *p)
-{
-#ifdef	OS_UNIX
-	struct termios *t;
-	// Validate arguments
-	if (p == NULL)
-	{
-		return;
-	}
-
-	t = (struct termios *)p;
-
-	// Restore the settings
-	tcsetattr(0, TCSANOW, t);
-
-	Free(t);
-#else	// OS_UNIX
-	if (p != NULL)
-	{
-		Free(p);
-	}
-#endif	// OS_UNIX
-}
-
-////////////////////////////
-// Local console function
-
-// Creating a new local console
-CONSOLE *NewLocalConsole(wchar_t *infile, wchar_t *outfile)
-{
-	IO *in_io = NULL, *out_io = NULL;
-	CONSOLE *c = ZeroMalloc(sizeof(CONSOLE));
-	LOCAL_CONSOLE_PARAM *p;
-	UINT old_size = 0;
-
-#ifdef	OS_WIN32
-	if (MsGetConsoleWidth() == 80)
-	{
-		//old_size = MsSetConsoleWidth(WIN32_DEFAULT_CONSOLE_WIDTH);
-	}
-#endif	// OS_WIN32
-
-	c->ConsoleType = CONSOLE_LOCAL;
-	c->Free = ConsoleLocalFree;
-	c->ReadLine = ConsoleLocalReadLine;
-	c->ReadPassword = ConsoleLocalReadPassword;
-	c->Write = ConsoleLocalWrite;
-	c->GetWidth = ConsoleLocalGetWidth;
-	c->OutputLock = NewLock();
-
-	if (UniIsEmptyStr(infile) == false)
-	{
-		// Input file is specified
-		in_io = FileOpenW(infile, false);
-		if (in_io == NULL)
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			UniFormat(tmp, sizeof(tmp), _UU("CON_INFILE_ERROR"), infile);
-			c->Write(c, tmp);
-			Free(c);
-			return NULL;
-		}
-		else
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			UniFormat(tmp, sizeof(tmp), _UU("CON_INFILE_START"), infile);
-			c->Write(c, tmp);
-		}
-	}
-
-	if (UniIsEmptyStr(outfile) == false)
-	{
-		// Output file is specified
-		out_io = FileCreateW(outfile);
-		if (out_io == NULL)
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			UniFormat(tmp, sizeof(tmp), _UU("CON_OUTFILE_ERROR"), outfile);
-			c->Write(c, tmp);
-			Free(c);
-
-			if (in_io != NULL)
-			{
-				FileClose(in_io);
-			}
-			return NULL;
-		}
-		else
-		{
-			wchar_t tmp[MAX_SIZE];
-
-			UniFormat(tmp, sizeof(tmp), _UU("CON_OUTFILE_START"), outfile);
-			c->Write(c, tmp);
-		}
-	}
-
-	p = ZeroMalloc(sizeof(LOCAL_CONSOLE_PARAM));
-	c->Param = p;
-
-	p->InFile = in_io;
-	p->OutFile = out_io;
-	p->Win32_OldConsoleWidth = old_size;
-
-	if (in_io != NULL)
-	{
-		UINT size;
-		void *buf;
-
-		size = FileSize(in_io);
-		buf = ZeroMalloc(size + 1);
-		FileRead(in_io, buf, size);
-
-		p->InBuf = NewBuf();
-		WriteBuf(p->InBuf, buf, size);
-		Free(buf);
-
-		p->InBuf->Current = 0;
-	}
-
-	return c;
-}
-
-// Release Console
-void ConsoleLocalFree(CONSOLE *c)
-{
-	LOCAL_CONSOLE_PARAM *p;
-	// Validate arguments
-	if (c == NULL)
-	{
-		return;
-	}
-
-	p = (LOCAL_CONSOLE_PARAM *)c->Param;
-
-#ifdef	OS_WIN32
-	if (p->Win32_OldConsoleWidth != 0)
-	{
-		MsSetConsoleWidth(p->Win32_OldConsoleWidth);
-	}
-#endif	// OS_WIN32
-
-	if (p != NULL)
-	{
-		if (p->InFile != NULL)
-		{
-			FileClose(p->InFile);
-			FreeBuf(p->InBuf);
-		}
-
-		if (p->OutFile != NULL)
-		{
-			FileClose(p->OutFile);
-		}
-
-		Free(p);
-	}
-
-	DeleteLock(c->OutputLock);
-
-	// Memory release
-	Free(c);
-}
-
-// Get the width of the screen
-UINT ConsoleLocalGetWidth(CONSOLE *c)
-{
-	UINT ret = 0;
-	// Validate arguments
-	if (c == NULL)
-	{
-		return 0;
-	}
-
-#ifdef	OS_WIN32
-	ret = MsGetConsoleWidth();
-#else	// OS_WIN32
-	{
-		struct winsize t;
-
-		Zero(&t, sizeof(t));
-
-		if (ioctl(1, TIOCGWINSZ, &t) == 0)
-		{
-			ret = t.ws_col;
-		}
-	}
-#endif	// OS_WIN32
-
-	return ret;
-}
-
-// Read one line from the console
-wchar_t *ConsoleLocalReadLine(CONSOLE *c, wchar_t *prompt, bool nofile)
-{
-	wchar_t *ret;
-	LOCAL_CONSOLE_PARAM *p;
-	// Validate arguments
-	if (c == NULL)
-	{
-		return NULL;
-	}
-	p = (LOCAL_CONSOLE_PARAM *)c->Param;
-	if (prompt == NULL)
-	{
-		prompt = L">";
-	}
-
-	ConsoleWriteOutFile(c, prompt, false);
-
-	if (nofile == false && p->InBuf != NULL)
-	{
-		// Read the next line from the file
-		ret = ConsoleReadNextFromInFile(c);
-
-		if (ret != NULL)
-		{
-			// Display the pseudo prompt
-			UniPrint(L"%s", prompt);
-
-			// Display on the screen
-			UniPrint(L"%s\n", ret);
-		}
-	}
-	else
-	{
-		// Read the following line from the console
-		ret = Prompt(prompt);
-	}
-
-	if (ret != NULL)
-	{
-		ConsoleWriteOutFile(c, ret, true);
-	}
-	else
-	{
-		ConsoleWriteOutFile(c, _UU("CON_USER_CANCEL"), true);
-	}
-
-	return ret;
-}
-
-// Read the password from the console
-char *ConsoleLocalReadPassword(CONSOLE *c, wchar_t *prompt)
-{
-	char tmp[64];
-	// Validate arguments
-	if (c == NULL)
-	{
-		return NULL;
-	}
-	if (prompt == NULL)
-	{
-		prompt = L"Password>";
-	}
-
-	UniPrint(L"%s", prompt);
-	ConsoleWriteOutFile(c, prompt, false);
-
-	if (PasswordPrompt(tmp, sizeof(tmp)))
-	{
-		ConsoleWriteOutFile(c, L"********", true);
-		return CopyStr(tmp);
-	}
-	else
-	{
-		ConsoleWriteOutFile(c, _UU("CON_USER_CANCEL"), true);
-		return NULL;
-	}
-}
-
-// Display a string to the console
-bool ConsoleLocalWrite(CONSOLE *c, wchar_t *str)
-{
-	// Validate arguments
-	if (c == NULL || str == NULL)
-	{
-		return false;
-	}
-
-	UniPrint(L"%s%s", str, (UniEndWith(str, L"\n") ? L"" : L"\n"));
-
-	ConsoleWriteOutFile(c, str, true);
-
-	return true;
-}
-
-// Read the next line from the input file
-wchar_t *ConsoleReadNextFromInFile(CONSOLE *c)
-{
-	LOCAL_CONSOLE_PARAM *p;
-	char *str;
-	// Validate arguments
-	if (c == NULL)
-	{
-		return NULL;
-	}
-
-	p = (LOCAL_CONSOLE_PARAM *)c->Param;
-
-	if (p->InBuf == NULL)
-	{
-		return NULL;
-	}
-
-	while (true)
-	{
-		str = CfgReadNextLine(p->InBuf);
-
-		if (str == NULL)
-		{
-			return NULL;
-		}
-
-		Trim(str);
-
-		if (IsEmptyStr(str) == false)
-		{
-			UINT size;
-			wchar_t *ret;
-
-			size = CalcUtf8ToUni((BYTE *)str, StrLen(str));
-			ret = ZeroMalloc(size + 32);
-			Utf8ToUni(ret, size, (BYTE *)str, StrLen(str));
-
-			Free(str);
-
-			return ret;
-		}
-
-		Free(str);
-	}
-}
-
-// Write when the output file is specified
-void ConsoleWriteOutFile(CONSOLE *c, wchar_t *str, bool add_last_crlf)
-{
-	LOCAL_CONSOLE_PARAM *p;
-	// Validate arguments
-	if (c == NULL || str == NULL)
-	{
-		return;
-	}
-
-	p = (LOCAL_CONSOLE_PARAM *)c->Param;
-
-	if (p != NULL && p->OutFile != NULL)
-	{
-		wchar_t *tmp = UniNormalizeCrlf(str);
-		UINT utf8_size;
-		UCHAR *utf8;
-
-		utf8_size = CalcUniToUtf8(tmp);
-		utf8 = ZeroMalloc(utf8_size + 1);
-		UniToUtf8(utf8, utf8_size + 1, tmp);
-
-		FileWrite(p->OutFile, utf8, utf8_size);
-
-		if (UniEndWith(str, L"\n") == false && add_last_crlf)
-		{
-			char *crlf = "\r\n";
-			FileWrite(p->OutFile, "\r\n", StrLen(crlf));
-		}
-
-		Free(utf8);
-		Free(tmp);
-	}
-
-}
-
+// SoftEther VPN Source Code - Developer Edition Master Branch
+// Cedar Communication Module
+
+
+// Console.c
+// Console Service
+
+#include "Console.h"
+
+#include "Cedar.h"
+
+#include "Mayaqua/Cfg.h"
+#include "Mayaqua/FileIO.h"
+#include "Mayaqua/Internat.h"
+#include "Mayaqua/Mayaqua.h"
+#include "Mayaqua/Memory.h"
+#include "Mayaqua/Microsoft.h"
+#include "Mayaqua/Object.h"
+#include "Mayaqua/Str.h"
+#include "Mayaqua/Table.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef OS_WIN32
+#include <conio.h>
+#else
+#include <termios.h>
+#include <sys/ioctl.h>
+
+#ifndef __ANDROID__
+#include <readline/readline.h>
+#include <readline/history.h>
+#endif
+#endif
+#ifdef __ANDROID__
+#include <androidhelpers.h>
+#endif
+
+// Display the help for the command
+void PrintCmdHelp(CONSOLE *c, char *cmd_name, TOKEN_LIST *param_list)
+{
+	wchar_t tmp[MAX_SIZE];
+	wchar_t *buf;
+	UINT buf_size;
+	wchar_t *description, *args, *help;
+	UNI_TOKEN_LIST *t;
+	UINT width;
+	UINT i;
+	char *space;
+	// Validate arguments
+	if (c == NULL || cmd_name == NULL || param_list == NULL)
+	{
+		return;
+	}
+
+	width = GetConsoleWidth(c) - 2;
+
+	buf_size = sizeof(wchar_t) * (width + 32);
+	buf = Malloc(buf_size);
+
+	GetCommandHelpStr(cmd_name, &description, &args, &help);
+
+	space = MakeCharArray(' ', 2);
+
+	// Title
+	UniFormat(tmp, sizeof(tmp), _UU("CMD_HELP_TITLE"), cmd_name);
+	c->Write(c, tmp);
+	c->Write(c, L"");
+
+	// Purpose
+	c->Write(c, _UU("CMD_HELP_DESCRIPTION"));
+	t = SeparateStringByWidth(description, width - 2);
+	for (i = 0;i < t->NumTokens;i++)
+	{
+		UniFormat(buf, buf_size, L"%S%s", space, t->Token[i]);
+		c->Write(c, buf);
+	}
+	UniFreeToken(t);
+	c->Write(c, L"");
+
+	// Description
+	c->Write(c, _UU("CMD_HELP_HELP"));
+	t = SeparateStringByWidth(help, width - 2);
+	for (i = 0;i < t->NumTokens;i++)
+	{
+		UniFormat(buf, buf_size, L"%S%s", space, t->Token[i]);
+		c->Write(c, buf);
+	}
+	UniFreeToken(t);
+	c->Write(c, L"");
+
+	// Usage
+	c->Write(c, _UU("CMD_HELP_USAGE"));
+	t = SeparateStringByWidth(args, width - 2);
+	for (i = 0;i < t->NumTokens;i++)
+	{
+		UniFormat(buf, buf_size, L"%S%s", space, t->Token[i]);
+		c->Write(c, buf);
+	}
+	UniFreeToken(t);
+
+	// Arguments
+	if (param_list->NumTokens >= 1)
+	{
+		c->Write(c, L"");
+		c->Write(c, _UU("CMD_HELP_ARGS"));
+		PrintCandidateHelp(c, cmd_name, param_list, 2);
+	}
+
+	Free(space);
+
+	Free(buf);
+}
+
+// Evaluate whether it is SafeStr
+bool CmdEvalSafe(CONSOLE *c, wchar_t *str, void *param)
+{
+	wchar_t *p = (param == NULL) ? _UU("CMD_EVAL_SAFE") : (wchar_t *)param;
+
+	if (IsSafeUniStr(str))
+	{
+		return true;
+	}
+
+	c->Write(c, p);
+
+	return false;
+}
+
+// String input prompt
+wchar_t *CmdPrompt(CONSOLE *c, void *param)
+{
+	wchar_t *p = (param == NULL) ? _UU("CMD_PROMPT") : (wchar_t *)param;
+
+	return c->ReadLine(c, p, true);
+}
+
+// Evaluation whether the specified file exists
+bool CmdEvalIsFile(CONSOLE *c, wchar_t *str, void *param)
+{
+	wchar_t tmp[MAX_PATH];
+	// Validate arguments
+	if (c == NULL || str == NULL)
+	{
+		return false;
+	}
+
+	UniStrCpy(tmp, sizeof(tmp), str);
+
+	if (IsEmptyUniStr(tmp))
+	{
+		c->Write(c, _UU("CMD_FILE_NAME_EMPTY"));
+		return false;
+	}
+
+	if (IsFileExistsW(tmp) == false)
+	{
+		wchar_t tmp2[MAX_SIZE];
+
+		UniFormat(tmp2, sizeof(tmp2), _UU("CMD_FILE_NOT_FOUND"), tmp);
+		c->Write(c, tmp2);
+
+		return false;
+	}
+
+	return true;
+}
+
+// Evaluation of integer
+bool CmdEvalInt1(CONSOLE *c, wchar_t *str, void *param)
+{
+	wchar_t *p = (param == NULL) ? _UU("CMD_EVAL_INT") : (wchar_t *)param;
+
+	if (UniToInt(str) == 0)
+	{
+		c->Write(c, p);
+
+		return false;
+	}
+
+	return true;
+}
+
+// Evaluation of the parameters that a blank cannot be specified to
+bool CmdEvalNotEmpty(CONSOLE *c, wchar_t *str, void *param)
+{
+	wchar_t *p = (param == NULL) ? _UU("CMD_EVAL_NOT_EMPTY") : (wchar_t *)param;
+
+	if (UniIsEmptyStr(str) == false)
+	{
+		return true;
+	}
+
+	c->Write(c, p);
+
+	return false;
+}
+
+// Evaluation function for minimum / maximum value of the parameter
+bool CmdEvalMinMax(CONSOLE *c, wchar_t *str, void *param)
+{
+	CMD_EVAL_MIN_MAX *e;
+	wchar_t *tag;
+	UINT v;
+	// Validate arguments
+	if (param == NULL)
+	{
+		return false;
+	}
+
+	e = (CMD_EVAL_MIN_MAX *)param;
+
+	if (e->StrName == NULL)
+	{
+		tag = _UU("CMD_EVAL_MIN_MAX");
+	}
+	else
+	{
+		tag = _UU(e->StrName);
+	}
+
+	v = UniToInt(str);
+
+	if (v >= e->MinValue && v <= e->MaxValue)
+	{
+		return true;
+	}
+	else
+	{
+		wchar_t tmp[MAX_SIZE];
+
+		UniFormat(tmp, sizeof(tmp), tag, e->MinValue, e->MaxValue);
+		c->Write(c, tmp);
+
+		return false;
+	}
+}
+
+// Get the help string of command
+void GetCommandHelpStr(char *command_name, wchar_t **description, wchar_t **args, wchar_t **help)
+{
+	char tmp1[128], tmp2[128], tmp3[128];
+
+	Format(tmp1, sizeof(tmp1), "CMD_%s", command_name);
+	Format(tmp2, sizeof(tmp2), "CMD_%s_ARGS", command_name);
+	Format(tmp3, sizeof(tmp3), "CMD_%s_HELP", command_name);
+
+	if (description != NULL)
+	{
+		*description = _UU(tmp1);
+		if (UniIsEmptyStr(*description))
+		{
+			*description = _UU("CMD_UNKNOWM");
+		}
+	}
+
+	if (args != NULL)
+	{
+		*args = _UU(tmp2);
+		if (UniIsEmptyStr(*args))
+		{
+			*args = _UU("CMD_UNKNOWN_ARGS");
+		}
+	}
+
+	if (help != NULL)
+	{
+		*help = _UU(tmp3);
+		if (UniIsEmptyStr(*help))
+		{
+			*help = _UU("CMD_UNKNOWN_HELP");
+		}
+	}
+}
+
+// Get the help string for parameter
+void GetCommandParamHelpStr(char *command_name, char *param_name, wchar_t **description)
+{
+	char tmp[160];
+	if (description == NULL)
+	{
+		return;
+	}
+
+	Format(tmp, sizeof(tmp), "CMD_%s_%s", command_name, param_name);
+
+	*description = _UU(tmp);
+
+	if (UniIsEmptyStr(*description))
+	{
+		*description = _UU("CMD_UNKNOWN_PARAM");
+	}
+}
+
+// String comparison function
+int CompareCandidateStr(void *p1, void *p2)
+{
+	char *s1, *s2;
+	if (p1 == NULL || p2 == NULL)
+	{
+		return 0;
+	}
+	s1 = *(char **)p1;
+	s2 = *(char **)p2;
+	if (s1 == NULL || s2 == NULL)
+	{
+		return 0;
+	}
+
+	if (s1[0] == '[' && s2[0] != '[')
+	{
+		return -1;
+	}
+	else if (s2[0] == '[' && s1[0] != '[')
+	{
+		return 1;
+	}
+
+	return StrCmp(s1, s2);
+}
+
+// Display the help of the candidate list
+void PrintCandidateHelp(CONSOLE *c, char *cmd_name, TOKEN_LIST *candidate_list, UINT left_space)
+{
+	UINT console_width;
+	UINT max_keyword_width;
+	LIST *o;
+	UINT i;
+	wchar_t *tmpbuf;
+	UINT tmpbuf_size;
+	char *left_space_array;
+	char *max_space_array;
+	// Validate arguments
+	if (c == NULL || candidate_list == NULL)
+	{
+		return;
+	}
+
+	// Get the width of the screen
+	console_width = GetConsoleWidth(c) - 1;
+
+	tmpbuf_size = sizeof(wchar_t) * (console_width + 32);
+	tmpbuf = Malloc(tmpbuf_size);
+
+	left_space_array = MakeCharArray(' ', left_space);
+
+	// Sort and enlist the command name
+	// no need to sort the parameter name
+	o = NewListFast(cmd_name == NULL ? CompareCandidateStr : NULL);
+
+	max_keyword_width = 0;
+
+	for (i = 0;i < candidate_list->NumTokens;i++)
+	{
+		UINT keyword_width;
+
+		// Get the width of each keyword
+		Insert(o, candidate_list->Token[i]);
+
+		keyword_width = StrWidth(candidate_list->Token[i]);
+		if (cmd_name != NULL)
+		{
+			if (candidate_list->Token[i][0] != '[')
+			{
+				keyword_width += 1;
+			}
+			else
+			{
+				keyword_width -= 2;
+			}
+		}
+
+		max_keyword_width = MAX(max_keyword_width, keyword_width);
+	}
+
+	max_space_array = MakeCharArray(' ', max_keyword_width);
+
+	// Display the candidate
+	for (i = 0;i < LIST_NUM(o);i++)
+	{
+		char tmp[128];
+		char *name = LIST_DATA(o, i);
+		UNI_TOKEN_LIST *t;
+		wchar_t *help;
+		UINT j;
+		UINT keyword_start_width = left_space;
+		UINT descript_start_width = left_space + max_keyword_width + 1;
+		UINT descript_width;
+		char *space;
+
+		if (console_width >= (descript_start_width + 5))
+		{
+			descript_width = console_width - descript_start_width - 3;
+		}
+		else
+		{
+			descript_width = 2;
+		}
+
+		// Generate the name
+		if (cmd_name != NULL && name[0] != '[')
+		{
+			// Prepend a "/" in the case of a parameter
+			Format(tmp, sizeof(tmp), "/%s", name);
+		}
+		else
+		{
+			// Use the characters as it is in the case of a command name
+			if (cmd_name == NULL)
+			{
+				StrCpy(tmp, sizeof(tmp), name);
+			}
+			else
+			{
+				StrCpy(tmp, sizeof(tmp), name + 1);
+				if (StrLen(tmp) >= 1)
+				{
+					tmp[StrLen(tmp) - 1] = 0;
+				}
+			}
+		}
+
+		// Get the help string
+		if (cmd_name == NULL)
+		{
+			GetCommandHelpStr(name, &help, NULL, NULL);
+		}
+		else
+		{
+			GetCommandParamHelpStr(cmd_name, name, &help);
+		}
+
+		space = MakeCharArray(' ', max_keyword_width - StrWidth(name) - (cmd_name == NULL ? 0 : (name[0] != '[' ? 1 : -2)));
+
+		t = SeparateStringByWidth(help, descript_width);
+
+		for (j = 0;j < t->NumTokens;j++)
+		{
+			if (j == 0)
+			{
+				UniFormat(tmpbuf, tmpbuf_size, L"%S%S%S - %s",
+					left_space_array, tmp, space, t->Token[j]);
+			}
+			else
+			{
+				UniFormat(tmpbuf, tmpbuf_size, L"%S%S   %s",
+					left_space_array, max_space_array, t->Token[j]);
+			}
+
+			c->Write(c, tmpbuf);
+		}
+
+		Free(space);
+
+		UniFreeToken(t);
+	}
+
+	ReleaseList(o);
+
+	Free(max_space_array);
+	Free(tmpbuf);
+	Free(left_space_array);
+}
+
+// Acquisition whether word characters
+bool IsWordChar(wchar_t c)
+{
+	if (c >= L'a' && c <= 'z')
+	{
+		return true;
+	}
+	if (c >= L'A' && c <= 'Z')
+	{
+		return true;
+	}
+	if (c >= L'0' && c <= '9')
+	{
+		return true;
+	}
+	if (c == L'_')
+	{
+		return true;
+	}
+	if (c == L'.')
+	{
+		return true;
+	}
+	if (c == L'\"')
+	{
+		return true;
+	}
+	if (c == L'\'')
+	{
+		return true;
+	}
+	if (c == L',')
+	{
+		return true;
+	}
+	if (c == L')')
+	{
+		return true;
+	}
+	if (c == L']')
+	{
+		return true;
+	}
+
+	return false;
+}
+
+// Get the character width of the word that comes next
+UINT GetNextWordWidth(wchar_t *str)
+{
+	UINT i;
+	UINT ret;
+	// Validate arguments
+	if (str == NULL)
+	{
+		return 0;
+	}
+
+	ret = 0;
+
+	for (i = 0;;i++)
+	{
+		wchar_t c = str[i];
+
+		if (c == 0)
+		{
+			break;
+		}
+
+		if (IsWordChar(c) == false)
+		{
+			break;
+		}
+
+		ret++;
+	}
+
+	return ret;
+}
+
+// Split a string into specified width
+UNI_TOKEN_LIST *SeparateStringByWidth(wchar_t *str, UINT width)
+{
+	UINT wp;
+	wchar_t *tmp;
+	UINT len, i;
+	LIST *o;
+	UNI_TOKEN_LIST *ret;
+	// Validate arguments
+	if (str == NULL)
+	{
+		return UniNullToken();
+	}
+	if (width == 0)
+	{
+		width = 1;
+	}
+
+	o = NewListFast(NULL);
+
+	len = UniStrLen(str);
+	tmp = ZeroMalloc(sizeof(wchar_t) * (len + 32));
+	wp = 0;
+
+	for (i = 0;i < (len + 1);i++)
+	{
+		wchar_t c = str[i];
+		UINT next_word_width;
+		UINT remain_width;
+
+		switch (c)
+		{
+		case 0:
+		case L'\r':
+		case L'\n':
+			if (c == L'\r')
+			{
+				if (str[i + 1] == L'\n')
+				{
+					i++;
+				}
+			}
+
+			tmp[wp++] = 0;
+			wp = 0;
+
+			Insert(o, UniCopyStr(tmp));
+			break;
+
+		default:
+			next_word_width = GetNextWordWidth(&str[i]);
+			remain_width = (width - UniStrWidth(tmp));
+
+			if ((remain_width >= 1) && (next_word_width > remain_width) && (next_word_width <= width))
+			{
+				tmp[wp++] = 0;
+				wp = 0;
+
+				Insert(o, UniCopyStr(tmp));
+			}
+
+			tmp[wp++] = c;
+			tmp[wp] = 0;
+			if (UniStrWidth(tmp) >= width)
+			{
+				tmp[wp++] = 0;
+				wp = 0;
+
+				Insert(o, UniCopyStr(tmp));
+			}
+			break;
+		}
+	}
+
+	if (LIST_NUM(o) == 0)
+	{
+		Insert(o, CopyUniStr(L""));
+	}
+
+	ret = ZeroMalloc(sizeof(UNI_TOKEN_LIST));
+	ret->NumTokens = LIST_NUM(o);
+	ret->Token = ZeroMalloc(sizeof(wchar_t *) * ret->NumTokens);
+
+	for (i = 0;i < LIST_NUM(o);i++)
+	{
+		wchar_t *s = LIST_DATA(o, i);
+
+		UniTrimLeft(s);
+
+		ret->Token[i] = s;
+	}
+
+	ReleaseList(o);
+	Free(tmp);
+
+	return ret;
+}
+
+// Check whether the specified string means 'help'
+bool IsHelpStr(char *str)
+{
+	// Validate arguments
+	if (str == NULL)
+	{
+		return false;
+	}
+
+	if (StrCmpi(str, "help") == 0 || StrCmpi(str, "?") == 0 ||
+		StrCmpi(str, "man") == 0 || StrCmpi(str, "/man") == 0 ||
+		StrCmpi(str, "-man") == 0 || StrCmpi(str, "--man") == 0 ||
+		StrCmpi(str, "/help") == 0 || StrCmpi(str, "/?") == 0 ||
+		StrCmpi(str, "-help") == 0 || StrCmpi(str, "-?") == 0 ||
+		StrCmpi(str, "/h") == 0 || StrCmpi(str, "--help") == 0 ||
+		StrCmpi(str, "--?") == 0)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+// Execution of the command
+bool DispatchNextCmd(CONSOLE *c, char *prompt, CMD cmd[], UINT num_cmd, void *param)
+{
+	return DispatchNextCmdEx(c, NULL, prompt, cmd, num_cmd, param);
+}
+bool DispatchNextCmdEx(CONSOLE *c, wchar_t *exec_command, char *prompt, CMD cmd[], UINT num_cmd, void *param)
+{
+	wchar_t *str;
+	wchar_t *tmp;
+	char *cmd_name;
+	bool b_exit = false;
+	wchar_t *cmd_param;
+	UINT ret = ERR_NO_ERROR;
+	TOKEN_LIST *t;
+	TOKEN_LIST *candidate;
+	bool no_end_crlf = false;
+	UINT i;
+	// Validate arguments
+	if (c == NULL || (num_cmd >= 1 && cmd == NULL))
+	{
+		return false;
+	}
+
+	if (exec_command == NULL)
+	{
+		// Show the prompt
+RETRY:
+		tmp = CopyStrToUni(prompt);
+
+		if (c->ProgrammingMode)
+		{
+			wchar_t tmp2[MAX_PATH];
+
+			UniFormat(tmp2, sizeof(tmp2), L"[PROMPT:%u:%s]\r\n", c->RetCode, tmp);
+
+			Free(tmp);
+
+			tmp = CopyUniStr(tmp2);
+		}
+
+		str = c->ReadLine(c, tmp, false);
+		Free(tmp);
+
+		if (str != NULL && IsEmptyUniStr(str))
+		{
+			Free(str);
+			goto RETRY;
+		}
+	}
+	else
+	{
+		wchar_t tmp[MAX_SIZE];
+		// Use exec_command
+		if (UniStartWith(exec_command, L"vpncmd") == false)
+		{
+			if (prompt != NULL)
+			{
+				if (c->ConsoleType != CONSOLE_CSV)
+				{
+					UniFormat(tmp, sizeof(tmp), L"%S%s", prompt, exec_command);
+					c->Write(c, tmp);
+				}
+			}
+		}
+		str = CopyUniStr(exec_command);
+	}
+
+	if (str == NULL)
+	{
+		// User canceled
+		return false;
+	}
+
+	UniTrimCrlf(str);
+	UniTrim(str);
+
+	if (UniIsEmptyStr(str))
+	{
+		// Do Nothing
+		Free(str);
+		return true;
+	}
+
+	// Divide into command name and parameter
+	if (SeparateCommandAndParam(str, &cmd_name, &cmd_param) == false)
+	{
+		// Do Nothing
+		Free(str);
+		return true;
+	}
+
+	if (StrLen(cmd_name) >= 2 && cmd_name[0] == '?' && cmd_name[1] != '?')
+	{
+		char tmp[MAX_SIZE];
+		wchar_t *s;
+
+		StrCpy(tmp, sizeof(tmp), cmd_name + 1);
+		StrCpy(cmd_name, 0, tmp);
+
+		s = UniCopyStr(L"/?");
+		Free(cmd_param);
+
+		cmd_param = s;
+	}
+
+	if (StrLen(cmd_name) >= 2 && EndWith(cmd_name, "?") && cmd_name[StrLen(cmd_name) - 2] != '?')
+	{
+		wchar_t *s;
+
+		cmd_name[StrLen(cmd_name) - 1] = 0;
+
+		s = UniCopyStr(L"/?");
+		Free(cmd_param);
+
+		cmd_param = s;
+	}
+
+	// Get the candidate of command
+	t = ZeroMalloc(sizeof(TOKEN_LIST));
+	t->NumTokens = num_cmd;
+	t->Token = ZeroMalloc(sizeof(char *) * t->NumTokens);
+	for (i = 0;i < t->NumTokens;i++)
+	{
+		t->Token[i] = CopyStr(cmd[i].Name);
+	}
+
+	if (IsHelpStr(cmd_name))
+	{
+		if (UniIsEmptyStr(cmd_param))
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			// Display the list of commands that can be used
+			UniFormat(tmp, sizeof(tmp), _UU("CMD_HELP_1"), t->NumTokens);
+			c->Write(c, tmp);
+
+			PrintCandidateHelp(c, NULL, t, 1);
+
+			c->Write(c, L"");
+			c->Write(c, _UU("CMD_HELP_2"));
+		}
+		else
+		{
+			char *cmd_name;
+
+			// Display the help for the specified command
+			if (SeparateCommandAndParam(cmd_param, &cmd_name, NULL))
+			{
+				bool b = true;
+
+				if (IsHelpStr(cmd_name))
+				{
+					b = false;
+				}
+
+				if (b)
+				{
+					wchar_t str[MAX_SIZE];
+
+					UniFormat(str, sizeof(str), L"%S /help", cmd_name);
+					DispatchNextCmdEx(c, str, NULL, cmd, num_cmd, param);
+					no_end_crlf = true;
+				}
+
+				Free(cmd_name);
+			}
+		}
+	}
+	else if (StrCmpi(cmd_name, "exit") == 0 || StrCmpi(cmd_name, "quit") == 0)
+	{
+		// Exit
+		b_exit = true;
+	}
+	else
+	{
+		candidate = GetRealnameCandidate(cmd_name, t);
+
+		if (candidate == NULL || candidate->NumTokens == 0)
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			// No candidate
+			UniFormat(tmp, sizeof(tmp), _UU("CON_UNKNOWN_CMD"), cmd_name);
+			c->Write(c, tmp);
+
+			c->RetCode = ERR_BAD_COMMAND_OR_PARAM;
+		}
+		else if (candidate->NumTokens >= 2)
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			// There is more than one candidate
+			UniFormat(tmp, sizeof(tmp), _UU("CON_AMBIGUOUS_CMD"), cmd_name);
+			c->Write(c, tmp);
+			c->Write(c, _UU("CON_AMBIGUOUS_CMD_1"));
+			PrintCandidateHelp(c, NULL, candidate, 1);
+			c->Write(c, _UU("CON_AMBIGUOUS_CMD_2"));
+
+			c->RetCode = ERR_BAD_COMMAND_OR_PARAM;
+		}
+		else
+		{
+			char *real_cmd_name;
+			UINT i;
+
+			// The candidate was shortlisted to one
+			real_cmd_name = candidate->Token[0];
+
+			for (i = 0;i < num_cmd;i++)
+			{
+				if (StrCmpi(cmd[i].Name, real_cmd_name) == 0)
+				{
+					if (cmd[i].Proc != NULL)
+					{
+						// Show the description of the command if it isn't in CSV mode
+						if(c->ConsoleType != CONSOLE_CSV)
+						{
+							wchar_t tmp[256];
+							wchar_t *note;
+
+							GetCommandHelpStr(cmd[i].Name, &note, NULL, NULL);
+							UniFormat(tmp, sizeof(tmp), _UU("CMD_EXEC_MSG_NAME"), cmd[i].Name, note);
+							c->Write(c, tmp);
+						}
+
+						// Call the procedure of the command
+						ret = cmd[i].Proc(c, cmd[i].Name, cmd_param, param);
+
+						if (ret == INFINITE)
+						{
+							// Exit command
+							b_exit = true;
+						}
+						else
+						{
+							c->RetCode = ret;
+						}
+					}
+				}
+			}
+		}
+
+		FreeToken(candidate);
+	}
+
+	FreeToken(t);
+	Free(str);
+	Free(cmd_name);
+	Free(cmd_param);
+
+	if (no_end_crlf == false)
+	{
+		//c->Write(c, L"");
+	}
+
+	if (b_exit)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Get the width of the current console
+UINT GetConsoleWidth(CONSOLE *c)
+{
+	UINT size;
+
+	size = c->GetWidth(c);
+
+	if (size == 0)
+	{
+		size = 80;
+	}
+
+	if (size < 32)
+	{
+		size = 32;
+	}
+
+	if (size > 65536)
+	{
+		size = 65535;
+	}
+
+	return size;
+}
+
+// Separate the command line into the command and the parameters
+bool SeparateCommandAndParam(wchar_t *src, char **cmd, wchar_t **param)
+{
+	UINT i, len, wp;
+	wchar_t *tmp;
+	wchar_t *src_tmp;
+	// Validate arguments
+	if (src == NULL)
+	{
+		return false;
+	}
+	if (cmd != NULL)
+	{
+		*cmd = NULL;
+	}
+	if (param != NULL)
+	{
+		*param = NULL;
+	}
+
+	src_tmp = UniCopyStr(src);
+	UniTrimCrlf(src_tmp);
+	UniTrim(src_tmp);
+
+	len = UniStrLen(src_tmp);
+	tmp = Malloc(sizeof(wchar_t) * (len + 32));
+	wp = 0;
+
+	for (i = 0;i < (len + 1);i++)
+	{
+		wchar_t c = src_tmp[i];
+
+		switch (c)
+		{
+		case 0:
+		case L' ':
+		case L'\t':
+			tmp[wp] = 0;
+			if (UniIsEmptyStr(tmp))
+			{
+				Free(tmp);
+				Free(src_tmp);
+				return false;
+			}
+			if (cmd != NULL)
+			{
+				*cmd = CopyUniToStr(tmp);
+				Trim(*cmd);
+			}
+			goto ESCAPE;
+
+		default:
+			tmp[wp++] = c;
+			break;
+		}
+	}
+
+ESCAPE:
+	if (param != NULL)
+	{
+		*param = CopyUniStr(&src_tmp[wp]);
+		UniTrim(*param);
+	}
+
+	Free(tmp);
+	Free(src_tmp);
+
+	return true;
+}
+
+// Get the candidates list of of the real command name whose abbreviation matches to the command specified by the user
+TOKEN_LIST *GetRealnameCandidate(char *input_name, TOKEN_LIST *real_name_list)
+{
+	TOKEN_LIST *ret;
+	LIST *o;
+	UINT i;
+	bool ok = false;
+	// Validate arguments
+	if (input_name == NULL || real_name_list == NULL)
+	{
+		return NullToken();
+	}
+
+	o = NewListFast(NULL);
+
+	for (i = 0;i < real_name_list->NumTokens;i++)
+	{
+		char *name = real_name_list->Token[i];
+
+		// Search for an exact match with the highest priority first
+		if (StrCmpi(name, input_name) == 0)
+		{
+			Insert(o, name);
+			ok = true;
+			break;
+		}
+	}
+
+	if (ok == false)
+	{
+		// If there is no command to exact match, check whether it matches to a short form command
+		for (i = 0;i < real_name_list->NumTokens;i++)
+		{
+			char *name = real_name_list->Token[i];
+
+			if (IsOmissionName(input_name, name) || IsNameInRealName(input_name, name))
+			{
+				// A abbreviation is found
+				Insert(o, name);
+				ok = true;
+			}
+		}
+	}
+
+	if (ok)
+	{
+		// One or more candidate is found
+		ret = ListToTokenList(o);
+	}
+	else
+	{
+		ret = NullToken();
+	}
+
+	ReleaseList(o);
+
+	return ret;
+}
+
+// Check whether the command specified by the user is a abbreviation of existing commands
+bool IsOmissionName(char *input_name, char *real_name)
+{
+	char oname[128];
+	// Validate arguments
+	if (input_name == NULL || real_name == NULL)
+	{
+		return false;
+	}
+
+	if (IsAllUpperStr(real_name))
+	{
+		// Command of all capital letters do not take abbreviations
+		return false;
+	}
+
+	GetOmissionName(oname, sizeof(oname), real_name);
+
+	if (IsEmptyStr(oname))
+	{
+		return false;
+	}
+
+	if (StartWith(oname, input_name))
+	{
+		// Example: The oname of AccountSecureCertSet is "ascs".
+		// But if the user enters "asc", returns true
+		return true;
+	}
+
+	if (StartWith(input_name, oname))
+	{
+		// Example: When two commands AccountCreate and AccountConnect exist,
+		// if the user enter "aconnect" , only AccountConnect is true
+
+		if (EndWith(real_name, &input_name[StrLen(oname)]))
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+// Get the short name of the specified command
+void GetOmissionName(char *dst, UINT size, char *src)
+{
+	UINT i, len;
+	// Validate arguments
+	if (dst == NULL || src == NULL)
+	{
+		return;
+	}
+
+	StrCpy(dst, size, "");
+	len = StrLen(src);
+
+	for (i = 0;i < len;i++)
+	{
+		char c = src[i];
+
+		if ((c >= '0' && c <= '9') ||
+			(c >= 'A' && c <= 'Z'))
+		{
+			char tmp[2];
+			tmp[0] = c;
+			tmp[1] = 0;
+
+			StrCat(dst, size, tmp);
+		}
+	}
+}
+
+// Check whether the command specified by the user matches the existing commands
+bool IsNameInRealName(char *input_name, char *real_name)
+{
+	// Validate arguments
+	if (input_name == NULL || real_name == NULL)
+	{
+		return false;
+	}
+
+	if (StartWith(real_name, input_name))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+// Parse the command list
+LIST *ParseCommandList(CONSOLE *c, char *cmd_name, wchar_t *command, PARAM param[], UINT num_param)
+{
+	UINT i;
+	LIST *o;
+	bool ok = true;
+	TOKEN_LIST *param_list;
+	TOKEN_LIST *real_name_list;
+	bool help_mode = false;
+	wchar_t *tmp;
+	// Validate arguments
+	if (c == NULL || command == NULL || (num_param >= 1 && param == NULL) || cmd_name == NULL)
+	{
+		return NULL;
+	}
+
+	// Initialization
+	for (i = 0;i < num_param;i++)
+	{
+		if (IsEmptyStr(param[i].Name) == false)
+		{
+			if (param[i].Name[0] == '[')
+			{
+				param[i].Tmp = "";
+			}
+			else
+			{
+				param[i].Tmp = NULL;
+			}
+		}
+		else
+		{
+			param[i].Tmp = "";
+		}
+	}
+
+	real_name_list = ZeroMalloc(sizeof(TOKEN_LIST));
+	real_name_list->NumTokens = num_param;
+	real_name_list->Token = ZeroMalloc(sizeof(char *) * real_name_list->NumTokens);
+
+	for (i = 0;i < real_name_list->NumTokens;i++)
+	{
+		real_name_list->Token[i] = CopyStr(param[i].Name);
+	}
+
+	// Generate a list of parameter name specified by the user
+	param_list = GetCommandNameList(command);
+
+	for (i = 0;i < param_list->NumTokens;i++)
+	{
+		char *s = param_list->Token[i];
+
+		if (StrCmpi(s, "help") == 0 || StrCmpi(s, "?") == 0)
+		{
+			help_mode = true;
+			break;
+		}
+	}
+
+	tmp = ParseCommand(command, L"");
+	if (tmp != NULL)
+	{
+		if (UniStrCmpi(tmp, L"?") == 0)
+		{
+			help_mode = true;
+		}
+		Free(tmp);
+	}
+
+	if (help_mode)
+	{
+		// Show the help
+		PrintCmdHelp(c, cmd_name, real_name_list);
+		FreeToken(param_list);
+		FreeToken(real_name_list);
+		return NULL;
+	}
+
+	for (i = 0;i < param_list->NumTokens;i++)
+	{
+		// Get the corresponding commands for all parameter names which is specified by the user
+		TOKEN_LIST *candidate = GetRealnameCandidate(param_list->Token[i], real_name_list);
+
+		if (candidate != NULL && candidate->NumTokens >= 1)
+		{
+			if (candidate->NumTokens >= 2)
+			{
+				wchar_t tmp[MAX_SIZE];
+
+				// There is more than one candidate
+				UniFormat(tmp, sizeof(tmp), _UU("CON_AMBIGUOUS_PARAM"), param_list->Token[i]);
+				c->Write(c, tmp);
+				UniFormat(tmp, sizeof(tmp), _UU("CON_AMBIGUOUS_PARAM_1"), cmd_name);
+				c->Write(c, tmp);
+
+				PrintCandidateHelp(c, cmd_name, candidate, 1);
+
+				c->Write(c, _UU("CON_AMBIGUOUS_PARAM_2"));
+
+				ok = false;
+			}
+			else
+			{
+				UINT j;
+				char *real_name = candidate->Token[0];
+
+				// There is only one candidate
+				for (j = 0;j < num_param;j++)
+				{
+					if (StrCmpi(param[j].Name, real_name) == 0)
+					{
+						param[j].Tmp = param_list->Token[i];
+					}
+				}
+			}
+		}
+		else
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			// No candidate
+			UniFormat(tmp, sizeof(tmp), _UU("CON_INVALID_PARAM"), param_list->Token[i], cmd_name, cmd_name);
+			c->Write(c, tmp);
+
+			ok = false;
+		}
+
+		FreeToken(candidate);
+	}
+
+	if (ok == false)
+	{
+		FreeToken(param_list);
+		FreeToken(real_name_list);
+
+		return NULL;
+	}
+
+	// Creating a list
+	o = NewParamValueList();
+
+	// Read all the parameters of the specified name in the parameter list
+	for (i = 0;i < num_param;i++)
+	{
+		bool prompt_input_value = false;
+		PARAM *p = &param[i];
+
+		if (p->Tmp != NULL || p->PromptProc != NULL)
+		{
+			wchar_t *name = CopyStrToUni(p->Name);
+			wchar_t *tmp;
+			wchar_t *str;
+
+			if (p->Tmp != NULL)
+			{
+				tmp = CopyStrToUni(p->Tmp);
+			}
+			else
+			{
+				tmp = CopyStrToUni(p->Name);
+			}
+
+			str = ParseCommand(command, tmp);
+			Free(tmp);
+			if (str != NULL)
+			{
+				wchar_t *unistr;
+				bool ret;
+EVAL_VALUE:
+				// Reading succeeded
+				unistr = str;
+
+				if (p->EvalProc != NULL)
+				{
+					// Evaluate the value if EvalProc is specified
+					ret = p->EvalProc(c, unistr, p->EvalProcParam);
+				}
+				else
+				{
+					// Accept any value if EvalProc is not specified
+					ret = true;
+				}
+
+				if (ret == false)
+				{
+					// The specified value is invalid
+					if (p->PromptProc == NULL)
+					{
+						// Cancel
+						ok = false;
+						Free(name);
+						Free(str);
+						break;
+					}
+					else if (c->ProgrammingMode)
+					{
+						// In the programming mode, return the error immediately.
+						ok = false;
+						Free(name);
+						Free(str);
+						break;
+					}
+					else
+					{
+						// Request to re-enter
+						Free(str);
+						str = NULL;
+						goto SHOW_PROMPT;
+					}
+				}
+				else
+				{
+					PARAM_VALUE *v;
+					// Finished loading, add it to the list
+					v = ZeroMalloc(sizeof(PARAM_VALUE));
+					v->Name = CopyStr(p->Name);
+					v->StrValue = CopyUniToStr(str);
+					v->UniStrValue = CopyUniStr(str);
+					v->IntValue = ToInt(v->StrValue);
+					Insert(o, v);
+				}
+			}
+			else
+			{
+				// Failed to read. The parameter is not specified
+				if (p->PromptProc != NULL)
+				{
+					wchar_t *tmp;
+SHOW_PROMPT:
+					// Prompt because it is a mandatory parameter
+					tmp = NULL;
+					if (c->ProgrammingMode == false)
+					{
+						tmp = p->PromptProc(c, p->PromptProcParam);
+					}
+					if (tmp == NULL)
+					{
+						// User canceled
+						ok = false;
+						Free(str);
+						Free(name);
+						break;
+					}
+					else
+					{
+						// Entered by the user
+						c->Write(c, L"");
+						str = tmp;
+						prompt_input_value = true;
+						goto EVAL_VALUE;
+					}
+				}
+			}
+
+			Free(str);
+			Free(name);
+		}
+	}
+
+	FreeToken(param_list);
+	FreeToken(real_name_list);
+
+	if (ok)
+	{
+		return o;
+	}
+	else
+	{
+		FreeParamValueList(o);
+		return NULL;
+	}
+}
+
+// Acquisition of [Yes] or [No]
+bool GetParamYes(LIST *o, char *name)
+{
+	char *s;
+	char tmp[64];
+	// Validate arguments
+	if (o == NULL)
+	{
+		return false;
+	}
+
+	s = GetParamStr(o, name);
+	if (s == NULL)
+	{
+		return false;
+	}
+
+	StrCpy(tmp, sizeof(tmp), s);
+	Trim(tmp);
+
+	if (StartWith(tmp, "y"))
+	{
+		return true;
+	}
+
+	if (StartWith(tmp, "t"))
+	{
+		return true;
+	}
+
+	if (ToInt(tmp) != 0)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+// Acquisition of parameter value Int
+UINT GetParamInt(LIST *o, char *name)
+{
+	PARAM_VALUE *v;
+	// Validate arguments
+	if (o == NULL)
+	{
+		return 0;
+	}
+
+	v = FindParamValue(o, name);
+	if (v == NULL)
+	{
+		return 0;
+	}
+	else
+	{
+		return v->IntValue;
+	}
+}
+
+// Acquisition of parameter value Unicode string
+wchar_t *GetParamUniStr(LIST *o, char *name)
+{
+	PARAM_VALUE *v;
+	// Validate arguments
+	if (o == NULL)
+	{
+		return NULL;
+	}
+
+	v = FindParamValue(o, name);
+	if (v == NULL)
+	{
+		return NULL;
+	}
+	else
+	{
+		return v->UniStrValue;
+	}
+}
+
+// Acquisition of the parameter value string
+char *GetParamStr(LIST *o, char *name)
+{
+	PARAM_VALUE *v;
+	// Validate arguments
+	if (o == NULL)
+	{
+		return NULL;
+	}
+
+	v = FindParamValue(o, name);
+	if (v == NULL)
+	{
+		return NULL;
+	}
+	else
+	{
+		return v->StrValue;
+	}
+}
+
+// Acquisition of parameter value
+PARAM_VALUE *FindParamValue(LIST *o, char *name)
+{
+	PARAM_VALUE t, *ret;
+	// Validate arguments
+	if (o == NULL)
+	{
+		return NULL;
+	}
+	if (name == NULL)
+	{
+		name = "";
+	}
+
+	Zero(&t, sizeof(t));
+	t.Name = name;
+
+	ret = Search(o, &t);
+
+	return ret;
+}
+
+// Release of the parameter value list
+void FreeParamValueList(LIST *o)
+{
+	UINT i;
+	// Validate arguments
+	if (o == NULL)
+	{
+		return;
+	}
+
+	for (i = 0;i < LIST_NUM(o);i++)
+	{
+		PARAM_VALUE *v = LIST_DATA(o, i);
+
+		Free(v->StrValue);
+		Free(v->UniStrValue);
+		Free(v->Name);
+		Free(v);
+	}
+
+	ReleaseList(o);
+}
+
+// Parameter value list sort function
+int CmpParamValue(void *p1, void *p2)
+{
+	PARAM_VALUE *v1, *v2;
+	if (p1 == NULL || p2 == NULL)
+	{
+		return 0;
+	}
+	v1 = *(PARAM_VALUE **)p1;
+	v2 = *(PARAM_VALUE **)p2;
+	if (v1 == NULL || v2 == NULL)
+	{
+		return 0;
+	}
+
+	if (IsEmptyStr(v1->Name) && IsEmptyStr(v2->Name))
+	{
+		return 0;
+	}
+	return StrCmpi(v1->Name, v2->Name);
+}
+
+// Generation of the parameter value list
+LIST *NewParamValueList()
+{
+	return NewListFast(CmpParamValue);
+}
+
+// Get the list of parameter names that were included in the entered command
+TOKEN_LIST *GetCommandNameList(wchar_t *str)
+{
+	TOKEN_LIST *t;
+	// Validate arguments
+	if (str == NULL)
+	{
+		return NullToken();
+	}
+
+	Free(ParseCommandEx(str, L"dummy_str", &t));
+
+	return t;
+}
+
+// Get the commands that start with the specified name
+wchar_t *ParseCommand(wchar_t *str, wchar_t *name)
+{
+	return ParseCommandEx(str, name, NULL);
+}
+wchar_t *ParseCommandEx(wchar_t *str, wchar_t *name, TOKEN_LIST **param_list)
+{
+	UNI_TOKEN_LIST *t;
+	UINT i;
+	wchar_t *tmp;
+	wchar_t *ret = NULL;
+	LIST *o;
+	// Validate arguments
+	if (str == NULL)
+	{
+		return NULL;
+	}
+	if (name != NULL && UniIsEmptyStr(name))
+	{
+		name = NULL;
+	}
+
+	o = NULL;
+	if (param_list != NULL)
+	{
+		o = NewListFast(CompareStr);
+	}
+
+	tmp = CopyUniStr(str);
+	UniTrim(tmp);
+
+	i = UniSearchStrEx(tmp, L"/CMD ", 0, false);
+
+	if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
+	{
+		i = INFINITE;
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"/CMD\t", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
+		{
+			i = INFINITE;
+		}
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"/CMD:", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
+		{
+			i = INFINITE;
+		}
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"/CMD=", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'/')
+		{
+			i = INFINITE;
+		}
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"-CMD ", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
+		{
+			i = INFINITE;
+		}
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"-CMD\t", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
+		{
+			i = INFINITE;
+		}
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"-CMD:", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
+		{
+			i = INFINITE;
+		}
+	}
+	if (i == INFINITE)
+	{
+		i = UniSearchStrEx(tmp, L"-CMD=", 0, false);
+		if (i != INFINITE && i >= 1 && tmp[i - 1] == L'-')
+		{
+			i = INFINITE;
+		}
+	}
+
+	if (i != INFINITE)
+	{
+		char *s = CopyStr("CMD");
+		if (InsertStr(o, s) == false)
+		{
+			Free(s);
+		}
+		if (UniStrCmpi(name, L"CMD") == 0)
+		{
+			ret = CopyUniStr(&str[i + 5]);
+			UniTrim(ret);
+		}
+		else
+		{
+			tmp[i] = 0;
+		}
+	}
+
+	if (ret == NULL)
+	{
+		t = UniParseCmdLine(tmp);
+
+		if (t != NULL)
+		{
+			for (i = 0;i < t->NumTokens;i++)
+			{
+				wchar_t *token = t->Token[i];
+
+				if ((token[0] == L'-' && token[1] != L'-') ||
+					(UniStrCmpi(token, L"--help") == 0) ||
+					(token[0] == L'/' && token[1] != L'/'))
+				{
+					UINT i;
+
+					// Named parameter
+					// Examine whether there is a colon character
+
+					if (UniStrCmpi(token, L"--help") == 0)
+					{
+						token++;
+					}
+
+					i = UniSearchStrEx(token, L":", 0, false);
+					if (i == INFINITE)
+					{
+						i = UniSearchStrEx(token, L"=", 0, false);
+					}
+					if (i != INFINITE)
+					{
+						wchar_t *tmp;
+						char *a;
+
+						// There is a colon character
+						tmp = CopyUniStr(token);
+						tmp[i] = 0;
+
+						a = CopyUniToStr(&tmp[1]);
+						if (InsertStr(o, a) == false)
+						{
+							Free(a);
+						}
+
+						if (UniStrCmpi(name, &tmp[1]) == 0)
+						{
+							if (ret == NULL)
+							{
+								// Content
+								ret = UniCopyStr(&token[i + 1]);
+							}
+						}
+
+						Free(tmp);
+					}
+					else
+					{
+						// There is no colon character
+						char *a;
+
+						a = CopyUniToStr(&token[1]);
+						if (InsertStr(o, a) == false)
+						{
+							Free(a);
+						}
+
+						if (UniStrCmpi(name, &token[1]) == 0)
+						{
+							if (ret == NULL)
+							{
+								// Empty character
+								ret = UniCopyStr(L"");
+							}
+						}
+					}
+				}
+				else
+				{
+					// Nameless argument
+					if (name == NULL)
+					{
+						if (ret == NULL)
+						{
+							if (token[0] == L'-' && token[1] == L'-')
+							{
+								ret = UniCopyStr(&token[1]);
+							}
+							else if (token[0] == L'/' && token[1] == L'/')
+							{
+								ret = UniCopyStr(&token[1]);
+							}
+							else
+							{
+								ret = UniCopyStr(token);
+							}
+						}
+					}
+				}
+			}
+
+			UniFreeToken(t);
+		}
+	}
+
+	Free(tmp);
+
+	if (o != NULL)
+	{
+		TOKEN_LIST *t = ZeroMalloc(sizeof(TOKEN_LIST));
+		UINT i;
+
+		t->NumTokens = LIST_NUM(o);
+		t->Token = ZeroMalloc(sizeof(char *) * t->NumTokens);
+
+		for (i = 0;i < t->NumTokens;i++)
+		{
+			t->Token[i] = LIST_DATA(o, i);
+		}
+
+		ReleaseList(o);
+
+		*param_list = t;
+	}
+
+	if (UniStrCmpi(ret, L"none") == 0 || UniStrCmpi(ret, L"null") == 0)
+	{
+		// Null and none are reserved words
+		ret[0] = 0;
+	}
+
+	return ret;
+}
+char *ParseCommandA(wchar_t *str, char *name)
+{
+	wchar_t *tmp1, *tmp2;
+	char *ret;
+	// Validate arguments
+	if (str == NULL)
+	{
+		return NULL;
+	}
+
+	if (name != NULL)
+	{
+		tmp1 = CopyStrToUni(name);
+	}
+	else
+	{
+		tmp1 = NULL;
+	}
+
+	tmp2 = ParseCommand(str, tmp1);
+
+	if (tmp2 == NULL)
+	{
+		ret = NULL;
+	}
+	else
+	{
+		ret = CopyUniToStr(tmp2);
+		Free(tmp2);
+	}
+
+	Free(tmp1);
+
+	return ret;
+}
+
+// Password prompt
+bool PasswordPrompt(char *password, UINT size)
+{
+	UINT wp;
+	bool escape = false;
+	void *console;
+	// Validate arguments
+	if (password == NULL || size <= 1)
+	{
+		if (size >= 1)
+		{
+			password[0] = 0;
+		}
+		return false;
+	}
+
+	wp = 0;
+
+	Zero(password, size);
+
+	console = SetConsoleRaw();
+
+	while (true)
+	{
+		int c;
+
+#ifdef	OS_WIN32
+		c = _getch();
+#else	// OS_WIN32
+		c = getc(stdin);
+#endif	// OS_WIN32
+
+		if (c >= 0x20 && c <= 0x7E)
+		{
+			// Character
+			if ((wp + 1) < size)
+			{
+				password[wp++] = (char)c;
+				putc('*', stdout);
+			}
+		}
+		else if (c == 0x03)
+		{
+			// Break
+			exit(0);
+		}
+		else if (c == 0x04 || c == 0x1a || c == 0x0D || c==0x0A)
+		{
+			// Exit
+			if (c == 0x04 || c == 0x1a)
+			{
+				escape = true;
+			}
+			break;
+		}
+		else if (c == 0xE0)
+		{
+			// Read one more character
+#ifdef	OS_WIN32
+			c = _getch();
+#else	// OS_WIN32
+			c = getc(stdin);
+#endif	// OS_WIN32
+			if (c == 0x4B || c == 0x53)
+			{
+				// Backspace
+				goto BACKSPACE;
+			}
+		}
+		else if (c == 0x08)
+		{
+BACKSPACE:
+			// Backspace
+			if (wp >= 1)
+			{
+				password[--wp] = 0;
+				putc(0x08, stdout);
+				putc(' ', stdout);
+				putc(0x08, stdout);
+			}
+		}
+	}
+	Print("\n");
+
+	RestoreConsole(console);
+
+	return (escape ? false : true);
+}
+
+// Show the prompt
+wchar_t *Prompt(wchar_t *prompt_str)
+{
+	wchar_t *ret = NULL;
+	wchar_t *tmp = NULL;
+	// Validate arguments
+	if (prompt_str == NULL)
+	{
+		prompt_str = L"";
+	}
+
+#ifdef	OS_WIN32
+	UniPrint(L"%s", prompt_str);
+	tmp = Malloc(MAX_PROMPT_STRSIZE);
+	if (fgetws(tmp, MAX_PROMPT_STRSIZE - 1, stdin) != NULL)
+	{
+		bool escape = false;
+		UINT i, len;
+
+		len = UniStrLen(tmp);
+		for (i = 0;i < len;i++)
+		{
+			if (tmp[i] == 0x04 || tmp[i] == 0x1A)
+			{
+				escape = true;
+				break;
+			}
+		}
+
+		if (escape == false)
+		{
+			UniTrimCrlf(tmp);
+
+			ret = UniCopyStr(tmp);
+		}
+	}
+	Free(tmp);
+#else	// OS_WIN32
+	{
+		char *prompt = CopyUniToStr(prompt_str);
+		#ifdef __ANDROID__
+		char *s = strdup("");
+		#else
+		char *s = readline(prompt);
+		#endif
+		Free(prompt);
+
+		if (s != NULL)
+		{
+			TrimCrlf(s);
+			Trim(s);
+
+			if (IsEmptyStr(s) == false)
+			{
+				#ifndef __ANDROID__
+				add_history(s);
+				#endif
+			}
+
+			ret = CopyStrToUni(s);
+
+			free(s);
+		}
+	}
+#endif	// OS_WIN32
+
+	if (ret == NULL)
+	{
+		Print("\n");
+	}
+
+	return ret;
+}
+char *PromptA(wchar_t *prompt_str)
+{
+	wchar_t *str = Prompt(prompt_str);
+
+	if (str == NULL)
+	{
+		return NULL;
+	}
+	else
+	{
+		char *ret = CopyUniToStr(str);
+
+		Free(str);
+		return ret;
+	}
+}
+
+// Set the console to raw mode
+void *SetConsoleRaw()
+{
+#ifdef	OS_UNIX
+	struct termios t, *ret;
+
+	Zero(&t, sizeof(t));
+	if (tcgetattr(0, &t) != 0)
+	{
+		// Failed
+		return NULL;
+	}
+
+	// Copy the current settings
+	ret = Clone(&t, sizeof(t));
+
+	// Change the settings
+	t.c_lflag &= (~ICANON);
+	t.c_lflag &= (~ECHO);
+	t.c_cc[VTIME] = 0;
+	t.c_cc[VMIN] = 1;
+	tcsetattr(0, TCSANOW, &t);
+
+	return ret;
+#else	// OS_UNIX
+	return Malloc(0);
+#endif	// OS_UNIX
+}
+
+// Restore the mode of the console
+void RestoreConsole(void *p)
+{
+#ifdef	OS_UNIX
+	struct termios *t;
+	// Validate arguments
+	if (p == NULL)
+	{
+		return;
+	}
+
+	t = (struct termios *)p;
+
+	// Restore the settings
+	tcsetattr(0, TCSANOW, t);
+
+	Free(t);
+#else	// OS_UNIX
+	if (p != NULL)
+	{
+		Free(p);
+	}
+#endif	// OS_UNIX
+}
+
+////////////////////////////
+// Local console function
+
+// Creating a new local console
+CONSOLE *NewLocalConsole(wchar_t *infile, wchar_t *outfile)
+{
+	IO *in_io = NULL, *out_io = NULL;
+	CONSOLE *c = ZeroMalloc(sizeof(CONSOLE));
+	LOCAL_CONSOLE_PARAM *p;
+	UINT old_size = 0;
+
+#ifdef	OS_WIN32
+	if (MsGetConsoleWidth() == 80)
+	{
+		//old_size = MsSetConsoleWidth(WIN32_DEFAULT_CONSOLE_WIDTH);
+	}
+#endif	// OS_WIN32
+
+	c->ConsoleType = CONSOLE_LOCAL;
+	c->Free = ConsoleLocalFree;
+	c->ReadLine = ConsoleLocalReadLine;
+	c->ReadPassword = ConsoleLocalReadPassword;
+	c->Write = ConsoleLocalWrite;
+	c->GetWidth = ConsoleLocalGetWidth;
+	c->OutputLock = NewLock();
+
+	if (UniIsEmptyStr(infile) == false)
+	{
+		// Input file is specified
+		in_io = FileOpenW(infile, false);
+		if (in_io == NULL)
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			UniFormat(tmp, sizeof(tmp), _UU("CON_INFILE_ERROR"), infile);
+			c->Write(c, tmp);
+			Free(c);
+			return NULL;
+		}
+		else
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			UniFormat(tmp, sizeof(tmp), _UU("CON_INFILE_START"), infile);
+			c->Write(c, tmp);
+		}
+	}
+
+	if (UniIsEmptyStr(outfile) == false)
+	{
+		// Output file is specified
+		out_io = FileCreateW(outfile);
+		if (out_io == NULL)
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			UniFormat(tmp, sizeof(tmp), _UU("CON_OUTFILE_ERROR"), outfile);
+			c->Write(c, tmp);
+			Free(c);
+
+			if (in_io != NULL)
+			{
+				FileClose(in_io);
+			}
+			return NULL;
+		}
+		else
+		{
+			wchar_t tmp[MAX_SIZE];
+
+			UniFormat(tmp, sizeof(tmp), _UU("CON_OUTFILE_START"), outfile);
+			c->Write(c, tmp);
+		}
+	}
+
+	p = ZeroMalloc(sizeof(LOCAL_CONSOLE_PARAM));
+	c->Param = p;
+
+	p->InFile = in_io;
+	p->OutFile = out_io;
+	p->Win32_OldConsoleWidth = old_size;
+
+	if (in_io != NULL)
+	{
+		UINT size;
+		void *buf;
+
+		size = FileSize(in_io);
+		buf = ZeroMalloc(size + 1);
+		FileRead(in_io, buf, size);
+
+		p->InBuf = NewBuf();
+		WriteBuf(p->InBuf, buf, size);
+		Free(buf);
+
+		p->InBuf->Current = 0;
+	}
+
+	return c;
+}
+
+// Release Console
+void ConsoleLocalFree(CONSOLE *c)
+{
+	LOCAL_CONSOLE_PARAM *p;
+	// Validate arguments
+	if (c == NULL)
+	{
+		return;
+	}
+
+	p = (LOCAL_CONSOLE_PARAM *)c->Param;
+
+#ifdef	OS_WIN32
+	if (p->Win32_OldConsoleWidth != 0)
+	{
+		MsSetConsoleWidth(p->Win32_OldConsoleWidth);
+	}
+#endif	// OS_WIN32
+
+	if (p != NULL)
+	{
+		if (p->InFile != NULL)
+		{
+			FileClose(p->InFile);
+			FreeBuf(p->InBuf);
+		}
+
+		if (p->OutFile != NULL)
+		{
+			FileClose(p->OutFile);
+		}
+
+		Free(p);
+	}
+
+	DeleteLock(c->OutputLock);
+
+	// Memory release
+	Free(c);
+}
+
+// Get the width of the screen
+UINT ConsoleLocalGetWidth(CONSOLE *c)
+{
+	UINT ret = 0;
+	// Validate arguments
+	if (c == NULL)
+	{
+		return 0;
+	}
+
+#ifdef	OS_WIN32
+	ret = MsGetConsoleWidth();
+#else	// OS_WIN32
+	{
+		struct winsize t;
+
+		Zero(&t, sizeof(t));
+
+		if (ioctl(1, TIOCGWINSZ, &t) == 0)
+		{
+			ret = t.ws_col;
+		}
+	}
+#endif	// OS_WIN32
+
+	return ret;
+}
+
+// Read one line from the console
+wchar_t *ConsoleLocalReadLine(CONSOLE *c, wchar_t *prompt, bool nofile)
+{
+	wchar_t *ret;
+	LOCAL_CONSOLE_PARAM *p;
+	// Validate arguments
+	if (c == NULL)
+	{
+		return NULL;
+	}
+	p = (LOCAL_CONSOLE_PARAM *)c->Param;
+	if (prompt == NULL)
+	{
+		prompt = L">";
+	}
+
+	ConsoleWriteOutFile(c, prompt, false);
+
+	if (nofile == false && p->InBuf != NULL)
+	{
+		// Read the next line from the file
+		ret = ConsoleReadNextFromInFile(c);
+
+		if (ret != NULL)
+		{
+			// Display the pseudo prompt
+			UniPrint(L"%s", prompt);
+
+			// Display on the screen
+			UniPrint(L"%s\n", ret);
+		}
+	}
+	else
+	{
+		// Read the following line from the console
+		ret = Prompt(prompt);
+	}
+
+	if (ret != NULL)
+	{
+		ConsoleWriteOutFile(c, ret, true);
+	}
+	else
+	{
+		ConsoleWriteOutFile(c, _UU("CON_USER_CANCEL"), true);
+	}
+
+	return ret;
+}
+
+// Read the password from the console
+char *ConsoleLocalReadPassword(CONSOLE *c, wchar_t *prompt)
+{
+	char tmp[64];
+	// Validate arguments
+	if (c == NULL)
+	{
+		return NULL;
+	}
+	if (prompt == NULL)
+	{
+		prompt = L"Password>";
+	}
+
+	UniPrint(L"%s", prompt);
+	ConsoleWriteOutFile(c, prompt, false);
+
+	if (PasswordPrompt(tmp, sizeof(tmp)))
+	{
+		ConsoleWriteOutFile(c, L"********", true);
+		return CopyStr(tmp);
+	}
+	else
+	{
+		ConsoleWriteOutFile(c, _UU("CON_USER_CANCEL"), true);
+		return NULL;
+	}
+}
+
+// Display a string to the console
+bool ConsoleLocalWrite(CONSOLE *c, wchar_t *str)
+{
+	// Validate arguments
+	if (c == NULL || str == NULL)
+	{
+		return false;
+	}
+
+	UniPrint(L"%s%s", str, (UniEndWith(str, L"\n") ? L"" : L"\n"));
+
+	ConsoleWriteOutFile(c, str, true);
+
+	return true;
+}
+
+// Read the next line from the input file
+wchar_t *ConsoleReadNextFromInFile(CONSOLE *c)
+{
+	LOCAL_CONSOLE_PARAM *p;
+	char *str;
+	// Validate arguments
+	if (c == NULL)
+	{
+		return NULL;
+	}
+
+	p = (LOCAL_CONSOLE_PARAM *)c->Param;
+
+	if (p->InBuf == NULL)
+	{
+		return NULL;
+	}
+
+	while (true)
+	{
+		str = CfgReadNextLine(p->InBuf);
+
+		if (str == NULL)
+		{
+			return NULL;
+		}
+
+		Trim(str);
+
+		if (IsEmptyStr(str) == false)
+		{
+			UINT size;
+			wchar_t *ret;
+
+			size = CalcUtf8ToUni((BYTE *)str, StrLen(str));
+			ret = ZeroMalloc(size + 32);
+			Utf8ToUni(ret, size, (BYTE *)str, StrLen(str));
+
+			Free(str);
+
+			return ret;
+		}
+
+		Free(str);
+	}
+}
+
+// Write when the output file is specified
+void ConsoleWriteOutFile(CONSOLE *c, wchar_t *str, bool add_last_crlf)
+{
+	LOCAL_CONSOLE_PARAM *p;
+	// Validate arguments
+	if (c == NULL || str == NULL)
+	{
+		return;
+	}
+
+	p = (LOCAL_CONSOLE_PARAM *)c->Param;
+
+	if (p != NULL && p->OutFile != NULL)
+	{
+		wchar_t *tmp = UniNormalizeCrlf(str);
+		UINT utf8_size;
+		UCHAR *utf8;
+
+		utf8_size = CalcUniToUtf8(tmp);
+		utf8 = ZeroMalloc(utf8_size + 1);
+		UniToUtf8(utf8, utf8_size + 1, tmp);
+
+		FileWrite(p->OutFile, utf8, utf8_size);
+
+		if (UniEndWith(str, L"\n") == false && add_last_crlf)
+		{
+			char *crlf = "\r\n";
+			FileWrite(p->OutFile, "\r\n", StrLen(crlf));
+		}
+
+		Free(utf8);
+		Free(tmp);
+	}
+
+}
diff --git a/src/Mayaqua/FileIO.c b/src/Mayaqua/FileIO.c
index 5e4b9c9..154a4f1 100644
--- a/src/Mayaqua/FileIO.c
+++ b/src/Mayaqua/FileIO.c
@@ -1,2180 +1,2202 @@
-// SoftEther VPN Source Code - Developer Edition Master Branch
-// Mayaqua Kernel
-
-
-// FileIO.c
-// File Input / Output code
-
-#include "FileIO.h"
-
-#include "Cfg.h"
-#include "GlobalConst.h"
-#include "Internat.h"
-#include "Memory.h"
-#include "Microsoft.h"
-#include "Str.h"
-#include "Tick64.h"
-#include "Tracking.h"
-#include "Unix.h"
-#include "Win32.h"
-
-#include <Hamcore.h>
-
-static char exe_file_name[MAX_SIZE] = "/tmp/a.out";
-static wchar_t exe_file_name_w[MAX_SIZE] = L"/tmp/a.out";
-static LIST *hamcore = NULL;
-static HAMCORE *hamcore_io = NULL;
-
-#define	NUM_CRC32_TABLE	256
-static UINT crc32_table[NUM_CRC32_TABLE];
-
-// Confirm that the specified string exists as a line
-bool IsInLines(BUF *buf, char *str, bool instr)
-{
-	bool ret = false;
-	// Validate arguments
-	if (buf == NULL || str == NULL)
-	{
-		return false;
-	}
-
-	if (IsEmptyStr(str))
-	{
-		return false;
-	}
-
-	SeekBufToBegin(buf);
-
-	while (ret == false)
-	{
-		char *line = CfgReadNextLine(buf);
-
-		if (line == NULL)
-		{
-			break;
-		}
-
-		Trim(line);
-
-		if (IsEmptyStr(line) == false)
-		{
-			if (StrCmpi(line, str) == 0)
-			{
-				ret = true;
-			}
-
-			if (instr)
-			{
-				if (InStr(str, line))
-				{
-					ret = true;
-				}
-
-				if (InStr(line, str))
-				{
-					ret = true;
-				}
-			}
-		}
-
-		Free(line);
-	}
-
-	return ret;
-}
-bool IsInLinesFile(wchar_t *filename, char *str, bool instr)
-{
-	bool ret = false;
-	BUF *b;
-	// Validate arguments
-	if (filename == NULL || str == NULL)
-	{
-		return false;
-	}
-
-	b = ReadDumpW(filename);
-	if (b == NULL)
-	{
-		return false;
-	}
-
-	ret = IsInLines(b, str, instr);
-
-	FreeBuf(b);
-
-	return ret;
-}
-
-// Check whether the file is write-locked
-bool IsFileWriteLockedW(wchar_t *name)
-{
-	IO *io;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	if (IsFileExistsW(name) == false)
-	{
-		return false;
-	}
-
-	io = FileOpenW(name, true);
-	if (io == NULL)
-	{
-		return true;
-	}
-
-	FileClose(io);
-
-	return false;
-}
-
-// Creating a ZIP packer
-ZIP_PACKER *NewZipPacker()
-{
-	ZIP_PACKER *p = ZeroMalloc(sizeof(ZIP_PACKER));
-
-	p->Fifo = NewFifo();
-	p->FileList = NewList(NULL);
-	p->CurrentFile = NULL;
-
-	return p;
-}
-
-// Release of ZIP packer
-void FreeZipPacker(ZIP_PACKER *p)
-{
-	UINT i;
-	// Validate arguments
-	if (p == NULL)
-	{
-		return;
-	}
-
-	ReleaseFifo(p->Fifo);
-
-	for (i = 0;i < LIST_NUM(p->FileList);i++)
-	{
-		ZIP_FILE *f = LIST_DATA(p->FileList, i);
-
-		Free(f);
-	}
-
-	ReleaseList(p->FileList);
-
-	Free(p);
-}
-
-// Simply add the file
-void ZipAddFileSimple(ZIP_PACKER *p, char *name, UINT64 dt, UINT attribute, void *data, UINT size)
-{
-	// Validate arguments
-	if (p == NULL || IsEmptyStr(name) || (size != 0 && data == NULL))
-	{
-		return;
-	}
-
-	ZipAddFileStart(p, name, size, dt, attribute);
-	ZipAddFileData(p, data, 0, size);
-}
-bool ZipAddRealFileW(ZIP_PACKER *p, char *name, UINT64 dt, UINT attribute, wchar_t *srcname)
-{
-	BUF *b;
-	// Validate arguments
-	if (p == NULL || IsEmptyStr(name) || srcname == NULL)
-	{
-		return false;
-	}
-
-	b = ReadDumpW(srcname);
-	if (b == NULL)
-	{
-		return false;
-	}
-
-	ZipAddFileSimple(p, name, dt, attribute, b->Buf, b->Size);
-
-	FreeBuf(b);
-
-	return true;
-}
-bool ZipAddRealFile(ZIP_PACKER *p, char *name, UINT64 dt, UINT attribute, char *srcname)
-{
-	bool ret = false;
-	wchar_t *s;
-
-	s = CopyStrToUni(srcname);
-
-	ret = ZipAddRealFileW(p, name, dt, attribute, s);
-
-	Free(s);
-
-	return ret;
-}
-
-// Start adding a file
-void ZipAddFileStart(ZIP_PACKER *p, char *name, UINT size, UINT64 dt, UINT attribute)
-{
-	char tmp[MAX_PATH];
-	ZIP_FILE *f;
-	ZIP_DATA_HEADER h;
-	// Validate arguments
-	if (p == NULL || IsEmptyStr(name))
-	{
-		return;
-	}
-	if (dt == 0)
-	{
-		dt = LocalTime64();
-	}
-
-	if (p->CurrentFile != NULL)
-	{
-		return;
-	}
-
-	StrCpy(tmp, sizeof(tmp), name);
-	ReplaceStrEx(tmp, sizeof(tmp), tmp, "/", "\\", true);
-
-	f = ZeroMalloc(sizeof(ZIP_FILE));
-
-	StrCpy(f->Name, sizeof(f->Name), tmp);
-	f->Size = size;
-	f->DateTime = dt;
-	f->Attributes = attribute;
-
-	Add(p->FileList, f);
-
-	Zero(&h, sizeof(h));
-	f->HeaderPos = (UINT)p->Fifo->total_write_size;
-	WriteZipDataHeader(f, &h, false);
-	WriteFifo(p->Fifo, &h, sizeof(h));
-	WriteFifo(p->Fifo, f->Name, StrLen(f->Name));
-	f->Crc32 = 0xffffffff;
-
-	p->CurrentFile = f;
-}
-
-// Add data to the file
-UINT ZipAddFileData(ZIP_PACKER *p, void *data, UINT pos, UINT len)
-{
-	UINT ret;
-	UINT total_size;
-	// Validate arguments
-	if (p == NULL)
-	{
-		return 0;
-	}
-
-	total_size = p->CurrentFile->CurrentSize + len;
-
-	if (total_size > p->CurrentFile->Size)
-	{
-		return 0;
-	}
-
-	WriteFifo(p->Fifo, ((UCHAR *)data) + pos, len);
-
-	p->CurrentFile->CurrentSize += len;
-	p->CurrentFile->Crc32 = Crc32Next(data, pos, len, p->CurrentFile->Crc32);
-
-	ret = p->CurrentFile->Size - p->CurrentFile->CurrentSize;
-
-	if (ret == 0)
-	{
-		p->CurrentFile->Crc32 = ~p->CurrentFile->Crc32;
-
-		ZipAddFileFooter(p);
-
-		p->CurrentFile = NULL;
-	}
-
-	return ret;
-}
-
-// Append a file footer
-void ZipAddFileFooter(ZIP_PACKER *p)
-{
-	ZIP_DATA_FOOTER f;
-	// Validate arguments
-	if (p == NULL)
-	{
-		return;
-	}
-
-	Zero(&f, sizeof(f));
-	WriteZipDataFooter(p->CurrentFile, &f);
-
-	WriteFifo(p->Fifo, &f, sizeof(f));
-}
-
-// Output the ZIP data to a file
-bool ZipWriteW(ZIP_PACKER *p, wchar_t *name)
-{
-	FIFO *f;
-	// Validate arguments
-	if (p == NULL || name == NULL)
-	{
-		return false;
-	}
-
-	f = ZipFinish(p);
-	if (f == NULL)
-	{
-		return false;
-	}
-
-	return FileWriteAllW(name, FifoPtr(f), FifoSize(f));
-}
-
-// Complete the creation of the ZIP data
-FIFO *ZipFinish(ZIP_PACKER *p)
-{
-	UINT i;
-	UINT pos_start;
-	UINT pos_end;
-	ZIP_END_HEADER e;
-	// Validate arguments
-	if (p == NULL)
-	{
-		return NULL;
-	}
-
-	pos_start = (UINT)p->Fifo->total_write_size;
-
-	for (i = 0;i < LIST_NUM(p->FileList);i++)
-	{
-		ZIP_FILE *f = LIST_DATA(p->FileList, i);
-		ZIP_DIR_HEADER d;
-		ZIP_DATA_HEADER dh;
-
-		Zero(&d, sizeof(d));
-		Zero(&dh, sizeof(dh));
-
-		d.Signature = Endian32(Swap32(0x02014B50));
-		d.MadeVer = Endian16(Swap16(ZIP_VERSION));
-
-		WriteZipDataHeader(f, &dh, true);
-
-		d.NeedVer = dh.NeedVer;
-		d.Option = dh.Option;
-		d.CompType = dh.CompType;
-		d.FileTime = dh.FileTime;
-		d.FileDate = dh.FileDate;
-		d.Crc32 = dh.Crc32;
-		d.CompSize = dh.CompSize;
-		d.UncompSize = dh.UncompSize;
-		d.FileNameLen = dh.FileNameLen;
-		d.ExtraLen = dh.ExtraLen;
-		d.CommentLen = 0;
-		d.DiskNum = 0;
-		d.InAttr = 0;
-		d.OutAttr = Endian32(Swap32((USHORT)f->Attributes));
-		d.HeaderPos = Endian32(Swap32(f->HeaderPos));
-
-		WriteFifo(p->Fifo, &d, sizeof(d));
-		WriteFifo(p->Fifo, f->Name, StrLen(f->Name));
-	}
-
-	pos_end = (UINT)p->Fifo->total_write_size;
-
-	Zero(&e, sizeof(e));
-	e.Signature = Endian32(Swap32(ZIP_SIGNATURE_END));
-	e.DiskNum = e.StartDiskNum = 0;
-	e.DiskDirEntry = e.DirEntry = Endian16(Swap16((USHORT)LIST_NUM(p->FileList)));
-	e.DirSize = Endian32(Swap32((UINT)(pos_end - pos_start)));
-	e.StartPos = Endian32(Swap32(pos_start));
-	e.CommentLen = 0;
-
-	WriteFifo(p->Fifo, &e, sizeof(e));
-
-	return p->Fifo;
-}
-
-// Creating a ZIP data header
-void WriteZipDataHeader(ZIP_FILE *f, ZIP_DATA_HEADER *h, bool write_sizes)
-{
-	// Validate arguments
-	if (f == NULL || h ==NULL)
-	{
-		return;
-	}
-
-	h->Signature = Endian32(Swap32(ZIP_SIGNATURE));
-	h->NeedVer = Endian16(Swap16(ZIP_VERSION));
-	h->CompType = 0;
-	h->FileDate = Endian16(Swap16(System64ToDosDate(f->DateTime)));
-	h->FileTime = Endian16(Swap16(System64ToDosTime(f->DateTime)));
-	h->Option = Endian16(Swap16(8)); // bit3: Set the file-size and the CRC in local header to 0
-
-	if (write_sizes == false)
-	{
-		h->CompSize = h->UncompSize = 0;
-		h->Crc32 = 0;
-	}
-	else
-	{
-		h->CompSize = h->UncompSize = Endian32(Swap32(f->Size));
-		h->Crc32 = Endian32(Swap32(f->Crc32));
-	}
-
-	h->FileNameLen = Endian16(Swap16(StrLen(f->Name)));
-	h->ExtraLen = 0;
-}
-
-// Creating a ZIP data footer
-void WriteZipDataFooter(ZIP_FILE *f, ZIP_DATA_FOOTER *h)
-{
-	// Validate arguments
-	if (f == NULL || h ==NULL)
-	{
-		return;
-	}
-
-	h->Signature = Endian32(Swap32(0x08074B50));
-	h->CompSize = h->UncompSize = Endian32(Swap32(f->Size));
-	h->Crc32 = Endian32(Swap32(f->Crc32));
-}
-
-// Initialize the common table of CRC32
-void InitCrc32()
-{
-	UINT poly = 0xEDB88320;
-	UINT u, i, j;
-
-	for (i = 0;i < 256;i++)
-	{
-		u = i;
-
-		for (j = 0;j < 8;j++)
-		{
-			if ((u & 0x1) != 0)
-			{
-				u = (u >> 1) ^ poly;
-			}
-			else
-			{
-				u >>= 1;
-			}
-		}
-
-		crc32_table[i] = u;
-	}
-}
-
-// CRC32 arithmetic processing
-UINT Crc32(void *buf, UINT pos, UINT len)
-{
-	return Crc32Finish(Crc32First(buf, pos, len));
-}
-UINT Crc32First(void *buf, UINT pos, UINT len)
-{
-	return Crc32Next(buf, pos, len, 0xffffffff);
-}
-UINT Crc32Next(void *buf, UINT pos, UINT len, UINT last_crc32)
-{
-	UINT ret = last_crc32;
-	UINT i;
-
-	for (i = 0;i < len;i++)
-	{
-		ret = (ret >> 8) ^ crc32_table[((UCHAR *)buf)[pos + i] ^ (ret & 0xff)];
-	}
-
-	return ret;
-}
-UINT Crc32Finish(UINT last_crc32)
-{
-	return ~last_crc32;
-}
-
-// Save the file
-bool SaveFileW(wchar_t *name, void *data, UINT size)
-{
-	IO *io;
-	// Validate arguments
-	if (name == NULL || (data == NULL && size != 0))
-	{
-		return false;
-	}
-
-	io = FileCreateW(name);
-	if (io == NULL)
-	{
-		return false;
-	}
-
-	if (FileWrite(io, data, size) == false)
-	{
-		FileClose(io);
-		return false;
-	}
-
-	FileClose(io);
-
-	return true;
-}
-bool SaveFile(char *name, void *data, UINT size)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	bool ret = SaveFileW(name_w, data, size);
-
-	Free(name_w);
-
-	return ret;
-}
-
-// Check whether the file exists
-bool IsFile(char *name)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	bool ret = IsFileW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-bool IsFileW(wchar_t *name)
-{
-	IO *io;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	io = FileOpenExW(name, false, false);
-	if (io == NULL)
-	{
-		return false;
-	}
-
-	FileClose(io);
-
-	return true;
-}
-
-// Make the file name safe
-void ConvertSafeFileName(char *dst, UINT size, char *src)
-{
-	UINT i;
-	// Validate arguments
-	if (dst == NULL || src == NULL)
-	{
-		return;
-	}
-
-	StrCpy(dst, size, src);
-	for (i = 0;i < StrLen(dst);i++)
-	{
-		if (IsSafeChar(dst[i]) == false)
-		{
-			dst[i] = '_';
-		}
-	}
-}
-
-// Get the free disk space
-bool GetDiskFree(char *path, UINT64 *free_size, UINT64 *used_size, UINT64 *total_size)
-{
-	bool ret;
-	// Validate arguments
-	if (path == NULL)
-	{
-		path = "./";
-	}
-
-#ifdef	OS_WIN32
-	ret = Win32GetDiskFree(path, free_size, used_size, total_size);
-#else	// OS_WIN32
-	ret = UnixGetDiskFree(path, free_size, used_size, total_size);
-#endif	// OS_WIN32
-
-	return ret;
-}
-
-// Enumeration of directory
-DIRLIST *EnumDirEx(char *dirname, COMPARE *compare)
-{
-	wchar_t *dirname_w = CopyStrToUni(dirname);
-	DIRLIST *ret = EnumDirExW(dirname_w, compare);
-
-	Free(dirname_w);
-
-	return ret;
-}
-DIRLIST *EnumDirExW(wchar_t *dirname, COMPARE *compare)
-{
-	DIRLIST *d = NULL;
-	// Validate arguments
-	if (dirname == NULL)
-	{
-		dirname = L"./";
-	}
-
-	if (compare == NULL)
-	{
-		compare = CompareDirListByName;
-	}
-
-#ifdef	OS_WIN32
-	d = Win32EnumDirExW(dirname, compare);
-#else	// OS_WIN32
-	d = UnixEnumDirExW(dirname, compare);
-#endif	// OS_WIN32
-
-	return d;
-}
-DIRLIST *EnumDir(char *dirname)
-{
-	return EnumDirEx(dirname, NULL);
-}
-DIRLIST *EnumDirW(wchar_t *dirname)
-{
-	return EnumDirExW(dirname, NULL);
-}
-
-// Comparison of DIRLIST list entry
-int CompareDirListByName(void *p1, void *p2)
-{
-	DIRENT *d1, *d2;
-	if (p1 == NULL || p2 == NULL)
-	{
-		return 0;
-	}
-	d1 = *(DIRENT **)p1;
-	d2 = *(DIRENT **)p2;
-	if (d1 == NULL || d2 == NULL)
-	{
-		return 0;
-	}
-	return UniStrCmpi(d1->FileNameW, d2->FileNameW);
-}
-
-// Release the enumeration of the directory 
-void FreeDir(DIRLIST *d)
-{
-	UINT i;
-	// Validate arguments
-	if (d == NULL)
-	{
-		return;
-	}
-
-	for (i = 0;i < d->NumFiles;i++)
-	{
-		DIRENT *f = d->File[i];
-		Free(f->FileName);
-		Free(f->FileNameW);
-		Free(f);
-	}
-	Free(d->File);
-	Free(d);
-}
-
-
-// Make the file name safe
-void UniSafeFileName(wchar_t *name)
-{
-	UINT i, len, dlen;
-	static wchar_t *danger_str = L"\\/:*?\"<>|";
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	dlen = UniStrLen(danger_str);
-	len = UniStrLen(name);
-
-	for (i = 0;i < len;i++)
-	{
-		wchar_t c = name[i];
-		UINT j;
-		for (j = 0;j < dlen;j++)
-		{
-			if (c == danger_str[j])
-			{
-				c = L'_';
-			}
-		}
-		name[i] = c;
-	}
-}
-
-// Read HamCore file
-BUF *ReadHamcoreW(wchar_t *filename)
-{
-	char *filename_a = CopyUniToStr(filename);
-	BUF *ret;
-
-	ret = ReadHamcore(filename_a);
-
-	Free(filename_a);
-
-	return ret;
-}
-BUF *ReadHamcore(char *name)
-{
-	if (name == NULL || MayaquaIsMinimalMode())
-	{
-		return NULL;
-	}
-
-	if (name[0] == '/')
-	{
-		++name;
-	}
-
-	char path[MAX_PATH];
-	GetExeDir(path, sizeof(path));
-	Format(path, sizeof(path), "%s/%s/%s", path, HAMCORE_DIR_NAME, name);
-
-	BUF *buf = ReadDump(path);
-	if (buf != NULL)
-	{
-		return buf;
-	}
-
-	LockList(hamcore);
-	{
-		HC t = {0};
-		t.Path = name;
-		HC *c = Search(hamcore, &t);
-		if (c == NULL)
-		{
-			const HAMCORE_FILE *file = HamcoreFind(hamcore_io, name);
-			if (file)
-			{
-				c = Malloc(sizeof(HC));
-				c->Size = file->OriginalSize;
-				c->Path = CopyStr(name);
-				c->Buffer = Malloc(c->Size);
-
-				if (HamcoreRead(hamcore_io, c->Buffer, file))
-				{
-					Add(hamcore, c);
-				}
-				else
-				{
-					Free(c->Buffer);
-					Free(c->Path);
-					Free(c);
-
-					c = NULL;
-				}
-			}
-		}
-
-		if (c != NULL)
-		{
-			buf = NewBuf();
-			WriteBuf(buf, c->Buffer, c->Size);
-			SeekBuf(buf, 0, 0);
-			c->LastAccess = Tick64();
-		}
-
-		LIST *to_delete = NewListFast(NULL);
-
-		for (UINT i = 0; i < LIST_NUM(hamcore); ++i)
-		{
-			HC *c = LIST_DATA(hamcore, i);
-			if (c->LastAccess + HAMCORE_CACHE_EXPIRES <= Tick64())
-			{
-				Add(to_delete, c);
-			}
-		}
-
-		for (UINT i = 0; i < LIST_NUM(to_delete); ++i)
-		{
-			HC *c = LIST_DATA(to_delete, i);
-
-			Delete(hamcore, c);
-
-			Free(c->Buffer);
-			Free(c->Path);
-			Free(c);
-		}
-
-		ReleaseList(to_delete);
-	}
-	UnlockList(hamcore);
-
-	return buf;
-}
-
-// Initialization of HamCore file system
-void InitHamcore()
-{
-	if (MayaquaIsMinimalMode())
-	{
-		return;
-	}
-
-	hamcore = NewList(CompareHamcore);
-#ifdef HAMCORE_FILE_PATH
-	hamcore_io = HamcoreOpen(HAMCORE_FILE_PATH);
-	if (hamcore_io != NULL)
-	{
-		Debug("InitHamcore(): Loaded from \"%s\".\n", HAMCORE_FILE_PATH);
-		return;
-	}
-#endif
-	char path[MAX_PATH];
-	GetExeDir(path, sizeof(path));
-	Format(path, sizeof(path), "%s/%s", path, HAMCORE_FILE_NAME);
-
-	hamcore_io = HamcoreOpen(path);
-	if (hamcore_io != NULL)
-	{
-		Debug("InitHamcore(): Loaded from \"%s\".\n", path);
-	}
-}
-
-// Release of HamCore file system
-void FreeHamcore()
-{
-	for (UINT i = 0; i < LIST_NUM(hamcore); ++i)
-	{
-		HC *c = LIST_DATA(hamcore, i);
-
-		Free(c->Buffer);
-		Free(c->Path);
-		Free(c);
-	}
-	ReleaseList(hamcore);
-
-	HamcoreClose(hamcore_io);
-	hamcore_io = NULL;
-	hamcore = NULL;
-}
-
-// Comparison of the HCs
-int CompareHamcore(void *p1, void *p2)
-{
-	HC *c1, *c2;
-	if (p1 == NULL || p2 == NULL)
-	{
-		return 0;
-	}
-	c1 = *(HC **)p1;
-	c2 = *(HC **)p2;
-	if (c1 == NULL || c2 == NULL)
-	{
-		return 0;
-	}
-	return StrCmpi(c1->Path, c2->Path);
-}
-
-// Getting the name of the directory where the EXE file is in
-void GetExeDir(char *name, UINT size)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	GetDirNameFromFilePath(name, size, exe_file_name);
-}
-void GetExeDirW(wchar_t *name, UINT size)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	GetDirNameFromFilePathW(name, size, exe_file_name_w);
-}
-
-// Get the EXE file name
-void GetExeName(char *name, UINT size)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	StrCpy(name, size, exe_file_name);
-}
-void GetExeNameW(wchar_t *name, UINT size)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	UniStrCpy(name, size, exe_file_name_w);
-}
-
-void GetLogDir(char *name, UINT size)
-{
-#ifdef SE_LOGDIR
-	Format(name, size, SE_LOGDIR);
-#else
-	GetExeDir(name, size);
-#endif
-}
-
-void GetLogDirW(wchar_t *name, UINT size)
-{
-#ifdef SE_LOGDIR
-	UniFormat(name, size, L""SE_LOGDIR);
-#else
-	GetExeDirW(name, size);
-#endif
-}
-
-void GetDbDir(char *name, UINT size)
-{
-#ifdef SE_DBDIR
-	Format(name, size, SE_DBDIR);
-#else
-	GetExeDir(name, size);
-#endif
-}
-
-void GetDbDirW(wchar_t *name, UINT size)
-{
-#ifdef SE_DBDIR
-	UniFormat(name, size, L""SE_DBDIR);
-#else
-	GetExeDirW(name, size);
-#endif
-}
-
-void GetPidDir(char *name, UINT size)
-{
-#ifdef SE_PIDDIR
-	Format(name, size, SE_PIDDIR);
-#else
-	GetExeDir(name, size);
-#endif
-}
-
-void GetPidDirW(wchar_t *name, UINT size)
-{
-#ifdef SE_PIDDIR
-	UniFormat(name, size, L""SE_PIDDIR);
-#else
-	GetExeDirW(name, size);
-#endif
-}
-
-// Initialization of the acquisition of the EXE file name
-void InitGetExeName(char *arg)
-{
-	wchar_t *arg_w = NULL;
-	// Validate arguments
-	if (arg == NULL)
-	{
-		arg = "./a.out";
-	}
-
-	arg_w = CopyUtfToUni(arg);
-
-#ifdef	OS_WIN32
-	Win32GetExeNameW(exe_file_name_w, sizeof(exe_file_name_w));
-#else	// OS_WIN32
-	UnixGetExeNameW(exe_file_name_w, sizeof(exe_file_name_w), arg_w);
-#endif	// OS_WIN32
-
-	UniToStr(exe_file_name, sizeof(exe_file_name), exe_file_name_w);
-
-	Free(arg_w);
-}
-
-// Get the full path of the executable binary file in Unix
-void UnixGetExeNameW(wchar_t *name, UINT size, wchar_t *arg)
-{
-	UNI_TOKEN_LIST *t;
-	char *path_str;
-	wchar_t *path_str_w;
-	bool ok = false;
-	// Validate arguments
-	if (name == NULL || arg == NULL)
-	{
-		return;
-	}
-
-	path_str = GetCurrentPathEnvStr();
-	path_str_w = CopyUtfToUni(path_str);
-
-	t = ParseSplitedPathW(path_str_w);
-
-	if (t != NULL)
-	{
-		UINT i;
-		for (i = 0;i < t->NumTokens;i++)
-		{
-			wchar_t *s = t->Token[i];
-			wchar_t tmp[MAX_SIZE];
-
-			ConbinePathW(tmp, sizeof(tmp), s, arg);
-
-			if (IsFileExistsInnerW(tmp))
-			{
-#ifdef	OS_UNIX
-				if (UnixCheckExecAccessW(tmp) == false)
-				{
-					continue;
-				}
-#endif	// OS_UNIX
-				ok = true;
-				UniStrCpy(name, size, tmp);
-				break;
-			}
-		}
-
-		UniFreeToken(t);
-	}
-
-	Free(path_str);
-	Free(path_str_w);
-
-	if (ok == false)
-	{
-		// In the case of failing to find the path
-#ifdef	OS_UNIX
-		UnixGetCurrentDirW(name, size);
-#else	// OS_UNIX
-		Win32GetCurrentDirW(name, size);
-#endif	// OS_UNIX
-		ConbinePathW(name, size, name, arg);
-	}
-}
-
-// Generate a secure file name
-void MakeSafeFileName(char *dst, UINT size, char *src)
-{
-	char tmp[MAX_PATH];
-	// Validate arguments
-	if (dst == NULL || src == NULL)
-	{
-		return;
-	}
-
-	StrCpy(tmp, sizeof(tmp), src);
-	ReplaceStrEx(tmp, sizeof(tmp), tmp, "..", "__", false);
-	ReplaceStrEx(tmp, sizeof(tmp), tmp, "/", "_", false);
-	ReplaceStrEx(tmp, sizeof(tmp), tmp, "\\", "_", false);
-	ReplaceStrEx(tmp, sizeof(tmp), tmp, "@", "_", false);
-	ReplaceStrEx(tmp, sizeof(tmp), tmp, "|", "_", false);
-
-	StrCpy(dst, size, tmp);
-}
-
-// Get the file name from the file path
-void GetFileNameFromFilePathW(wchar_t *dst, UINT size, wchar_t *filepath)
-{
-	wchar_t tmp[MAX_SIZE];
-	UINT i, len, wp;
-	// Validate arguments
-	if (dst == NULL || filepath == NULL)
-	{
-		return;
-	}
-
-	len = MIN(UniStrLen(filepath), (MAX_SIZE - 2));
-	wp = 0;
-
-	for (i = 0;i < (len + 1);i++)
-	{
-		wchar_t c = filepath[i];
-
-		switch (c)
-		{
-		case L'\\':
-		case L'/':
-		case 0:
-			tmp[wp] = 0;
-			wp = 0;
-			break;
-
-		default:
-			tmp[wp] = c;
-			wp++;
-			break;
-		}
-	}
-
-	UniStrCpy(dst, size, tmp);
-}
-void GetFileNameFromFilePath(char *dst, UINT size, char *filepath)
-{
-	char tmp[MAX_SIZE];
-	UINT i, len, wp;
-	// Validate arguments
-	if (dst == NULL || filepath == NULL)
-	{
-		return;
-	}
-
-	len = MIN(StrLen(filepath), (MAX_SIZE - 2));
-	wp = 0;
-
-	for (i = 0;i < (len + 1);i++)
-	{
-		char c = filepath[i];
-
-		switch (c)
-		{
-		case '\\':
-		case '/':
-		case 0:
-			tmp[wp] = 0;
-			wp = 0;
-			break;
-
-		default:
-			tmp[wp] = c;
-			wp++;
-			break;
-		}
-	}
-
-	StrCpy(dst, size, tmp);
-}
-void GetDirNameFromFilePathW(wchar_t *dst, UINT size, wchar_t *filepath)
-{
-	wchar_t tmp[MAX_SIZE];
-	UINT wp;
-	UINT i;
-	UINT len;
-	// Validate arguments
-	if (dst == NULL || filepath == NULL)
-	{
-		return;
-	}
-
-	UniStrCpy(tmp, sizeof(tmp), filepath);
-	if (UniEndWith(tmp, L"\\") || UniEndWith(tmp, L"/"))
-	{
-		tmp[UniStrLen(tmp) - 1] = 0;
-	}
-
-	len = UniStrLen(tmp);
-
-	UniStrCpy(dst, size, L"");
-
-	wp = 0;
-
-	for (i = 0;i < len;i++)
-	{
-		wchar_t c = tmp[i];
-		if (c == L'/' || c == L'\\')
-		{
-			tmp[wp++] = 0;
-			wp = 0;
-			UniStrCat(dst, size, tmp);
-			tmp[wp++] = c;
-		}
-		else
-		{
-			tmp[wp++] = c;
-		}
-	}
-
-	if (UniStrLen(dst) == 0)
-	{
-		UniStrCpy(dst, size, L"/");
-	}
-
-	NormalizePathW(dst, size, dst);
-}
-
-// Get the directory name from the file path
-void GetDirNameFromFilePath(char *dst, UINT size, char *filepath)
-{
-	char tmp[MAX_SIZE];
-	UINT wp;
-	UINT i;
-	UINT len;
-	// Validate arguments
-	if (dst == NULL || filepath == NULL)
-	{
-		return;
-	}
-
-	StrCpy(tmp, sizeof(tmp), filepath);
-	if (EndWith(tmp, "\\") || EndWith(tmp, "/"))
-	{
-		tmp[StrLen(tmp) - 1] = 0;
-	}
-
-	len = StrLen(tmp);
-
-	StrCpy(dst, size, "");
-
-	wp = 0;
-
-	for (i = 0;i < len;i++)
-	{
-		char c = tmp[i];
-		if (c == '/' || c == '\\')
-		{
-			tmp[wp++] = 0;
-			wp = 0;
-			StrCat(dst, size, tmp);
-			tmp[wp++] = c;
-		}
-		else
-		{
-			tmp[wp++] = c;
-		}
-	}
-
-	if (StrLen(dst) == 0)
-	{
-		StrCpy(dst, size, "/");
-	}
-
-	NormalizePath(dst, size, dst);
-}
-
-// Combine the two paths
-void ConbinePath(char *dst, UINT size, char *dirname, char *filename)
-{
-	wchar_t dst_w[MAX_PATH];
-	wchar_t *dirname_w = CopyStrToUni(dirname);
-	wchar_t *filename_w = CopyStrToUni(filename);
-
-	ConbinePathW(dst_w, sizeof(dst_w), dirname_w, filename_w);
-
-	Free(dirname_w);
-	Free(filename_w);
-
-	UniToStr(dst, size, dst_w);
-}
-void ConbinePathW(wchar_t *dst, UINT size, wchar_t *dirname, wchar_t *filename)
-{
-	bool is_full_path;
-	wchar_t tmp[MAX_SIZE];
-	wchar_t filename_ident[MAX_SIZE];
-	// Validate arguments
-	if (dst == NULL || dirname == NULL || filename == NULL)
-	{
-		return;
-	}
-
-	NormalizePathW(filename_ident, sizeof(filename_ident), filename);
-
-	is_full_path = false;
-
-	if (UniStartWith(filename_ident, L"\\") || UniStartWith(filename_ident, L"/"))
-	{
-		is_full_path = true;
-	}
-
-	filename = &filename_ident[0];
-
-#ifdef	OS_WIN32
-	if (UniStrLen(filename) >= 2)
-	{
-		if ((L'a' <= filename[0] && filename[0] <= L'z') || (L'A' <= filename[0] && filename[0] <= L'Z'))
-		{
-			if (filename[1] == L':')
-			{
-				is_full_path = true;
-			}
-		}
-	}
-#endif	// OS_WIN32
-
-	if (is_full_path == false)
-	{
-		UniStrCpy(tmp, sizeof(tmp), dirname);
-		if (UniEndWith(tmp, L"/") == false && UniEndWith(tmp, L"\\") == false)
-		{
-			UniStrCat(tmp, sizeof(tmp), L"/");
-		}
-		UniStrCat(tmp, sizeof(tmp), filename);
-	}
-	else
-	{
-		UniStrCpy(tmp, sizeof(tmp), filename);
-	}
-
-	NormalizePathW(dst, size, tmp);
-}
-void CombinePath(char *dst, UINT size, char *dirname, char *filename)
-{
-	ConbinePath(dst, size, dirname, filename);
-}
-void CombinePathW(wchar_t *dst, UINT size, wchar_t *dirname, wchar_t *filename)
-{
-	ConbinePathW(dst, size, dirname, filename);
-}
-
-// Check whether the file exists
-bool IsFileExists(char *name)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	bool ret = IsFileExistsW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-bool IsFileExistsW(wchar_t *name)
-{
-	wchar_t tmp[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	InnerFilePathW(tmp, sizeof(tmp), name);
-
-	return IsFileExistsInnerW(tmp);
-}
-bool IsFileExistsInnerW(wchar_t *name)
-{
-	IO *o;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	o = FileOpenInnerW(name, false, false);
-	if (o == NULL)
-	{
-		return false;
-	}
-
-	FileClose(o);
-
-	return true;
-}
-
-// Get the current contents of the PATH environment variable
-char *GetCurrentPathEnvStr()
-{
-	char tmp[1024];
-	char *tag_name;
-
-#ifdef	OS_WIN32
-	tag_name = "Path";
-#else	// OS_WIN32
-	tag_name = "PATH";
-#endif	// OS_WIN32
-
-	if (GetEnv(tag_name, tmp, sizeof(tmp)) == false)
-	{
-#ifdef	OS_WIN32
-		Win32GetCurrentDir(tmp, sizeof(tmp));
-#else	// OS_WIN32
-		UnixGetCurrentDir(tmp, sizeof(tmp));
-#endif	// OS_WIN32
-	}
-
-	return CopyStr(tmp);
-}
-
-// Get multiple paths separated by colons
-UNI_TOKEN_LIST *ParseSplitedPathW(wchar_t *path)
-{
-	UNI_TOKEN_LIST *ret;
-	wchar_t *tmp = UniCopyStr(path);
-	wchar_t *split_str;
-	UINT i;
-
-	UniTrim(tmp);
-	UniTrimCrlf(tmp);
-	UniTrim(tmp);
-	UniTrimCrlf(tmp);
-
-#ifdef	OS_WIN32
-	split_str = L";";
-#else	// OS_WIN32
-	split_str = L":";
-#endif	// OS_WIN32
-
-	ret = UniParseToken(tmp, split_str);
-
-	if (ret != NULL)
-	{
-		for (i = 0;i < ret->NumTokens;i++)
-		{
-			UniTrim(ret->Token[i]);
-			UniTrimCrlf(ret->Token[i]);
-			UniTrim(ret->Token[i]);
-			UniTrimCrlf(ret->Token[i]);
-		}
-	}
-
-	Free(tmp);
-
-	return ret;
-}
-
-// Normalize the file path
-void NormalizePathW(wchar_t *dst, UINT size, wchar_t *src)
-{
-	wchar_t tmp[MAX_SIZE];
-	UNI_TOKEN_LIST *t;
-	bool first_double_slash = false;
-	bool first_single_slash = false;
-#ifdef  OS_WIN32
-	wchar_t win32_drive_char = 0;
-#endif  // OS_WIN32
-	bool is_full_path = false;
-	UINT i;
-	SK *sk;
-	// Validate arguments
-	if (dst == NULL || src == 0)
-	{
-		return;
-	}
-
-	// Convert the path (Win32, UNIX conversion)
-	UniStrCpy(tmp, sizeof(tmp), src);
-	ConvertPathW(tmp);
-	UniTrim(tmp);
-
-	// If the path begins with "./ " or " ../", replace it to the current directory
-	if (UniStartWith(tmp, L"./") || UniStartWith(tmp, L".\\") ||
-		UniStartWith(tmp, L"../") || UniStartWith(tmp, L"..\\") ||
-		UniStrCmpi(tmp, L".") == 0 || UniStrCmpi(tmp, L"..") == 0)
-	{
-		wchar_t cd[MAX_SIZE];
-		Zero(cd, sizeof(cd));
-
-#ifdef	OS_WIN32
-		Win32GetCurrentDirW(cd, sizeof(cd));
-#else	// OS_WIN32
-		UnixGetCurrentDirW(cd, sizeof(cd));
-#endif	// OS_WIN32
-
-		if (UniStartWith(tmp, L".."))
-		{
-			UniStrCat(cd, sizeof(cd), L"/../");
-			UniStrCat(cd, sizeof(cd), tmp + 2);
-		}
-		else
-		{
-			UniStrCat(cd, sizeof(cd), L"/");
-			UniStrCat(cd, sizeof(cd), tmp);
-		}
-
-		UniStrCpy(tmp, sizeof(tmp), cd);
-	}
-
-	// If the path starts with "~/", replace it with the home directory
-	if (UniStartWith(tmp, L"~/") || UniStartWith(tmp, L"~\\"))
-	{
-		wchar_t tmp2[MAX_SIZE];
-		GetHomeDirW(tmp2, sizeof(tmp2));
-		UniStrCat(tmp2, sizeof(tmp2), L"/");
-		UniStrCat(tmp2, sizeof(tmp2), tmp + 2);
-		UniStrCpy(tmp, sizeof(tmp), tmp2);
-	}
-
-	if (UniStartWith(tmp, L"//") || UniStartWith(tmp, L"\\\\"))
-	{
-        // Begin with "//" or "\\"
-		first_double_slash = true;
-		is_full_path = true;
-	}
-	else if (UniStartWith(tmp, L"/") || UniStartWith(tmp, L"\\"))
-	{
-		// Begin with "\"
-		first_single_slash = true;
-		is_full_path = true;
-	}
-
-#ifdef	OS_WIN32
-	if (UniStrLen(tmp) >= 2)
-	{
-		if (tmp[1] == L':')
-		{
-			// The drive string representation of the Win32
-			wchar_t tmp2[MAX_SIZE];
-			is_full_path = true;
-			win32_drive_char = tmp[0];
-			UniStrCpy(tmp2, sizeof(tmp2), tmp + 2);
-			UniStrCpy(tmp, sizeof(tmp), tmp2);
-		}
-	}
-#endif	// OS_WIN32
-
-	if (UniStrLen(tmp) == 1 && (tmp[0] == L'/' || tmp[0] == L'\\'))
-	{
-		tmp[0] = 0;
-	}
-
-	// Tokenize
-	t = UniParseToken(tmp, L"/\\");
-
-	sk = NewSk();
-
-	for (i = 0;i < t->NumTokens;i++)
-	{
-		wchar_t *s = t->Token[i];
-
-		if (UniStrCmpi(s, L".") == 0)
-		{
-			continue;
-		}
-		else if (UniStrCmpi(s, L"..") == 0)
-		{
-			if (sk->num_item >= 1 && (first_double_slash == false || sk->num_item >= 2))
-			{
-				Pop(sk);
-			}
-		}
-		else
-		{
-			Push(sk, s);
-		}
-	}
-
-	// Token concatenation
-	UniStrCpy(tmp, sizeof(tmp), L"");
-
-	if (first_double_slash)
-	{
-		UniStrCat(tmp, sizeof(tmp), L"//");
-	}
-	else if (first_single_slash)
-	{
-		UniStrCat(tmp, sizeof(tmp), L"/");
-	}
-
-#ifdef  OS_WIN32
-	if (win32_drive_char != 0)
-	{
-		wchar_t d[2];
-		d[0] = win32_drive_char;
-		d[1] = 0;
-		UniStrCat(tmp, sizeof(tmp), d);
-		UniStrCat(tmp, sizeof(tmp), L":/");
-	}
-#endif  // OS_WIN32
-
-	for (i = 0;i < sk->num_item;i++)
-	{
-		UniStrCat(tmp, sizeof(tmp), (wchar_t *)sk->p[i]);
-		if (i != (sk->num_item - 1))
-		{
-			UniStrCat(tmp, sizeof(tmp), L"/");
-		}
-	}
-
-	ReleaseSk(sk);
-
-	UniFreeToken(t);
-
-	ConvertPathW(tmp);
-
-	UniStrCpy(dst, size, tmp);
-}
-void NormalizePath(char *dst, UINT size, char *src)
-{
-	wchar_t dst_w[MAX_SIZE];
-	wchar_t *src_w = CopyStrToUni(src);
-
-	NormalizePathW(dst_w, sizeof(dst_w), src_w);
-
-	Free(src_w);
-
-	UniToStr(dst, size, dst_w);
-}
-
-// Rename the file
-bool FileRenameW(wchar_t *old_name, wchar_t *new_name)
-{
-	wchar_t tmp1[MAX_SIZE];
-	wchar_t tmp2[MAX_SIZE];
-	// Validate arguments
-	if (old_name == NULL || new_name == NULL)
-	{
-		return false;
-	}
-
-	InnerFilePathW(tmp1, sizeof(tmp1), old_name);
-	InnerFilePathW(tmp2, sizeof(tmp2), new_name);
-
-	return FileRenameInnerW(tmp1, tmp2);
-}
-bool FileRenameInnerW(wchar_t *old_name, wchar_t *new_name)
-{
-	// Validate arguments
-	if (old_name == NULL || new_name == NULL)
-	{
-		return false;
-	}
-
-	return OSFileRenameW(old_name, new_name);
-}
-
-// Convert the path
-void ConvertPathW(wchar_t *path)
-{
-	UINT i, len;
-#ifdef	PATH_BACKSLASH
-	wchar_t new_char = L'\\';
-#else
-	wchar_t new_char = L'/';
-#endif
-
-	len = UniStrLen(path);
-	for (i = 0;i < len;i++)
-	{
-		if (path[i] == L'\\' || path[i] == L'/')
-		{
-			path[i] = new_char;
-		}
-	}
-}
-
-// Delete the directory
-bool DeleteDir(char *name)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	bool ret = DeleteDirW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-bool DeleteDirW(wchar_t *name)
-{
-	wchar_t tmp[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	InnerFilePathW(tmp, sizeof(tmp), name);
-
-	return DeleteDirInnerW(tmp);
-}
-bool DeleteDirInnerW(wchar_t *name)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	return OSDeleteDirW(name);
-}
-
-// Generation of internal file path
-void InnerFilePathW(wchar_t *dst, UINT size, wchar_t *src)
-{
-	// Validate arguments
-	if (dst == NULL || src == NULL)
-	{
-		return;
-	}
-
-	if (src[0] == L'@')
-	{
-		wchar_t dir[MAX_SIZE];
-		GetLogDirW(dir, sizeof(dir));
-		ConbinePathW(dst, size, dir, &src[1]);
-	}
-	else if (src[0] == L'$')
-	{
-		wchar_t dir[MAX_SIZE];
-		GetDbDirW(dir, sizeof(dir));
-		ConbinePathW(dst, size, dir, &src[1]);
-	}
-	else
-	{
-		NormalizePathW(dst, size, src);
-	}
-}
-void InnerFilePath(char *dst, UINT size, char *src)
-{
-	wchar_t dst_w[MAX_PATH];
-	wchar_t *src_w = CopyStrToUni(src);
-
-	InnerFilePathW(dst_w, sizeof(dst_w), src_w);
-
-	Free(src_w);
-
-	UniToStr(dst, size, dst_w);
-}
-
-// Recursive directory creation
-bool MakeDirEx(char *name)
-{
-	bool ret;
-	wchar_t *name_w = CopyStrToUni(name);
-
-	ret = MakeDirExW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-bool MakeDirExW(wchar_t *name)
-{
-	LIST *o;
-	wchar_t tmp[MAX_PATH];
-	wchar_t tmp2[MAX_PATH];
-	UINT i;
-	bool ret = false;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	o = NewListFast(NULL);
-
-	UniStrCpy(tmp, sizeof(tmp), name);
-	while (true)
-	{
-		wchar_t *s = CopyUniStr(tmp);
-
-		Add(o, s);
-
-		GetDirNameFromFilePathW(tmp2, sizeof(tmp2), tmp);
-
-		if (UniStrCmpi(tmp2, tmp) == 0)
-		{
-			break;
-		}
-
-		UniStrCpy(tmp, sizeof(tmp), tmp2);
-	}
-
-	for (i = 0;i < LIST_NUM(o);i++)
-	{
-		UINT j = LIST_NUM(o) - i - 1;
-		wchar_t *s = LIST_DATA(o, j);
-
-		if (UniStrCmpi(s, L"\\") != 0 && UniStrCmpi(s, L"/") != 0)
-		{
-			ret = MakeDirW(s);
-		}
-	}
-
-	UniFreeStrList(o);
-
-	return ret;
-}
-
-// Create a directory
-bool MakeDir(char *name)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	bool ret = MakeDirW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-bool MakeDirW(wchar_t *name)
-{
-	wchar_t tmp[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	InnerFilePathW(tmp, sizeof(tmp), name);
-
-	return MakeDirInnerW(tmp);
-}
-bool MakeDirInnerW(wchar_t *name)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	return OSMakeDirW(name);
-}
-
-// Delete the file
-bool FileDelete(char *name)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	bool ret = FileDeleteW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-bool FileDeleteW(wchar_t *name)
-{
-	wchar_t tmp[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	InnerFilePathW(tmp, sizeof(tmp), name);
-
-	return FileDeleteInnerW(tmp);
-}
-bool FileDeleteInnerW(wchar_t *name)
-{
-	wchar_t name2[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	UniStrCpy(name2, sizeof(name2), name);
-	ConvertPathW(name2);
-
-	return OSFileDeleteW(name2);
-}
-
-// Seek the file
-bool FileSeek(IO *o, UINT mode, int offset)
-{
-	// Validate arguments
-	if (o == NULL)
-	{
-		return false;
-	}
-
-	if (o->HamMode == false)
-	{
-		return OSFileSeek(o->pData, mode, offset);
-	}
-	else
-	{
-		return false;
-	}
-}
-
-// Get the file size
-UINT64 FileSize64(IO *o)
-{
-	// Validate arguments
-	if (o == NULL)
-	{
-		return 0;
-	}
-
-	if (o->HamMode == false)
-	{
-		return OSFileSize(o->pData);
-	}
-	else
-	{
-		return (UINT64)o->HamBuf->Size;
-	}
-}
-UINT FileSize(IO *o)
-{
-	UINT64 size = (UINT)(FileSize64(o));
-
-	if (size >= 4294967296ULL)
-	{
-		size = 4294967295ULL;
-	}
-
-	return (UINT)size;
-}
-
-// Read from a file
-bool FileRead(IO *o, void *buf, UINT size)
-{
-	// Validate arguments
-	if (o == NULL || buf == NULL)
-	{
-		return false;
-	}
-
-	// KS
-	KS_INC(KS_IO_READ_COUNT);
-	KS_ADD(KS_IO_TOTAL_READ_SIZE, size);
-
-	if (size == 0)
-	{
-		return true;
-	}
-
-	if (o->HamMode == false)
-	{
-		return OSFileRead(o->pData, buf, size);
-	}
-	else
-	{
-		return ReadBuf(o->HamBuf, buf, size) == size ? true : false;
-	}
-}
-
-// Write to a file
-bool FileWrite(IO *o, void *buf, UINT size)
-{
-	// Validate arguments
-	if (o == NULL || buf == NULL)
-	{
-		return false;
-	}
-	if (o->WriteMode == false)
-	{
-		return false;
-	}
-
-	// KS
-	KS_INC(KS_IO_WRITE_COUNT);
-	KS_ADD(KS_IO_TOTAL_WRITE_SIZE, size);
-
-	if (size == 0)
-	{
-		return true;
-	}
-
-	return OSFileWrite(o->pData, buf, size);
-}
-
-// Flush the file
-void FileFlush(IO *o)
-{
-	// Validate arguments
-	if (o == NULL)
-	{
-		return;
-	}
-
-	if (o->HamMode)
-	{
-		return;
-	}
-
-	OSFileFlush(o->pData);
-}
-
-// Close the file
-void FileClose(IO *o)
-{
-	FileCloseEx(o, false);
-}
-void FileCloseEx(IO *o, bool no_flush)
-{
-	// Validate arguments
-	if (o == NULL)
-	{
-		return;
-	}
-
-	if (o->HamMode == false)
-	{
-		if (o->WriteMode)
-		{
-#ifdef	OS_WIN32
-			Win32FileSetDate(o->pData, o->SetCreateTime, o->SetUpdateTime);
-#endif	// OS_WIN32
-		}
-
-		OSFileClose(o->pData, no_flush);
-	}
-	else
-	{
-		FreeBuf(o->HamBuf);
-	}
-	Free(o);
-
-	// KS
-	KS_INC(KS_IO_CLOSE_COUNT);
-}
-
-// Create a file
-IO *FileCreateInnerW(wchar_t *name)
-{
-	IO *o;
-	void *p;
-	wchar_t name2[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return NULL;
-	}
-
-	UniStrCpy(name2, sizeof(name2), name);
-	ConvertPathW(name2);
-
-	p = OSFileCreateW(name2);
-	if (p == NULL)
-	{
-		return NULL;
-	}
-
-	o = ZeroMalloc(sizeof(IO));
-	o->pData = p;
-	UniStrCpy(o->NameW, sizeof(o->NameW), name2);
-	UniToStr(o->Name, sizeof(o->Name), o->NameW);
-	o->WriteMode = true;
-
-	// KS
-	KS_INC(KS_IO_CREATE_COUNT);
-
-	return o;
-}
-IO *FileCreate(char *name)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	IO *ret = FileCreateW(name_w);
-
-	Free(name_w);
-
-	return ret;
-}
-IO *FileCreateW(wchar_t *name)
-{
-	wchar_t tmp[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return NULL;
-	}
-
-	InnerFilePathW(tmp, sizeof(tmp), name);
-
-	return FileCreateInnerW(tmp);
-}
-
-// Write all the data to the file
-bool FileWriteAllW(wchar_t *name, void *data, UINT size)
-{
-	IO *io;
-	// Validate arguments
-	if (name == NULL || (data == NULL && size != 0))
-	{
-		return false;
-	}
-
-	io = FileCreateW(name);
-
-	if (io == NULL)
-	{
-		return false;
-	}
-
-	FileWrite(io, data, size);
-
-	FileClose(io);
-
-	return true;
-}
-
-// Open the file
-IO *FileOpenInnerW(wchar_t *name, bool write_mode, bool read_lock)
-{
-	IO *o;
-	void *p;
-	wchar_t name2[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return NULL;
-	}
-
-	UniStrCpy(name2, sizeof(name2), name);
-	ConvertPathW(name2);
-
-	p = OSFileOpenW(name2, write_mode, read_lock);
-	if (p == NULL)
-	{
-		return NULL;
-	}
-
-	o = ZeroMalloc(sizeof(IO));
-	o->pData = p;
-	UniStrCpy(o->NameW, sizeof(o->NameW), name2);
-	UniToStr(o->Name, sizeof(o->Name), o->NameW);
-	o->WriteMode = write_mode;
-
-#ifdef	OS_WIN32
-	Win32FileGetDate(p, &o->GetCreateTime, &o->GetUpdateTime, &o->GetAccessTime);
-#endif	// OS_WIN32
-
-	// KS
-	KS_INC(KS_IO_OPEN_COUNT);
-
-	return o;
-}
-IO *FileOpen(char *name, bool write_mode)
-{
-	return FileOpenEx(name, write_mode, true);
-}
-IO *FileOpenW(wchar_t *name, bool write_mode)
-{
-	return FileOpenExW(name, write_mode, true);
-}
-IO *FileOpenEx(char *name, bool write_mode, bool read_lock)
-{
-	wchar_t *name_w = CopyStrToUni(name);
-	IO *ret = FileOpenExW(name_w, write_mode, read_lock);
-
-	Free(name_w);
-
-	return ret;
-}
-
-// Replace the specified character in the string with a new character
-wchar_t *UniReplaceCharW(wchar_t *src, UINT size, wchar_t c, wchar_t  newc) {
-	if (src == NULL)
-	{
-		return NULL;
-	}
-	for (; *src; src++, size -= sizeof(wchar_t)) {
-		if (size < sizeof(wchar_t)) {
-			break;
-		}
-		if (*src == c) {
-			*src = newc;
-		}
-	}
-	return (wchar_t *)src;
-}
-
-IO *FileOpenExW(wchar_t *name, bool write_mode, bool read_lock)
-{
-	wchar_t tmp[MAX_SIZE];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return NULL;
-	}
-
-	InnerFilePathW(tmp, sizeof(tmp), name);
-
-	if (name[0] == L'|')
-	{
-		IO *o = ZeroMalloc(sizeof(IO));
-		name++;
-		UniStrCpy(o->NameW, sizeof(o->NameW), name);
-#ifdef	OS_WIN32
-		UniReplaceCharW(o->NameW, sizeof(o->NameW), L'\\', L'/');		// Path separator "/" is used.
-#endif	// OS_WIN32
-		UniToStr(o->Name, sizeof(o->Name), o->NameW);
-		o->HamMode = true;
-		o->HamBuf = ReadHamcoreW(o->NameW);
-		if (o->HamBuf == NULL)
-		{
-			Free(o);
-			return NULL;
-		}
-		return o;
-	}
-	else
-	{
-		return FileOpenInnerW(tmp, write_mode, read_lock);
-	}
-}
-
-
+// SoftEther VPN Source Code - Developer Edition Master Branch
+// Mayaqua Kernel
+
+
+// FileIO.c
+// File Input / Output code
+
+#include "FileIO.h"
+
+#include "Cfg.h"
+#include "GlobalConst.h"
+#include "Internat.h"
+#include "Memory.h"
+#include "Microsoft.h"
+#include "Str.h"
+#include "Tick64.h"
+#include "Tracking.h"
+#include "Unix.h"
+#include "Win32.h"
+
+#include <Hamcore.h>
+#ifdef __ANDROID__
+#include <androidhelpers.h>
+#endif
+
+static char exe_file_name[MAX_SIZE] = "/tmp/a.out";
+static wchar_t exe_file_name_w[MAX_SIZE] = L"/tmp/a.out";
+static LIST *hamcore = NULL;
+static HAMCORE *hamcore_io = NULL;
+
+#define	NUM_CRC32_TABLE	256
+static UINT crc32_table[NUM_CRC32_TABLE];
+
+// Confirm that the specified string exists as a line
+bool IsInLines(BUF *buf, char *str, bool instr)
+{
+	bool ret = false;
+	// Validate arguments
+	if (buf == NULL || str == NULL)
+	{
+		return false;
+	}
+
+	if (IsEmptyStr(str))
+	{
+		return false;
+	}
+
+	SeekBufToBegin(buf);
+
+	while (ret == false)
+	{
+		char *line = CfgReadNextLine(buf);
+
+		if (line == NULL)
+		{
+			break;
+		}
+
+		Trim(line);
+
+		if (IsEmptyStr(line) == false)
+		{
+			if (StrCmpi(line, str) == 0)
+			{
+				ret = true;
+			}
+
+			if (instr)
+			{
+				if (InStr(str, line))
+				{
+					ret = true;
+				}
+
+				if (InStr(line, str))
+				{
+					ret = true;
+				}
+			}
+		}
+
+		Free(line);
+	}
+
+	return ret;
+}
+bool IsInLinesFile(wchar_t *filename, char *str, bool instr)
+{
+	bool ret = false;
+	BUF *b;
+	// Validate arguments
+	if (filename == NULL || str == NULL)
+	{
+		return false;
+	}
+
+	b = ReadDumpW(filename);
+	if (b == NULL)
+	{
+		return false;
+	}
+
+	ret = IsInLines(b, str, instr);
+
+	FreeBuf(b);
+
+	return ret;
+}
+
+// Check whether the file is write-locked
+bool IsFileWriteLockedW(wchar_t *name)
+{
+	IO *io;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	if (IsFileExistsW(name) == false)
+	{
+		return false;
+	}
+
+	io = FileOpenW(name, true);
+	if (io == NULL)
+	{
+		return true;
+	}
+
+	FileClose(io);
+
+	return false;
+}
+
+// Creating a ZIP packer
+ZIP_PACKER *NewZipPacker()
+{
+	ZIP_PACKER *p = ZeroMalloc(sizeof(ZIP_PACKER));
+
+	p->Fifo = NewFifo();
+	p->FileList = NewList(NULL);
+	p->CurrentFile = NULL;
+
+	return p;
+}
+
+// Release of ZIP packer
+void FreeZipPacker(ZIP_PACKER *p)
+{
+	UINT i;
+	// Validate arguments
+	if (p == NULL)
+	{
+		return;
+	}
+
+	ReleaseFifo(p->Fifo);
+
+	for (i = 0;i < LIST_NUM(p->FileList);i++)
+	{
+		ZIP_FILE *f = LIST_DATA(p->FileList, i);
+
+		Free(f);
+	}
+
+	ReleaseList(p->FileList);
+
+	Free(p);
+}
+
+// Simply add the file
+void ZipAddFileSimple(ZIP_PACKER *p, char *name, UINT64 dt, UINT attribute, void *data, UINT size)
+{
+	// Validate arguments
+	if (p == NULL || IsEmptyStr(name) || (size != 0 && data == NULL))
+	{
+		return;
+	}
+
+	ZipAddFileStart(p, name, size, dt, attribute);
+	ZipAddFileData(p, data, 0, size);
+}
+bool ZipAddRealFileW(ZIP_PACKER *p, char *name, UINT64 dt, UINT attribute, wchar_t *srcname)
+{
+	BUF *b;
+	// Validate arguments
+	if (p == NULL || IsEmptyStr(name) || srcname == NULL)
+	{
+		return false;
+	}
+
+	b = ReadDumpW(srcname);
+	if (b == NULL)
+	{
+		return false;
+	}
+
+	ZipAddFileSimple(p, name, dt, attribute, b->Buf, b->Size);
+
+	FreeBuf(b);
+
+	return true;
+}
+bool ZipAddRealFile(ZIP_PACKER *p, char *name, UINT64 dt, UINT attribute, char *srcname)
+{
+	bool ret = false;
+	wchar_t *s;
+
+	s = CopyStrToUni(srcname);
+
+	ret = ZipAddRealFileW(p, name, dt, attribute, s);
+
+	Free(s);
+
+	return ret;
+}
+
+// Start adding a file
+void ZipAddFileStart(ZIP_PACKER *p, char *name, UINT size, UINT64 dt, UINT attribute)
+{
+	char tmp[MAX_PATH];
+	ZIP_FILE *f;
+	ZIP_DATA_HEADER h;
+	// Validate arguments
+	if (p == NULL || IsEmptyStr(name))
+	{
+		return;
+	}
+	if (dt == 0)
+	{
+		dt = LocalTime64();
+	}
+
+	if (p->CurrentFile != NULL)
+	{
+		return;
+	}
+
+	StrCpy(tmp, sizeof(tmp), name);
+	ReplaceStrEx(tmp, sizeof(tmp), tmp, "/", "\\", true);
+
+	f = ZeroMalloc(sizeof(ZIP_FILE));
+
+	StrCpy(f->Name, sizeof(f->Name), tmp);
+	f->Size = size;
+	f->DateTime = dt;
+	f->Attributes = attribute;
+
+	Add(p->FileList, f);
+
+	Zero(&h, sizeof(h));
+	f->HeaderPos = (UINT)p->Fifo->total_write_size;
+	WriteZipDataHeader(f, &h, false);
+	WriteFifo(p->Fifo, &h, sizeof(h));
+	WriteFifo(p->Fifo, f->Name, StrLen(f->Name));
+	f->Crc32 = 0xffffffff;
+
+	p->CurrentFile = f;
+}
+
+// Add data to the file
+UINT ZipAddFileData(ZIP_PACKER *p, void *data, UINT pos, UINT len)
+{
+	UINT ret;
+	UINT total_size;
+	// Validate arguments
+	if (p == NULL)
+	{
+		return 0;
+	}
+
+	total_size = p->CurrentFile->CurrentSize + len;
+
+	if (total_size > p->CurrentFile->Size)
+	{
+		return 0;
+	}
+
+	WriteFifo(p->Fifo, ((UCHAR *)data) + pos, len);
+
+	p->CurrentFile->CurrentSize += len;
+	p->CurrentFile->Crc32 = Crc32Next(data, pos, len, p->CurrentFile->Crc32);
+
+	ret = p->CurrentFile->Size - p->CurrentFile->CurrentSize;
+
+	if (ret == 0)
+	{
+		p->CurrentFile->Crc32 = ~p->CurrentFile->Crc32;
+
+		ZipAddFileFooter(p);
+
+		p->CurrentFile = NULL;
+	}
+
+	return ret;
+}
+
+// Append a file footer
+void ZipAddFileFooter(ZIP_PACKER *p)
+{
+	ZIP_DATA_FOOTER f;
+	// Validate arguments
+	if (p == NULL)
+	{
+		return;
+	}
+
+	Zero(&f, sizeof(f));
+	WriteZipDataFooter(p->CurrentFile, &f);
+
+	WriteFifo(p->Fifo, &f, sizeof(f));
+}
+
+// Output the ZIP data to a file
+bool ZipWriteW(ZIP_PACKER *p, wchar_t *name)
+{
+	FIFO *f;
+	// Validate arguments
+	if (p == NULL || name == NULL)
+	{
+		return false;
+	}
+
+	f = ZipFinish(p);
+	if (f == NULL)
+	{
+		return false;
+	}
+
+	return FileWriteAllW(name, FifoPtr(f), FifoSize(f));
+}
+
+// Complete the creation of the ZIP data
+FIFO *ZipFinish(ZIP_PACKER *p)
+{
+	UINT i;
+	UINT pos_start;
+	UINT pos_end;
+	ZIP_END_HEADER e;
+	// Validate arguments
+	if (p == NULL)
+	{
+		return NULL;
+	}
+
+	pos_start = (UINT)p->Fifo->total_write_size;
+
+	for (i = 0;i < LIST_NUM(p->FileList);i++)
+	{
+		ZIP_FILE *f = LIST_DATA(p->FileList, i);
+		ZIP_DIR_HEADER d;
+		ZIP_DATA_HEADER dh;
+
+		Zero(&d, sizeof(d));
+		Zero(&dh, sizeof(dh));
+
+		d.Signature = Endian32(Swap32(0x02014B50));
+		d.MadeVer = Endian16(Swap16(ZIP_VERSION));
+
+		WriteZipDataHeader(f, &dh, true);
+
+		d.NeedVer = dh.NeedVer;
+		d.Option = dh.Option;
+		d.CompType = dh.CompType;
+		d.FileTime = dh.FileTime;
+		d.FileDate = dh.FileDate;
+		d.Crc32 = dh.Crc32;
+		d.CompSize = dh.CompSize;
+		d.UncompSize = dh.UncompSize;
+		d.FileNameLen = dh.FileNameLen;
+		d.ExtraLen = dh.ExtraLen;
+		d.CommentLen = 0;
+		d.DiskNum = 0;
+		d.InAttr = 0;
+		d.OutAttr = Endian32(Swap32((USHORT)f->Attributes));
+		d.HeaderPos = Endian32(Swap32(f->HeaderPos));
+
+		WriteFifo(p->Fifo, &d, sizeof(d));
+		WriteFifo(p->Fifo, f->Name, StrLen(f->Name));
+	}
+
+	pos_end = (UINT)p->Fifo->total_write_size;
+
+	Zero(&e, sizeof(e));
+	e.Signature = Endian32(Swap32(ZIP_SIGNATURE_END));
+	e.DiskNum = e.StartDiskNum = 0;
+	e.DiskDirEntry = e.DirEntry = Endian16(Swap16((USHORT)LIST_NUM(p->FileList)));
+	e.DirSize = Endian32(Swap32((UINT)(pos_end - pos_start)));
+	e.StartPos = Endian32(Swap32(pos_start));
+	e.CommentLen = 0;
+
+	WriteFifo(p->Fifo, &e, sizeof(e));
+
+	return p->Fifo;
+}
+
+// Creating a ZIP data header
+void WriteZipDataHeader(ZIP_FILE *f, ZIP_DATA_HEADER *h, bool write_sizes)
+{
+	// Validate arguments
+	if (f == NULL || h ==NULL)
+	{
+		return;
+	}
+
+	h->Signature = Endian32(Swap32(ZIP_SIGNATURE));
+	h->NeedVer = Endian16(Swap16(ZIP_VERSION));
+	h->CompType = 0;
+	h->FileDate = Endian16(Swap16(System64ToDosDate(f->DateTime)));
+	h->FileTime = Endian16(Swap16(System64ToDosTime(f->DateTime)));
+	h->Option = Endian16(Swap16(8)); // bit3: Set the file-size and the CRC in local header to 0
+
+	if (write_sizes == false)
+	{
+		h->CompSize = h->UncompSize = 0;
+		h->Crc32 = 0;
+	}
+	else
+	{
+		h->CompSize = h->UncompSize = Endian32(Swap32(f->Size));
+		h->Crc32 = Endian32(Swap32(f->Crc32));
+	}
+
+	h->FileNameLen = Endian16(Swap16(StrLen(f->Name)));
+	h->ExtraLen = 0;
+}
+
+// Creating a ZIP data footer
+void WriteZipDataFooter(ZIP_FILE *f, ZIP_DATA_FOOTER *h)
+{
+	// Validate arguments
+	if (f == NULL || h ==NULL)
+	{
+		return;
+	}
+
+	h->Signature = Endian32(Swap32(0x08074B50));
+	h->CompSize = h->UncompSize = Endian32(Swap32(f->Size));
+	h->Crc32 = Endian32(Swap32(f->Crc32));
+}
+
+// Initialize the common table of CRC32
+void InitCrc32()
+{
+	UINT poly = 0xEDB88320;
+	UINT u, i, j;
+
+	for (i = 0;i < 256;i++)
+	{
+		u = i;
+
+		for (j = 0;j < 8;j++)
+		{
+			if ((u & 0x1) != 0)
+			{
+				u = (u >> 1) ^ poly;
+			}
+			else
+			{
+				u >>= 1;
+			}
+		}
+
+		crc32_table[i] = u;
+	}
+}
+
+// CRC32 arithmetic processing
+UINT Crc32(void *buf, UINT pos, UINT len)
+{
+	return Crc32Finish(Crc32First(buf, pos, len));
+}
+UINT Crc32First(void *buf, UINT pos, UINT len)
+{
+	return Crc32Next(buf, pos, len, 0xffffffff);
+}
+UINT Crc32Next(void *buf, UINT pos, UINT len, UINT last_crc32)
+{
+	UINT ret = last_crc32;
+	UINT i;
+
+	for (i = 0;i < len;i++)
+	{
+		ret = (ret >> 8) ^ crc32_table[((UCHAR *)buf)[pos + i] ^ (ret & 0xff)];
+	}
+
+	return ret;
+}
+UINT Crc32Finish(UINT last_crc32)
+{
+	return ~last_crc32;
+}
+
+// Save the file
+bool SaveFileW(wchar_t *name, void *data, UINT size)
+{
+	IO *io;
+	// Validate arguments
+	if (name == NULL || (data == NULL && size != 0))
+	{
+		return false;
+	}
+
+	io = FileCreateW(name);
+	if (io == NULL)
+	{
+		return false;
+	}
+
+	if (FileWrite(io, data, size) == false)
+	{
+		FileClose(io);
+		return false;
+	}
+
+	FileClose(io);
+
+	return true;
+}
+bool SaveFile(char *name, void *data, UINT size)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	bool ret = SaveFileW(name_w, data, size);
+
+	Free(name_w);
+
+	return ret;
+}
+
+// Check whether the file exists
+bool IsFile(char *name)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	bool ret = IsFileW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+bool IsFileW(wchar_t *name)
+{
+	IO *io;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	io = FileOpenExW(name, false, false);
+	if (io == NULL)
+	{
+		return false;
+	}
+
+	FileClose(io);
+
+	return true;
+}
+
+// Make the file name safe
+void ConvertSafeFileName(char *dst, UINT size, char *src)
+{
+	UINT i;
+	// Validate arguments
+	if (dst == NULL || src == NULL)
+	{
+		return;
+	}
+
+	StrCpy(dst, size, src);
+	for (i = 0;i < StrLen(dst);i++)
+	{
+		if (IsSafeChar(dst[i]) == false)
+		{
+			dst[i] = '_';
+		}
+	}
+}
+
+// Get the free disk space
+bool GetDiskFree(char *path, UINT64 *free_size, UINT64 *used_size, UINT64 *total_size)
+{
+	bool ret;
+	// Validate arguments
+	if (path == NULL)
+	{
+		path = "./";
+	}
+
+#ifdef	OS_WIN32
+	ret = Win32GetDiskFree(path, free_size, used_size, total_size);
+#else	// OS_WIN32
+	ret = UnixGetDiskFree(path, free_size, used_size, total_size);
+#endif	// OS_WIN32
+
+	return ret;
+}
+
+// Enumeration of directory
+DIRLIST *EnumDirEx(char *dirname, COMPARE *compare)
+{
+	wchar_t *dirname_w = CopyStrToUni(dirname);
+	DIRLIST *ret = EnumDirExW(dirname_w, compare);
+
+	Free(dirname_w);
+
+	return ret;
+}
+DIRLIST *EnumDirExW(wchar_t *dirname, COMPARE *compare)
+{
+	DIRLIST *d = NULL;
+	// Validate arguments
+	if (dirname == NULL)
+	{
+		dirname = L"./";
+	}
+
+	if (compare == NULL)
+	{
+		compare = CompareDirListByName;
+	}
+
+#ifdef	OS_WIN32
+	d = Win32EnumDirExW(dirname, compare);
+#else	// OS_WIN32
+	d = UnixEnumDirExW(dirname, compare);
+#endif	// OS_WIN32
+
+	return d;
+}
+DIRLIST *EnumDir(char *dirname)
+{
+	return EnumDirEx(dirname, NULL);
+}
+DIRLIST *EnumDirW(wchar_t *dirname)
+{
+	return EnumDirExW(dirname, NULL);
+}
+
+// Comparison of DIRLIST list entry
+int CompareDirListByName(void *p1, void *p2)
+{
+	DIRENT *d1, *d2;
+	if (p1 == NULL || p2 == NULL)
+	{
+		return 0;
+	}
+	d1 = *(DIRENT **)p1;
+	d2 = *(DIRENT **)p2;
+	if (d1 == NULL || d2 == NULL)
+	{
+		return 0;
+	}
+	return UniStrCmpi(d1->FileNameW, d2->FileNameW);
+}
+
+// Release the enumeration of the directory
+void FreeDir(DIRLIST *d)
+{
+	UINT i;
+	// Validate arguments
+	if (d == NULL)
+	{
+		return;
+	}
+
+	for (i = 0;i < d->NumFiles;i++)
+	{
+		DIRENT *f = d->File[i];
+		Free(f->FileName);
+		Free(f->FileNameW);
+		Free(f);
+	}
+	Free(d->File);
+	Free(d);
+}
+
+
+// Make the file name safe
+void UniSafeFileName(wchar_t *name)
+{
+	UINT i, len, dlen;
+	static wchar_t *danger_str = L"\\/:*?\"<>|";
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	dlen = UniStrLen(danger_str);
+	len = UniStrLen(name);
+
+	for (i = 0;i < len;i++)
+	{
+		wchar_t c = name[i];
+		UINT j;
+		for (j = 0;j < dlen;j++)
+		{
+			if (c == danger_str[j])
+			{
+				c = L'_';
+			}
+		}
+		name[i] = c;
+	}
+}
+
+// Read HamCore file
+BUF *ReadHamcoreW(wchar_t *filename)
+{
+	char *filename_a = CopyUniToStr(filename);
+	BUF *ret;
+
+	ret = ReadHamcore(filename_a);
+
+	Free(filename_a);
+
+	return ret;
+}
+BUF *ReadHamcore(char *name)
+{
+	if (name == NULL || MayaquaIsMinimalMode())
+	{
+		return NULL;
+	}
+
+	if (name[0] == '/')
+	{
+		++name;
+	}
+
+	char path[MAX_PATH];
+	GetExeDir(path, sizeof(path));
+	Format(path, sizeof(path), "%s/%s/%s", path, HAMCORE_DIR_NAME, name);
+
+	BUF *buf = ReadDump(path);
+	if (buf != NULL)
+	{
+		return buf;
+	}
+
+	LockList(hamcore);
+	{
+		HC t = {0};
+		t.Path = name;
+		HC *c = Search(hamcore, &t);
+		if (c == NULL)
+		{
+			const HAMCORE_FILE *file = HamcoreFind(hamcore_io, name);
+			if (file)
+			{
+				c = Malloc(sizeof(HC));
+				c->Size = file->OriginalSize;
+				c->Path = CopyStr(name);
+				c->Buffer = Malloc(c->Size);
+
+				if (HamcoreRead(hamcore_io, c->Buffer, file))
+				{
+					Add(hamcore, c);
+				}
+				else
+				{
+					Free(c->Buffer);
+					Free(c->Path);
+					Free(c);
+
+					c = NULL;
+				}
+			}
+		}
+
+		if (c != NULL)
+		{
+			buf = NewBuf();
+			WriteBuf(buf, c->Buffer, c->Size);
+			SeekBuf(buf, 0, 0);
+			c->LastAccess = Tick64();
+		}
+
+		LIST *to_delete = NewListFast(NULL);
+
+		for (UINT i = 0; i < LIST_NUM(hamcore); ++i)
+		{
+			HC *c = LIST_DATA(hamcore, i);
+			if (c->LastAccess + HAMCORE_CACHE_EXPIRES <= Tick64())
+			{
+				Add(to_delete, c);
+			}
+		}
+
+		for (UINT i = 0; i < LIST_NUM(to_delete); ++i)
+		{
+			HC *c = LIST_DATA(to_delete, i);
+
+			Delete(hamcore, c);
+
+			Free(c->Buffer);
+			Free(c->Path);
+			Free(c);
+		}
+
+		ReleaseList(to_delete);
+	}
+	UnlockList(hamcore);
+
+	return buf;
+}
+
+// Initialization of HamCore file system
+void InitHamcore()
+{
+	if (MayaquaIsMinimalMode())
+	{
+		return;
+	}
+
+	hamcore = NewList(CompareHamcore);
+#ifdef HAMCORE_FILE_PATH
+	hamcore_io = HamcoreOpen(HAMCORE_FILE_PATH);
+	if (hamcore_io != NULL)
+	{
+		Debug("InitHamcore(): Loaded from \"%s\".\n", HAMCORE_FILE_PATH);
+		return;
+	}
+#endif
+	char path[MAX_PATH];
+	GetExeDir(path, sizeof(path));
+	Format(path, sizeof(path), "%s/%s", path, HAMCORE_FILE_NAME);
+
+	hamcore_io = HamcoreOpen(path);
+	if (hamcore_io != NULL)
+	{
+		Debug("InitHamcore(): Loaded from \"%s\".\n", path);
+	}
+}
+
+// Release of HamCore file system
+void FreeHamcore()
+{
+	for (UINT i = 0; i < LIST_NUM(hamcore); ++i)
+	{
+		HC *c = LIST_DATA(hamcore, i);
+
+		Free(c->Buffer);
+		Free(c->Path);
+		Free(c);
+	}
+	ReleaseList(hamcore);
+
+	HamcoreClose(hamcore_io);
+	hamcore_io = NULL;
+	hamcore = NULL;
+}
+
+// Comparison of the HCs
+int CompareHamcore(void *p1, void *p2)
+{
+	HC *c1, *c2;
+	if (p1 == NULL || p2 == NULL)
+	{
+		return 0;
+	}
+	c1 = *(HC **)p1;
+	c2 = *(HC **)p2;
+	if (c1 == NULL || c2 == NULL)
+	{
+		return 0;
+	}
+	return StrCmpi(c1->Path, c2->Path);
+}
+
+// Getting the name of the directory where the EXE file is in
+void GetExeDir(char *name, UINT size)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+	#ifdef __ANDROID__
+	char* tmp = GetAndroidTmpDir();
+	StrCpy(name, size, tmp);
+	free(tmp);
+	return;
+    #endif
+
+	GetDirNameFromFilePath(name, size, exe_file_name);
+}
+void GetExeDirW(wchar_t *name, UINT size)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	GetDirNameFromFilePathW(name, size, exe_file_name_w);
+}
+
+// Get the EXE file name
+void GetExeName(char *name, UINT size)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	StrCpy(name, size, exe_file_name);
+}
+void GetExeNameW(wchar_t *name, UINT size)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	UniStrCpy(name, size, exe_file_name_w);
+}
+
+void GetLogDir(char *name, UINT size)
+{
+#ifdef SE_LOGDIR
+	Format(name, size, SE_LOGDIR);
+#elif __ANDROID__
+	 char* tmp = GetAndroidLogDir();
+	 StrCpy(name, size, tmp);
+	 free(tmp);
+	 return;
+#else
+	GetExeDir(name, size);
+#endif
+}
+
+void GetLogDirW(wchar_t *name, UINT size)
+{
+#ifdef SE_LOGDIR
+	UniFormat(name, size, L""SE_LOGDIR);
+#else
+	GetExeDirW(name, size);
+#endif
+}
+
+void GetDbDir(char *name, UINT size)
+{
+#ifdef SE_DBDIR
+	Format(name, size, SE_DBDIR);
+#elif __ANDROID__
+	  char* tmp = GetAndroidDbDir();
+	  StrCpy(name, size, tmp);
+	  free(tmp);
+	  return;
+#else
+	GetExeDir(name, size);
+#endif
+}
+
+void GetDbDirW(wchar_t *name, UINT size)
+{
+#ifdef SE_DBDIR
+	UniFormat(name, size, L""SE_DBDIR);
+#else
+	GetExeDirW(name, size);
+#endif
+}
+
+void GetPidDir(char *name, UINT size)
+{
+#ifdef SE_PIDDIR
+	Format(name, size, SE_PIDDIR);
+#elif __ANDROID__
+    char* tmp = GetAndroidTmpDir();
+    StrCpy(name, size, tmp);
+	free(tmp);
+	return;
+#else
+	GetExeDir(name, size);
+#endif
+}
+
+void GetPidDirW(wchar_t *name, UINT size)
+{
+#ifdef SE_PIDDIR
+	UniFormat(name, size, L""SE_PIDDIR);
+#else
+	GetExeDirW(name, size);
+#endif
+}
+
+// Initialization of the acquisition of the EXE file name
+void InitGetExeName(char *arg)
+{
+	wchar_t *arg_w = NULL;
+	// Validate arguments
+	if (arg == NULL)
+	{
+		arg = "./a.out";
+	}
+
+	arg_w = CopyUtfToUni(arg);
+
+#ifdef	OS_WIN32
+	Win32GetExeNameW(exe_file_name_w, sizeof(exe_file_name_w));
+#else	// OS_WIN32
+	UnixGetExeNameW(exe_file_name_w, sizeof(exe_file_name_w), arg_w);
+#endif	// OS_WIN32
+
+	UniToStr(exe_file_name, sizeof(exe_file_name), exe_file_name_w);
+
+	Free(arg_w);
+}
+
+// Get the full path of the executable binary file in Unix
+void UnixGetExeNameW(wchar_t *name, UINT size, wchar_t *arg)
+{
+	UNI_TOKEN_LIST *t;
+	char *path_str;
+	wchar_t *path_str_w;
+	bool ok = false;
+	// Validate arguments
+	if (name == NULL || arg == NULL)
+	{
+		return;
+	}
+
+	path_str = GetCurrentPathEnvStr();
+	path_str_w = CopyUtfToUni(path_str);
+
+	t = ParseSplitedPathW(path_str_w);
+
+	if (t != NULL)
+	{
+		UINT i;
+		for (i = 0;i < t->NumTokens;i++)
+		{
+			wchar_t *s = t->Token[i];
+			wchar_t tmp[MAX_SIZE];
+
+			ConbinePathW(tmp, sizeof(tmp), s, arg);
+
+			if (IsFileExistsInnerW(tmp))
+			{
+#ifdef	OS_UNIX
+				if (UnixCheckExecAccessW(tmp) == false)
+				{
+					continue;
+				}
+#endif	// OS_UNIX
+				ok = true;
+				UniStrCpy(name, size, tmp);
+				break;
+			}
+		}
+
+		UniFreeToken(t);
+	}
+
+	Free(path_str);
+	Free(path_str_w);
+
+	if (ok == false)
+	{
+		// In the case of failing to find the path
+#ifdef	OS_UNIX
+		UnixGetCurrentDirW(name, size);
+#else	// OS_UNIX
+		Win32GetCurrentDirW(name, size);
+#endif	// OS_UNIX
+		ConbinePathW(name, size, name, arg);
+	}
+}
+
+// Generate a secure file name
+void MakeSafeFileName(char *dst, UINT size, char *src)
+{
+	char tmp[MAX_PATH];
+	// Validate arguments
+	if (dst == NULL || src == NULL)
+	{
+		return;
+	}
+
+	StrCpy(tmp, sizeof(tmp), src);
+	ReplaceStrEx(tmp, sizeof(tmp), tmp, "..", "__", false);
+	ReplaceStrEx(tmp, sizeof(tmp), tmp, "/", "_", false);
+	ReplaceStrEx(tmp, sizeof(tmp), tmp, "\\", "_", false);
+	ReplaceStrEx(tmp, sizeof(tmp), tmp, "@", "_", false);
+	ReplaceStrEx(tmp, sizeof(tmp), tmp, "|", "_", false);
+
+	StrCpy(dst, size, tmp);
+}
+
+// Get the file name from the file path
+void GetFileNameFromFilePathW(wchar_t *dst, UINT size, wchar_t *filepath)
+{
+	wchar_t tmp[MAX_SIZE];
+	UINT i, len, wp;
+	// Validate arguments
+	if (dst == NULL || filepath == NULL)
+	{
+		return;
+	}
+
+	len = MIN(UniStrLen(filepath), (MAX_SIZE - 2));
+	wp = 0;
+
+	for (i = 0;i < (len + 1);i++)
+	{
+		wchar_t c = filepath[i];
+
+		switch (c)
+		{
+		case L'\\':
+		case L'/':
+		case 0:
+			tmp[wp] = 0;
+			wp = 0;
+			break;
+
+		default:
+			tmp[wp] = c;
+			wp++;
+			break;
+		}
+	}
+
+	UniStrCpy(dst, size, tmp);
+}
+void GetFileNameFromFilePath(char *dst, UINT size, char *filepath)
+{
+	char tmp[MAX_SIZE];
+	UINT i, len, wp;
+	// Validate arguments
+	if (dst == NULL || filepath == NULL)
+	{
+		return;
+	}
+
+	len = MIN(StrLen(filepath), (MAX_SIZE - 2));
+	wp = 0;
+
+	for (i = 0;i < (len + 1);i++)
+	{
+		char c = filepath[i];
+
+		switch (c)
+		{
+		case '\\':
+		case '/':
+		case 0:
+			tmp[wp] = 0;
+			wp = 0;
+			break;
+
+		default:
+			tmp[wp] = c;
+			wp++;
+			break;
+		}
+	}
+
+	StrCpy(dst, size, tmp);
+}
+void GetDirNameFromFilePathW(wchar_t *dst, UINT size, wchar_t *filepath)
+{
+	wchar_t tmp[MAX_SIZE];
+	UINT wp;
+	UINT i;
+	UINT len;
+	// Validate arguments
+	if (dst == NULL || filepath == NULL)
+	{
+		return;
+	}
+
+	UniStrCpy(tmp, sizeof(tmp), filepath);
+	if (UniEndWith(tmp, L"\\") || UniEndWith(tmp, L"/"))
+	{
+		tmp[UniStrLen(tmp) - 1] = 0;
+	}
+
+	len = UniStrLen(tmp);
+
+	UniStrCpy(dst, size, L"");
+
+	wp = 0;
+
+	for (i = 0;i < len;i++)
+	{
+		wchar_t c = tmp[i];
+		if (c == L'/' || c == L'\\')
+		{
+			tmp[wp++] = 0;
+			wp = 0;
+			UniStrCat(dst, size, tmp);
+			tmp[wp++] = c;
+		}
+		else
+		{
+			tmp[wp++] = c;
+		}
+	}
+
+	if (UniStrLen(dst) == 0)
+	{
+		UniStrCpy(dst, size, L"/");
+	}
+
+	NormalizePathW(dst, size, dst);
+}
+
+// Get the directory name from the file path
+void GetDirNameFromFilePath(char *dst, UINT size, char *filepath)
+{
+	char tmp[MAX_SIZE];
+	UINT wp;
+	UINT i;
+	UINT len;
+	// Validate arguments
+	if (dst == NULL || filepath == NULL)
+	{
+		return;
+	}
+
+	StrCpy(tmp, sizeof(tmp), filepath);
+	if (EndWith(tmp, "\\") || EndWith(tmp, "/"))
+	{
+		tmp[StrLen(tmp) - 1] = 0;
+	}
+
+	len = StrLen(tmp);
+
+	StrCpy(dst, size, "");
+
+	wp = 0;
+
+	for (i = 0;i < len;i++)
+	{
+		char c = tmp[i];
+		if (c == '/' || c == '\\')
+		{
+			tmp[wp++] = 0;
+			wp = 0;
+			StrCat(dst, size, tmp);
+			tmp[wp++] = c;
+		}
+		else
+		{
+			tmp[wp++] = c;
+		}
+	}
+
+	if (StrLen(dst) == 0)
+	{
+		StrCpy(dst, size, "/");
+	}
+
+	NormalizePath(dst, size, dst);
+}
+
+// Combine the two paths
+void ConbinePath(char *dst, UINT size, char *dirname, char *filename)
+{
+	wchar_t dst_w[MAX_PATH];
+	wchar_t *dirname_w = CopyStrToUni(dirname);
+	wchar_t *filename_w = CopyStrToUni(filename);
+
+	ConbinePathW(dst_w, sizeof(dst_w), dirname_w, filename_w);
+
+	Free(dirname_w);
+	Free(filename_w);
+
+	UniToStr(dst, size, dst_w);
+}
+void ConbinePathW(wchar_t *dst, UINT size, wchar_t *dirname, wchar_t *filename)
+{
+	bool is_full_path;
+	wchar_t tmp[MAX_SIZE];
+	wchar_t filename_ident[MAX_SIZE];
+	// Validate arguments
+	if (dst == NULL || dirname == NULL || filename == NULL)
+	{
+		return;
+	}
+
+	NormalizePathW(filename_ident, sizeof(filename_ident), filename);
+
+	is_full_path = false;
+
+	if (UniStartWith(filename_ident, L"\\") || UniStartWith(filename_ident, L"/"))
+	{
+		is_full_path = true;
+	}
+
+	filename = &filename_ident[0];
+
+#ifdef	OS_WIN32
+	if (UniStrLen(filename) >= 2)
+	{
+		if ((L'a' <= filename[0] && filename[0] <= L'z') || (L'A' <= filename[0] && filename[0] <= L'Z'))
+		{
+			if (filename[1] == L':')
+			{
+				is_full_path = true;
+			}
+		}
+	}
+#endif	// OS_WIN32
+
+	if (is_full_path == false)
+	{
+		UniStrCpy(tmp, sizeof(tmp), dirname);
+		if (UniEndWith(tmp, L"/") == false && UniEndWith(tmp, L"\\") == false)
+		{
+			UniStrCat(tmp, sizeof(tmp), L"/");
+		}
+		UniStrCat(tmp, sizeof(tmp), filename);
+	}
+	else
+	{
+		UniStrCpy(tmp, sizeof(tmp), filename);
+	}
+
+	NormalizePathW(dst, size, tmp);
+}
+void CombinePath(char *dst, UINT size, char *dirname, char *filename)
+{
+	ConbinePath(dst, size, dirname, filename);
+}
+void CombinePathW(wchar_t *dst, UINT size, wchar_t *dirname, wchar_t *filename)
+{
+	ConbinePathW(dst, size, dirname, filename);
+}
+
+// Check whether the file exists
+bool IsFileExists(char *name)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	bool ret = IsFileExistsW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+bool IsFileExistsW(wchar_t *name)
+{
+	wchar_t tmp[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	InnerFilePathW(tmp, sizeof(tmp), name);
+
+	return IsFileExistsInnerW(tmp);
+}
+bool IsFileExistsInnerW(wchar_t *name)
+{
+	IO *o;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	o = FileOpenInnerW(name, false, false);
+	if (o == NULL)
+	{
+		return false;
+	}
+
+	FileClose(o);
+
+	return true;
+}
+
+// Get the current contents of the PATH environment variable
+char *GetCurrentPathEnvStr()
+{
+	char tmp[1024];
+	char *tag_name;
+
+#ifdef	OS_WIN32
+	tag_name = "Path";
+#else	// OS_WIN32
+	tag_name = "PATH";
+#endif	// OS_WIN32
+
+	if (GetEnv(tag_name, tmp, sizeof(tmp)) == false)
+	{
+#ifdef	OS_WIN32
+		Win32GetCurrentDir(tmp, sizeof(tmp));
+#else	// OS_WIN32
+		UnixGetCurrentDir(tmp, sizeof(tmp));
+#endif	// OS_WIN32
+	}
+
+	return CopyStr(tmp);
+}
+
+// Get multiple paths separated by colons
+UNI_TOKEN_LIST *ParseSplitedPathW(wchar_t *path)
+{
+	UNI_TOKEN_LIST *ret;
+	wchar_t *tmp = UniCopyStr(path);
+	wchar_t *split_str;
+	UINT i;
+
+	UniTrim(tmp);
+	UniTrimCrlf(tmp);
+	UniTrim(tmp);
+	UniTrimCrlf(tmp);
+
+#ifdef	OS_WIN32
+	split_str = L";";
+#else	// OS_WIN32
+	split_str = L":";
+#endif	// OS_WIN32
+
+	ret = UniParseToken(tmp, split_str);
+
+	if (ret != NULL)
+	{
+		for (i = 0;i < ret->NumTokens;i++)
+		{
+			UniTrim(ret->Token[i]);
+			UniTrimCrlf(ret->Token[i]);
+			UniTrim(ret->Token[i]);
+			UniTrimCrlf(ret->Token[i]);
+		}
+	}
+
+	Free(tmp);
+
+	return ret;
+}
+
+// Normalize the file path
+void NormalizePathW(wchar_t *dst, UINT size, wchar_t *src)
+{
+	wchar_t tmp[MAX_SIZE];
+	UNI_TOKEN_LIST *t;
+	bool first_double_slash = false;
+	bool first_single_slash = false;
+#ifdef  OS_WIN32
+	wchar_t win32_drive_char = 0;
+#endif  // OS_WIN32
+	bool is_full_path = false;
+	UINT i;
+	SK *sk;
+	// Validate arguments
+	if (dst == NULL || src == 0)
+	{
+		return;
+	}
+
+	// Convert the path (Win32, UNIX conversion)
+	UniStrCpy(tmp, sizeof(tmp), src);
+	ConvertPathW(tmp);
+	UniTrim(tmp);
+
+	// If the path begins with "./ " or " ../", replace it to the current directory
+	if (UniStartWith(tmp, L"./") || UniStartWith(tmp, L".\\") ||
+		UniStartWith(tmp, L"../") || UniStartWith(tmp, L"..\\") ||
+		UniStrCmpi(tmp, L".") == 0 || UniStrCmpi(tmp, L"..") == 0)
+	{
+		wchar_t cd[MAX_SIZE];
+		Zero(cd, sizeof(cd));
+
+#ifdef	OS_WIN32
+		Win32GetCurrentDirW(cd, sizeof(cd));
+#else	// OS_WIN32
+		UnixGetCurrentDirW(cd, sizeof(cd));
+#endif	// OS_WIN32
+
+		if (UniStartWith(tmp, L".."))
+		{
+			UniStrCat(cd, sizeof(cd), L"/../");
+			UniStrCat(cd, sizeof(cd), tmp + 2);
+		}
+		else
+		{
+			UniStrCat(cd, sizeof(cd), L"/");
+			UniStrCat(cd, sizeof(cd), tmp);
+		}
+
+		UniStrCpy(tmp, sizeof(tmp), cd);
+	}
+
+	// If the path starts with "~/", replace it with the home directory
+	if (UniStartWith(tmp, L"~/") || UniStartWith(tmp, L"~\\"))
+	{
+		wchar_t tmp2[MAX_SIZE];
+		GetHomeDirW(tmp2, sizeof(tmp2));
+		UniStrCat(tmp2, sizeof(tmp2), L"/");
+		UniStrCat(tmp2, sizeof(tmp2), tmp + 2);
+		UniStrCpy(tmp, sizeof(tmp), tmp2);
+	}
+
+	if (UniStartWith(tmp, L"//") || UniStartWith(tmp, L"\\\\"))
+	{
+        // Begin with "//" or "\\"
+		first_double_slash = true;
+		is_full_path = true;
+	}
+	else if (UniStartWith(tmp, L"/") || UniStartWith(tmp, L"\\"))
+	{
+		// Begin with "\"
+		first_single_slash = true;
+		is_full_path = true;
+	}
+
+#ifdef	OS_WIN32
+	if (UniStrLen(tmp) >= 2)
+	{
+		if (tmp[1] == L':')
+		{
+			// The drive string representation of the Win32
+			wchar_t tmp2[MAX_SIZE];
+			is_full_path = true;
+			win32_drive_char = tmp[0];
+			UniStrCpy(tmp2, sizeof(tmp2), tmp + 2);
+			UniStrCpy(tmp, sizeof(tmp), tmp2);
+		}
+	}
+#endif	// OS_WIN32
+
+	if (UniStrLen(tmp) == 1 && (tmp[0] == L'/' || tmp[0] == L'\\'))
+	{
+		tmp[0] = 0;
+	}
+
+	// Tokenize
+	t = UniParseToken(tmp, L"/\\");
+
+	sk = NewSk();
+
+	for (i = 0;i < t->NumTokens;i++)
+	{
+		wchar_t *s = t->Token[i];
+
+		if (UniStrCmpi(s, L".") == 0)
+		{
+			continue;
+		}
+		else if (UniStrCmpi(s, L"..") == 0)
+		{
+			if (sk->num_item >= 1 && (first_double_slash == false || sk->num_item >= 2))
+			{
+				Pop(sk);
+			}
+		}
+		else
+		{
+			Push(sk, s);
+		}
+	}
+
+	// Token concatenation
+	UniStrCpy(tmp, sizeof(tmp), L"");
+
+	if (first_double_slash)
+	{
+		UniStrCat(tmp, sizeof(tmp), L"//");
+	}
+	else if (first_single_slash)
+	{
+		UniStrCat(tmp, sizeof(tmp), L"/");
+	}
+
+#ifdef  OS_WIN32
+	if (win32_drive_char != 0)
+	{
+		wchar_t d[2];
+		d[0] = win32_drive_char;
+		d[1] = 0;
+		UniStrCat(tmp, sizeof(tmp), d);
+		UniStrCat(tmp, sizeof(tmp), L":/");
+	}
+#endif  // OS_WIN32
+
+	for (i = 0;i < sk->num_item;i++)
+	{
+		UniStrCat(tmp, sizeof(tmp), (wchar_t *)sk->p[i]);
+		if (i != (sk->num_item - 1))
+		{
+			UniStrCat(tmp, sizeof(tmp), L"/");
+		}
+	}
+
+	ReleaseSk(sk);
+
+	UniFreeToken(t);
+
+	ConvertPathW(tmp);
+
+	UniStrCpy(dst, size, tmp);
+}
+void NormalizePath(char *dst, UINT size, char *src)
+{
+	wchar_t dst_w[MAX_SIZE];
+	wchar_t *src_w = CopyStrToUni(src);
+
+	NormalizePathW(dst_w, sizeof(dst_w), src_w);
+
+	Free(src_w);
+
+	UniToStr(dst, size, dst_w);
+}
+
+// Rename the file
+bool FileRenameW(wchar_t *old_name, wchar_t *new_name)
+{
+	wchar_t tmp1[MAX_SIZE];
+	wchar_t tmp2[MAX_SIZE];
+	// Validate arguments
+	if (old_name == NULL || new_name == NULL)
+	{
+		return false;
+	}
+
+	InnerFilePathW(tmp1, sizeof(tmp1), old_name);
+	InnerFilePathW(tmp2, sizeof(tmp2), new_name);
+
+	return FileRenameInnerW(tmp1, tmp2);
+}
+bool FileRenameInnerW(wchar_t *old_name, wchar_t *new_name)
+{
+	// Validate arguments
+	if (old_name == NULL || new_name == NULL)
+	{
+		return false;
+	}
+
+	return OSFileRenameW(old_name, new_name);
+}
+
+// Convert the path
+void ConvertPathW(wchar_t *path)
+{
+	UINT i, len;
+#ifdef	PATH_BACKSLASH
+	wchar_t new_char = L'\\';
+#else
+	wchar_t new_char = L'/';
+#endif
+
+	len = UniStrLen(path);
+	for (i = 0;i < len;i++)
+	{
+		if (path[i] == L'\\' || path[i] == L'/')
+		{
+			path[i] = new_char;
+		}
+	}
+}
+
+// Delete the directory
+bool DeleteDir(char *name)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	bool ret = DeleteDirW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+bool DeleteDirW(wchar_t *name)
+{
+	wchar_t tmp[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	InnerFilePathW(tmp, sizeof(tmp), name);
+
+	return DeleteDirInnerW(tmp);
+}
+bool DeleteDirInnerW(wchar_t *name)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	return OSDeleteDirW(name);
+}
+
+// Generation of internal file path
+void InnerFilePathW(wchar_t *dst, UINT size, wchar_t *src)
+{
+	// Validate arguments
+	if (dst == NULL || src == NULL)
+	{
+		return;
+	}
+
+	if (src[0] == L'@')
+	{
+		wchar_t dir[MAX_SIZE];
+		GetLogDirW(dir, sizeof(dir));
+		ConbinePathW(dst, size, dir, &src[1]);
+	}
+	else if (src[0] == L'$')
+	{
+		wchar_t dir[MAX_SIZE];
+		GetDbDirW(dir, sizeof(dir));
+		ConbinePathW(dst, size, dir, &src[1]);
+	}
+	else
+	{
+		NormalizePathW(dst, size, src);
+	}
+}
+void InnerFilePath(char *dst, UINT size, char *src)
+{
+	wchar_t dst_w[MAX_PATH];
+	wchar_t *src_w = CopyStrToUni(src);
+
+	InnerFilePathW(dst_w, sizeof(dst_w), src_w);
+
+	Free(src_w);
+
+	UniToStr(dst, size, dst_w);
+}
+
+// Recursive directory creation
+bool MakeDirEx(char *name)
+{
+	bool ret;
+	wchar_t *name_w = CopyStrToUni(name);
+
+	ret = MakeDirExW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+bool MakeDirExW(wchar_t *name)
+{
+	LIST *o;
+	wchar_t tmp[MAX_PATH];
+	wchar_t tmp2[MAX_PATH];
+	UINT i;
+	bool ret = false;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	o = NewListFast(NULL);
+
+	UniStrCpy(tmp, sizeof(tmp), name);
+	while (true)
+	{
+		wchar_t *s = CopyUniStr(tmp);
+
+		Add(o, s);
+
+		GetDirNameFromFilePathW(tmp2, sizeof(tmp2), tmp);
+
+		if (UniStrCmpi(tmp2, tmp) == 0)
+		{
+			break;
+		}
+
+		UniStrCpy(tmp, sizeof(tmp), tmp2);
+	}
+
+	for (i = 0;i < LIST_NUM(o);i++)
+	{
+		UINT j = LIST_NUM(o) - i - 1;
+		wchar_t *s = LIST_DATA(o, j);
+
+		if (UniStrCmpi(s, L"\\") != 0 && UniStrCmpi(s, L"/") != 0)
+		{
+			ret = MakeDirW(s);
+		}
+	}
+
+	UniFreeStrList(o);
+
+	return ret;
+}
+
+// Create a directory
+bool MakeDir(char *name)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	bool ret = MakeDirW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+bool MakeDirW(wchar_t *name)
+{
+	wchar_t tmp[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	InnerFilePathW(tmp, sizeof(tmp), name);
+
+	return MakeDirInnerW(tmp);
+}
+bool MakeDirInnerW(wchar_t *name)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	return OSMakeDirW(name);
+}
+
+// Delete the file
+bool FileDelete(char *name)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	bool ret = FileDeleteW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+bool FileDeleteW(wchar_t *name)
+{
+	wchar_t tmp[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	InnerFilePathW(tmp, sizeof(tmp), name);
+
+	return FileDeleteInnerW(tmp);
+}
+bool FileDeleteInnerW(wchar_t *name)
+{
+	wchar_t name2[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	UniStrCpy(name2, sizeof(name2), name);
+	ConvertPathW(name2);
+
+	return OSFileDeleteW(name2);
+}
+
+// Seek the file
+bool FileSeek(IO *o, UINT mode, int offset)
+{
+	// Validate arguments
+	if (o == NULL)
+	{
+		return false;
+	}
+
+	if (o->HamMode == false)
+	{
+		return OSFileSeek(o->pData, mode, offset);
+	}
+	else
+	{
+		return false;
+	}
+}
+
+// Get the file size
+UINT64 FileSize64(IO *o)
+{
+	// Validate arguments
+	if (o == NULL)
+	{
+		return 0;
+	}
+
+	if (o->HamMode == false)
+	{
+		return OSFileSize(o->pData);
+	}
+	else
+	{
+		return (UINT64)o->HamBuf->Size;
+	}
+}
+UINT FileSize(IO *o)
+{
+	UINT64 size = (UINT)(FileSize64(o));
+
+	if (size >= 4294967296ULL)
+	{
+		size = 4294967295ULL;
+	}
+
+	return (UINT)size;
+}
+
+// Read from a file
+bool FileRead(IO *o, void *buf, UINT size)
+{
+	// Validate arguments
+	if (o == NULL || buf == NULL)
+	{
+		return false;
+	}
+
+	// KS
+	KS_INC(KS_IO_READ_COUNT);
+	KS_ADD(KS_IO_TOTAL_READ_SIZE, size);
+
+	if (size == 0)
+	{
+		return true;
+	}
+
+	if (o->HamMode == false)
+	{
+		return OSFileRead(o->pData, buf, size);
+	}
+	else
+	{
+		return ReadBuf(o->HamBuf, buf, size) == size ? true : false;
+	}
+}
+
+// Write to a file
+bool FileWrite(IO *o, void *buf, UINT size)
+{
+	// Validate arguments
+	if (o == NULL || buf == NULL)
+	{
+		return false;
+	}
+	if (o->WriteMode == false)
+	{
+		return false;
+	}
+
+	// KS
+	KS_INC(KS_IO_WRITE_COUNT);
+	KS_ADD(KS_IO_TOTAL_WRITE_SIZE, size);
+
+	if (size == 0)
+	{
+		return true;
+	}
+
+	return OSFileWrite(o->pData, buf, size);
+}
+
+// Flush the file
+void FileFlush(IO *o)
+{
+	// Validate arguments
+	if (o == NULL)
+	{
+		return;
+	}
+
+	if (o->HamMode)
+	{
+		return;
+	}
+
+	OSFileFlush(o->pData);
+}
+
+// Close the file
+void FileClose(IO *o)
+{
+	FileCloseEx(o, false);
+}
+void FileCloseEx(IO *o, bool no_flush)
+{
+	// Validate arguments
+	if (o == NULL)
+	{
+		return;
+	}
+
+	if (o->HamMode == false)
+	{
+		if (o->WriteMode)
+		{
+#ifdef	OS_WIN32
+			Win32FileSetDate(o->pData, o->SetCreateTime, o->SetUpdateTime);
+#endif	// OS_WIN32
+		}
+
+		OSFileClose(o->pData, no_flush);
+	}
+	else
+	{
+		FreeBuf(o->HamBuf);
+	}
+	Free(o);
+
+	// KS
+	KS_INC(KS_IO_CLOSE_COUNT);
+}
+
+// Create a file
+IO *FileCreateInnerW(wchar_t *name)
+{
+	IO *o;
+	void *p;
+	wchar_t name2[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	UniStrCpy(name2, sizeof(name2), name);
+	ConvertPathW(name2);
+
+	p = OSFileCreateW(name2);
+	if (p == NULL)
+	{
+		return NULL;
+	}
+
+	o = ZeroMalloc(sizeof(IO));
+	o->pData = p;
+	UniStrCpy(o->NameW, sizeof(o->NameW), name2);
+	UniToStr(o->Name, sizeof(o->Name), o->NameW);
+	o->WriteMode = true;
+
+	// KS
+	KS_INC(KS_IO_CREATE_COUNT);
+
+	return o;
+}
+IO *FileCreate(char *name)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	IO *ret = FileCreateW(name_w);
+
+	Free(name_w);
+
+	return ret;
+}
+IO *FileCreateW(wchar_t *name)
+{
+	wchar_t tmp[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	InnerFilePathW(tmp, sizeof(tmp), name);
+
+	return FileCreateInnerW(tmp);
+}
+
+// Write all the data to the file
+bool FileWriteAllW(wchar_t *name, void *data, UINT size)
+{
+	IO *io;
+	// Validate arguments
+	if (name == NULL || (data == NULL && size != 0))
+	{
+		return false;
+	}
+
+	io = FileCreateW(name);
+
+	if (io == NULL)
+	{
+		return false;
+	}
+
+	FileWrite(io, data, size);
+
+	FileClose(io);
+
+	return true;
+}
+
+// Open the file
+IO *FileOpenInnerW(wchar_t *name, bool write_mode, bool read_lock)
+{
+	IO *o;
+	void *p;
+	wchar_t name2[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	UniStrCpy(name2, sizeof(name2), name);
+	ConvertPathW(name2);
+
+	p = OSFileOpenW(name2, write_mode, read_lock);
+	if (p == NULL)
+	{
+		return NULL;
+	}
+
+	o = ZeroMalloc(sizeof(IO));
+	o->pData = p;
+	UniStrCpy(o->NameW, sizeof(o->NameW), name2);
+	UniToStr(o->Name, sizeof(o->Name), o->NameW);
+	o->WriteMode = write_mode;
+
+#ifdef	OS_WIN32
+	Win32FileGetDate(p, &o->GetCreateTime, &o->GetUpdateTime, &o->GetAccessTime);
+#endif	// OS_WIN32
+
+	// KS
+	KS_INC(KS_IO_OPEN_COUNT);
+
+	return o;
+}
+IO *FileOpen(char *name, bool write_mode)
+{
+	return FileOpenEx(name, write_mode, true);
+}
+IO *FileOpenW(wchar_t *name, bool write_mode)
+{
+	return FileOpenExW(name, write_mode, true);
+}
+IO *FileOpenEx(char *name, bool write_mode, bool read_lock)
+{
+	wchar_t *name_w = CopyStrToUni(name);
+	IO *ret = FileOpenExW(name_w, write_mode, read_lock);
+
+	Free(name_w);
+
+	return ret;
+}
+
+// Replace the specified character in the string with a new character
+wchar_t *UniReplaceCharW(wchar_t *src, UINT size, wchar_t c, wchar_t  newc) {
+	if (src == NULL)
+	{
+		return NULL;
+	}
+	for (; *src; src++, size -= sizeof(wchar_t)) {
+		if (size < sizeof(wchar_t)) {
+			break;
+		}
+		if (*src == c) {
+			*src = newc;
+		}
+	}
+	return (wchar_t *)src;
+}
+
+IO *FileOpenExW(wchar_t *name, bool write_mode, bool read_lock)
+{
+	wchar_t tmp[MAX_SIZE];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	InnerFilePathW(tmp, sizeof(tmp), name);
+
+	if (name[0] == L'|')
+	{
+		IO *o = ZeroMalloc(sizeof(IO));
+		name++;
+		UniStrCpy(o->NameW, sizeof(o->NameW), name);
+#ifdef	OS_WIN32
+		UniReplaceCharW(o->NameW, sizeof(o->NameW), L'\\', L'/');		// Path separator "/" is used.
+#endif	// OS_WIN32
+		UniToStr(o->Name, sizeof(o->Name), o->NameW);
+		o->HamMode = true;
+		o->HamBuf = ReadHamcoreW(o->NameW);
+		if (o->HamBuf == NULL)
+		{
+			Free(o);
+			return NULL;
+		}
+		return o;
+	}
+	else
+	{
+		return FileOpenInnerW(tmp, write_mode, read_lock);
+	}
+}
diff --git a/src/Mayaqua/Mayaqua.c b/src/Mayaqua/Mayaqua.c
index 8649275..6cddf96 100644
--- a/src/Mayaqua/Mayaqua.c
+++ b/src/Mayaqua/Mayaqua.c
@@ -1,1094 +1,1100 @@
-// SoftEther VPN Source Code - Developer Edition Master Branch
-// Mayaqua Kernel
-
-
-// Mayaqua.c
-// Mayaqua Kernel program
-
-#include "Mayaqua.h"
-
-#include "Encrypt.h"
-#include "FileIO.h"
-#include "GlobalConst.h"
-#include "Internat.h"
-#include "Memory.h"
-#include "Microsoft.h"
-#include "Network.h"
-#include "Object.h"
-#include "OS.h"
-#include "Secure.h"
-#include "Str.h"
-#include "Table.h"
-#include "Tick64.h"
-#include "Tracking.h"
-
-#include <locale.h>
-#include <stdlib.h>
-
-// Global variable
-bool g_memcheck;								// Enable memory check
-bool g_debug;									// Debug mode
-UINT64 kernel_status[NUM_KERNEL_STATUS];		// Kernel state
-UINT64 kernel_status_max[NUM_KERNEL_STATUS];	// Kernel state (maximum value)
-LOCK *kernel_status_lock[NUM_KERNEL_STATUS];	// Kernel state lock
-bool kernel_status_inited = false;				// Kernel state initialization flag
-bool g_little_endian = true;
-char *cmdline = NULL;							// Command line
-wchar_t *uni_cmdline = NULL;					// Unicode command line
-bool g_foreground = false;					// Execute service in foreground mode
-
-// Static variable
-static char *exename = NULL;						// EXE file name (ANSI)
-static wchar_t *exename_w = NULL;					// EXE file name (Unicode)
-static TOKEN_LIST *cmdline_token = NULL;			// Command line token
-static UNI_TOKEN_LIST *cmdline_uni_token = NULL;	// Command line token (Unicode)
-static OS_INFO *os_info = NULL;						// OS information
-static bool dot_net_mode = false;
-static bool minimal_mode = false;
-static UINT last_time_check = 0;
-static UINT first_time_check = 0;
-static bool is_nt = false;
-static bool is_ham_mode = false;
-static UINT init_mayaqua_counter = 0;
-static bool use_probe = false;
-static BUF *probe_buf = NULL;
-static LOCK *probe_lock = NULL;
-static UINT64 probe_start = 0;
-static UINT64 probe_last = 0;
-static bool probe_enabled = false;
-
-// The function which should be called once as soon as possible after the process is started
-static bool init_proc_once_flag = false;
-void InitProcessCallOnce()
-{
-	if (init_proc_once_flag == false)
-	{
-		init_proc_once_flag = true;
-
-		InitCanaryRand();
-
-#ifdef	OS_WIN32
-		MsInitProcessCallOnce();
-#endif	// OS_WIN32
-	}
-}
-
-// Calculate the checksum
-USHORT CalcChecksum16(void *buf, UINT size)
-{
-	int sum = 0;
-	USHORT *addr = (USHORT *)buf;
-	int len = (int)size;
-	USHORT *w = addr;
-	int nleft = len;
-	USHORT answer = 0;
-
-	while (nleft > 1)
-	{
-		USHORT ww = 0;
-		Copy(&ww, w++, sizeof(USHORT));
-		sum += ww;
-		nleft -= 2;
-	}
-
-	if (nleft == 1)
-	{
-		*(UCHAR *)(&answer) = *(UCHAR *)w;
-		sum += answer;
-	}
-
-	sum = (sum >> 16) + (sum & 0xffff);
-	sum += (sum >> 16);
-
-	answer = ~sum;
-
-	return answer;
-}
-
-// Writing a probe with the data
-void WriteProbeData(char *filename, UINT line, char *str, void *data, UINT size)
-{
-	char tmp[MAX_SIZE];
-	USHORT cs;
-
-	if (IsProbeEnabled() == false)
-	{
-		return;
-	}
-
-	// Take a checksum of the data
-	if (size != 0)
-	{
-		cs = CalcChecksum16(data, size);
-	}
-	else
-	{
-		cs = 0;
-	}
-
-	// Generating a String
-	snprintf(tmp, sizeof(tmp), "\"%s\" (Size=%5u, Crc=0x%04X)", str, size, cs);
-
-	WriteProbe(filename, line, tmp);
-}
-
-// Writing Probe
-void WriteProbe(char *filename, UINT line, char *str)
-{
-#ifdef	OS_WIN32
-	char *s;
-	char tmp[MAX_SIZE];
-	char tmp2[MAX_SIZE];
-	UINT64 now = 0;
-	UINT64 time;
-
-	if (IsProbeEnabled() == false)
-	{
-		return;
-	}
-
-	now = MsGetHiResCounter();
-
-	Lock(probe_lock);
-	{
-		UINT64 diff;
-		
-		time = MsGetHiResTimeSpanUSec(now - probe_start);
-
-		diff = time - probe_last;
-
-		if (time < probe_last)
-		{
-			diff = 0;
-		}
-
-		probe_last = time;
-
-		ToStr64(tmp, time);
-		MakeCharArray2(tmp2, ' ', (UINT)(MIN(12, (int)12 - (int)StrLen(tmp))));
-		WriteBuf(probe_buf, tmp2, StrLen(tmp2));
-		WriteBuf(probe_buf, tmp, StrLen(tmp));
-
-		s = " [+";
-		WriteBuf(probe_buf, s, StrLen(s));
-
-		ToStr64(tmp, diff);
-		MakeCharArray2(tmp2, ' ', (UINT)(MIN(12, (int)12 - (int)StrLen(tmp))));
-		WriteBuf(probe_buf, tmp2, StrLen(tmp2));
-		WriteBuf(probe_buf, tmp, StrLen(tmp));
-
-		s = "] - ";
-		WriteBuf(probe_buf, s, StrLen(s));
-
-		WriteBuf(probe_buf, filename, StrLen(filename));
-
-		s = "(";
-		WriteBuf(probe_buf, s, StrLen(s));
-
-		ToStr64(tmp, (UINT64)line);
-		WriteBuf(probe_buf, tmp, StrLen(tmp));
-
-		s = "): ";
-		WriteBuf(probe_buf, s, StrLen(s));
-
-		WriteBuf(probe_buf, str, StrLen(str));
-
-		s = "\r\n";
-		WriteBuf(probe_buf, s, StrLen(s));
-	}
-	Unlock(probe_lock);
-#endif	// OS_WIN32
-}
-
-// Initialization of Probe
-void InitProbe()
-{
-	probe_buf = NewBuf();
-	probe_lock = NewLock();
-	probe_enabled = false;
-
-	probe_start = 0;
-
-#ifdef	OS_WIN32
-	probe_start = MsGetHiResCounter();
-#endif	// OS_WIN32
-}
-
-// Release of Probe
-void FreeProbe()
-{
-	if (probe_buf->Size >= 1)
-	{
-		SYSTEMTIME st;
-		char filename[MAX_SIZE];
-
-		// Write all to the file
-		MakeDirEx("@probe_log");
-
-		LocalTime(&st);
-
-		snprintf(filename, sizeof(filename), "@probe_log/%04u%02u%02u_%02u%02u%02u.log",
-			st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
-
-		DumpBuf(probe_buf, filename);
-	}
-
-	FreeBuf(probe_buf);
-	DeleteLock(probe_lock);
-}
-
-// Set enable / disable the Probe
-void EnableProbe(bool enable)
-{
-	probe_enabled = enable;
-}
-
-// Get whether the Probe is enabled?
-bool IsProbeEnabled()
-{
-#ifndef	USE_PROBE
-	return false;
-#else	// USE_PROBE
-	return probe_enabled;
-#endif	// USE_PROBE
-}
-
-// Set the Ham mode
-void SetHamMode()
-{
-	is_ham_mode = true;
-}
-
-// Get whether in Ham mode
-bool IsHamMode()
-{
-	return is_ham_mode;
-}
-
-// Display the time from the previous call to now
-void TimeCheck()
-{
-#ifdef OS_WIN32
-	UINT now, ret, total;
-	now = Win32GetTick();
-	if (last_time_check == 0)
-	{
-		ret = 0;
-	}
-	else
-	{
-		ret = now - last_time_check;
-	}
-	last_time_check = now;
-
-	if (first_time_check == 0)
-	{
-		first_time_check = now;
-	}
-
-	total = now - first_time_check;
-
-	printf(" -- %3.3f / %3.3f\n", (double)ret / 1000.0f, (double)total / 1000.0f);
-#endif	// OS_WIN32
-}
-
-// Whether this system is IA64
-bool IsIA64()
-{
-	if (Is64() == false)
-	{
-		return false;
-	}
-
-#ifndef	MAYAQUA_IA_64
-	return false;
-#else	// MAYAQUA_IA_64
-	return true;
-#endif	// MAYAQUA_IA_64
-}
-
-// Whether in x64
-bool IsX64()
-{
-	if (Is64() == false)
-	{
-		return false;
-	}
-
-#ifndef	MAYAQUA_IA_64
-	return true;
-#else	// MAYAQUA_IA_64
-	return false;
-#endif	// MAYAQUA_IA_64
-}
-
-// Whether 64bit
-bool Is64()
-{
-#ifdef	CPU_64
-	return true;
-#else	// CPU_64
-	return false;
-#endif	// CPU_64
-}
-
-// Whether 32bit
-bool Is32()
-{
-	return Is64() ? false : true;
-}
-
-// Acquisition whether in .NET mode
-bool MayaquaIsDotNetMode()
-{
-	return dot_net_mode;
-}
-
-// Check the endian
-void CheckEndian()
-{
-	unsigned short test;
-	UCHAR *buf;
-
-	test = 0x1234;
-	buf = (UCHAR *)&test;
-	if (buf[0] == 0x12)
-	{
-		g_little_endian = false;
-	}
-	else
-	{
-		g_little_endian = true;
-	}
-}
-
-// Minimize mode
-void MayaquaMinimalMode()
-{
-	minimal_mode = true;
-}
-bool MayaquaIsMinimalMode()
-{
-	return minimal_mode;
-}
-
-// Whether in NT
-bool IsNt()
-{
-	return is_nt;
-}
-
-// Initialization of Mayaqua library
-void InitMayaqua(bool memcheck, bool debug, int argc, char **argv)
-{
-	wchar_t tmp[MAX_PATH];
-	UCHAR hash[SHA1_SIZE];
-
-	if ((init_mayaqua_counter++) > 0)
-	{
-		return;
-	}
-
-	InitProcessCallOnce();
-
-	g_memcheck = memcheck;
-	g_debug = debug;
-	cmdline = NULL;
-	if (dot_net_mode == false)
-	{
-		// Fail this for some reason when this is called this in .NET mode
-		setbuf(stdout, NULL);
-	}
-
-#ifdef OS_UNIX
-	g_foreground = (argc >= 3 && StrCmpi(argv[2], UNIX_SVC_ARG_FOREGROUND) == 0);
-#else
-	g_foreground = false;
-#endif // OS_UNIX
-
-	// Acquisition whether NT
-#ifdef	OS_WIN32
-	is_nt = Win32IsNt();
-#endif	// OS_WIN32
-
-	// Check endian
-	CheckEndian();
-
-#ifdef	OS_WIN32
-	_configthreadlocale(_DISABLE_PER_THREAD_LOCALE);
-#endif	// OS_WIN32
-
-	// Set the locale information of the CRT to the Japanese
-	setlocale(LC_ALL, "");
-
-	// Initialization of OS
-	OSInit();
-
-	// Initialize the random number
-	srand((UINT)SystemTime64());
-
-	tick_manual_lock = NewLock();
-
-	// Initialization of CRC32
-	InitCrc32();
-
-	// Initialization of the FIFO system
-	InitFifo();
-
-	// Initialize the Kernel status
-	InitKernelStatus();
-
-	if (IsTrackingEnabled())
-	{
-		// Initialize the tracking
-		InitTracking();
-	}
-
-	// Initialization of thread pool
-	InitThreading();
-
-	// Initialize the string library
-	InitStringLibrary();
-
-	// Initialization of the locale information
-	SetLocale(NULL);
-
-	// Initialization of the crypt library
-	InitCryptLibrary();
-
-	// Initialization of the real-time clock
-	InitTick64();
-
-	// Initialize the network communication module
-	InitNetwork();
-
-	// Initialization of the acquisition of the EXE file name
-	InitGetExeName(argc >= 1 ? argv[0] : NULL);
-
-	// Initialization of the command line string
-	InitCommandLineStr(argc, argv);
-
-	// Initialization of OS information
-	InitOsInfo();
-
-	// Initialization of the operating system-specific module
-#ifdef	OS_WIN32
-	MsInit();	// Microsoft Win32
-#endif	// OS_WIN32
-
-	// Initialization of the security token module
-	InitSecure();
-
-	if (OSIsSupportedOs() == false)
-	{
-		// Abort
-		exit(0);
-	}
-
-	// RSA Check
-	if (RsaCheckEx() == false)
-	{
-		// Abort
-		Alert("OpenSSL Library Init Failed. (too old?)\nPlease install the latest version of OpenSSL.\n\n", "RsaCheck()");
-		exit(0);
-	}
-
-	// Initialization of HamCore file system
-	InitHamcore();
-
-	// Initialization of string table routine
-	InitTable();
-
-	if (exename == NULL)
-	{
-		// Executable file name
-		exename = CopyStr("unknown");
-	}
-
-	// Check whether the executable file name of themselves is found
-	// (If not found, quit because this is started in strange path)
-	GetExeNameW(tmp, sizeof(tmp));
-	if (IsFileExistsW(tmp) == false)
-	{
-		wchar_t tmp2[MAX_SIZE];
-
-		UniFormat(tmp2, sizeof(tmp2),
-			L"Error: Executable binary file \"%s\" not found.\r\n\r\n"
-			L"Please execute program with full path.\r\n",
-			tmp);
-
-		AlertW(tmp2, NULL);
-		_exit(0);
-	}
-
-	CheckUnixTempDir();
-
-	// Initialization of Probe
-	InitProbe();
-
-	// Initialization of Machine Hash
-	GetCurrentMachineIpProcessHash(hash);
-
-	// Reading Private IP file
-	LoadPrivateIPFile();
-}
-
-// Release of Mayaqua library
-void FreeMayaqua()
-{
-	if ((--init_mayaqua_counter) > 0)
-	{
-		return;
-	}
-
-	// Release of Private IP File
-	FreePrivateIPFile();
-
-	// Release of Probe
-	FreeProbe();
-
-	// Delete the table
-	FreeTable();
-
-	// Release of security token module
-	FreeSecure();
-
-	// Release of the operating system specific module
-#ifdef	OS_WIN32
-	MsFree();
-#endif	// OS_WIN32
-
-	// Release of OS information
-	FreeOsInfo();
-
-	// Release of HamCore file system
-	FreeHamcore();
-
-	// Release of the command line string
-	FreeCommandLineStr();
-
-	// Release of the command line token
-	FreeCommandLineTokens();
-
-	// Release of network communication module
-	FreeNetwork();
-
-	// Release of real-time clock
-	FreeTick64();
-
-	// Release of the string library
-	FreeStringLibrary();
-
-	// Release of thread pool
-	FreeThreading();
-
-	// Release of crypt library
-	FreeCryptLibrary();
-
-	if (IsTrackingEnabled())
-	{
-		// Show the kernel status
-		if (g_debug)
-		{
-			PrintKernelStatus();
-		}
-
-		// Display the debug information
-		if (g_memcheck)
-		{
-			PrintDebugInformation();
-		}
-
-		// Release the tracking
-		FreeTracking();
-	}
-
-	// Release of the kernel status
-	FreeKernelStatus();
-
-	DeleteLock(tick_manual_lock);
-	tick_manual_lock = NULL;
-
-	// Release of OS
-	OSFree();
-}
-
-// Check whether /tmp is available in the UNIX
-void CheckUnixTempDir()
-{
-	if (OS_IS_UNIX(GetOsInfo()->OsType))
-	{
-		char tmp[128], tmp2[64];
-		UINT64 now = SystemTime64();
-		IO *o;
-
-		MakeDir("/tmp");
-
-		Format(tmp2, sizeof(tmp2), "%I64u", now);
-
-		Format(tmp, sizeof(tmp), "/tmp/.%s", tmp2);
-
-		o = FileCreate(tmp);
-		if (o == NULL)
-		{
-			o = FileOpen(tmp, false);
-			if (o == NULL)
-			{
-				Print("Unable to use /tmp.\n\n");
-				exit(0);
-			}
-		}
-
-		FileClose(o);
-
-		FileDelete(tmp);
-	}
-}
-
-// Show an alert
-void Alert(char *msg, char *caption)
-{
-	OSAlert(msg, caption);
-}
-void AlertW(wchar_t *msg, wchar_t *caption)
-{
-	OSAlertW(msg, caption);
-}
-
-// Get the OS type
-UINT GetOsType()
-{
-	OS_INFO *i = GetOsInfo();
-
-	if (i == NULL)
-	{
-		return 0;
-	}
-
-	return i->OsType;
-}
-
-// Getting OS information
-OS_INFO *GetOsInfo()
-{
-	return os_info;
-}
-
-// Initialization of OS information
-void InitOsInfo()
-{
-	if (os_info != NULL)
-	{
-		return;
-	}
-
-	os_info = ZeroMalloc(sizeof(OS_INFO));
-
-	OSGetOsInfo(os_info);
-}
-
-// Release of OS information
-void FreeOsInfo()
-{
-	if (os_info == NULL)
-	{
-		return;
-	}
-
-	Free(os_info->OsSystemName);
-	Free(os_info->OsProductName);
-	Free(os_info->OsVendorName);
-	Free(os_info->OsVersion);
-	Free(os_info->KernelName);
-	Free(os_info->KernelVersion);
-	Free(os_info);
-
-	os_info = NULL;
-}
-
-// Get the Unicode command line tokens
-UNI_TOKEN_LIST *GetCommandLineUniToken()
-{
-	if (cmdline_uni_token == NULL)
-	{
-		return UniNullToken();
-	}
-	else
-	{
-		return UniCopyToken(cmdline_uni_token);
-	}
-}
-
-// Getting the command line tokens
-TOKEN_LIST *GetCommandLineToken()
-{
-	if (cmdline_token == NULL)
-	{
-		return NullToken();
-	}
-	else
-	{
-		return CopyToken(cmdline_token);
-	}
-}
-
-// Convert the command line string into tokens
-void ParseCommandLineTokens()
-{
-	if (cmdline_token != NULL)
-	{
-		FreeToken(cmdline_token);
-	}
-	cmdline_token = ParseCmdLine(cmdline);
-
-	if (cmdline_uni_token != NULL)
-	{
-		UniFreeToken(cmdline_uni_token);
-	}
-	cmdline_uni_token = UniParseCmdLine(uni_cmdline);
-}
-
-// Release command line tokens
-void FreeCommandLineTokens()
-{
-	if (cmdline_token != NULL)
-	{
-		FreeToken(cmdline_token);
-	}
-	cmdline_token = NULL;
-
-	if (cmdline_uni_token != NULL)
-	{
-		UniFreeToken(cmdline_uni_token);
-	}
-	cmdline_uni_token = NULL;
-}
-
-// Initialization of the command line string
-void InitCommandLineStr(int argc, char **argv)
-{
-	if (argc >= 1)
-	{
-#ifdef	OS_UNIX
-		exename_w = CopyUtfToUni(argv[0]);
-		exename = CopyUniToStr(exename_w);
-#else	// OS_UNIX
-		exename = CopyStr(argv[0]);
-		exename_w = CopyStrToUni(exename);
-#endif	// OS_UNIX
-	}
-	if (argc < 2 || argv == NULL)
-	{
-		// No command-line string
-		SetCommandLineStr(NULL);
-	}
-	else
-	{
-		// There are command-line string
-		int i, total_len = 1;
-		char *tmp;
-
-		for (i = 1;i < argc;i++)
-		{
-			total_len += StrLen(argv[i]) * 2 + 32;
-		}
-		tmp = ZeroMalloc(total_len);
-
-		for (i = 1;i < argc;i++)
-		{
-			UINT s_size = StrLen(argv[i]) * 2;
-			char *s = ZeroMalloc(s_size);
-			bool dq = (SearchStrEx(argv[i], " ", 0, true) != INFINITE);
-			ReplaceStrEx(s, s_size, argv[i], "\"", "\"\"", true);
-			if (dq)
-			{
-				StrCat(tmp, total_len, "\"");
-			}
-			StrCat(tmp, total_len, s);
-			if (dq)
-			{
-				StrCat(tmp, total_len, "\"");
-			}
-			StrCat(tmp, total_len, " ");
-			Free(s);
-		}
-
-		Trim(tmp);
-		SetCommandLineStr(tmp);
-		Free(tmp);
-	}
-}
-
-// Release of the command line string
-void FreeCommandLineStr()
-{
-	SetCommandLineStr(NULL);
-
-	if (exename != NULL)
-	{
-		Free(exename);
-		exename = NULL;
-	}
-
-	if (exename_w != NULL)
-	{
-		Free(exename_w);
-		exename_w = NULL;
-	}
-}
-
-// Get the Unicode command line string
-wchar_t *GetCommandLineUniStr()
-{
-	if (uni_cmdline == NULL)
-	{
-		return UniCopyStr(L"");
-	}
-	else
-	{
-		return UniCopyStr(uni_cmdline);
-	}
-}
-
-// Get the command line string
-char *GetCommandLineStr()
-{
-	if (cmdline == NULL)
-	{
-		return CopyStr("");
-	}
-	else
-	{
-		return CopyStr(cmdline);
-	}
-}
-
-// Set the Unicode command line string
-void SetCommandLineUniStr(wchar_t *str)
-{
-	if (uni_cmdline != NULL)
-	{
-		Free(uni_cmdline);
-	}
-	if (str == NULL)
-	{
-		uni_cmdline = NULL;
-	}
-	else
-	{
-		uni_cmdline = CopyUniStr(str);
-	}
-
-	ParseCommandLineTokens();
-}
-
-// Set the command-line string
-void SetCommandLineStr(char *str)
-{
-	// Validate arguments
-	if (str == NULL)
-	{
-		if (cmdline != NULL)
-		{
-			Free(cmdline);
-		}
-		cmdline = NULL;
-	}
-	else
-	{
-		if (cmdline != NULL)
-		{
-			Free(cmdline);
-		}
-		cmdline = CopyStr(str);
-	}
-
-	if (cmdline == NULL)
-	{
-		if (uni_cmdline != NULL)
-		{
-			Free(uni_cmdline);
-			uni_cmdline = NULL;
-		}
-	}
-	else
-	{
-		if (uni_cmdline != NULL)
-		{
-			Free(uni_cmdline);
-		}
-		uni_cmdline = CopyStrToUni(cmdline);
-	}
-
-	ParseCommandLineTokens();
-}
-
-// Display the kernel status
-void PrintKernelStatus()
-{
-	bool leaked = false;
-
-	Print("\n");
-	Print(
-		"     --------- Mayaqua Kernel Status ---------\n"
-		"        Malloc Count ............... %u\n"
-		"        ReAlloc Count .............. %u\n"
-		"        Free Count ................. %u\n"
-		"        Total Memory Size .......... %I64u bytes\n"
-		"      * Current Memory Blocks ...... %u Blocks (Peek: %u)\n"
-		"        Total Memory Blocks ........ %u Blocks\n"
-		"      * Current MemPool Blocks ..... %u Blocks (Peek: %u)\n"
-		"        Total MemPool Mallocs ...... %u Mallocs\n"
-		"        Total MemPool ReAllocs ..... %u ReAllocs\n"
-		"        NewLock Count .............. %u\n"
-		"        DeleteLock Count ........... %u\n"
-		"      * Current Lock Objects ....... %u Objects\n"
-		"      * Current Locked Objects ..... %u Objects\n"
-		"        NewRef Count ............... %u\n"
-		"        FreeRef Count .............. %u\n"
-		"      * Current Ref Objects ........ %u Objects\n"
-		"      * Current Ref Count .......... %u Refs\n"
-		"        GetTime Count .............. %u\n"
-		"        GetTick Count .............. %u\n"
-		"        NewThread Count ............ %u\n"
-		"        FreeThread Count ........... %u\n"
-		"      * Current Threads ............ %u Threads\n"
-		"        Wait For Event Count ....... %u\n\n",
-		KS_GET(KS_MALLOC_COUNT),
-		KS_GET(KS_REALLOC_COUNT),
-		KS_GET(KS_FREE_COUNT),
-		KS_GET64(KS_TOTAL_MEM_SIZE),
-		KS_GET(KS_CURRENT_MEM_COUNT),
-		KS_GETMAX(KS_CURRENT_MEM_COUNT),
-		KS_GET(KS_TOTAL_MEM_COUNT),
-		KS_GET(KS_MEMPOOL_CURRENT_NUM),
-		KS_GETMAX(KS_MEMPOOL_CURRENT_NUM),
-		KS_GET(KS_MEMPOOL_MALLOC_COUNT),
-		KS_GET(KS_MEMPOOL_REALLOC_COUNT),
-		KS_GET(KS_NEWLOCK_COUNT),
-		KS_GET(KS_DELETELOCK_COUNT),
-		KS_GET(KS_CURRENT_LOCK_COUNT),
-		KS_GET(KS_CURRENT_LOCKED_COUNT),
-		KS_GET(KS_NEWREF_COUNT),
-		KS_GET(KS_FREEREF_COUNT),
-		KS_GET(KS_CURRENT_REF_COUNT),
-		KS_GET(KS_CURRENT_REFED_COUNT),
-		KS_GET(KS_GETTIME_COUNT),
-		KS_GET(KS_GETTICK_COUNT),
-		KS_GET(KS_NEWTHREAD_COUNT),
-		KS_GET(KS_FREETHREAD_COUNT),
-		KS_GET(KS_NEWTHREAD_COUNT) - KS_GET(KS_FREETHREAD_COUNT),
-		KS_GET(KS_WAIT_COUNT)
-		);
-
-	if (KS_GET(KS_CURRENT_MEM_COUNT) != 0 || KS_GET(KS_CURRENT_LOCK_COUNT) != 0 ||
-		KS_GET(KS_MEMPOOL_CURRENT_NUM) != 0 ||
-		KS_GET(KS_CURRENT_LOCKED_COUNT) != 0 || KS_GET(KS_CURRENT_REF_COUNT) != 0)
-	{
-		leaked = true;
-	}
-
-	if (leaked)
-	{
-		Print("      !!! MEMORY LEAKS DETECTED !!!\n\n");
-		if (g_memcheck == false)
-		{
-			if (IsHamMode())
-			{
-				Print("    Enable /memcheck startup option to see the leaking memory heap.\n");
-				Print("    Press Enter key to exit the process.\n");
-			}
-			GetLine(NULL, 0);
-		}
-	}
-	else
-	{
-		Print("        @@@ NO MEMORY LEAKS @@@\n\n");
-	}
-}
-
-// Initialize Kernel status
-void InitKernelStatus()
-{
-	UINT i;
-
-	// Memory initialization
-	Zero(kernel_status, sizeof(kernel_status));
-	Zero(kernel_status_max, sizeof(kernel_status_max));
-
-	// Lock initialization
-	for (i = 0;i < NUM_KERNEL_STATUS;i++)
-	{
-		kernel_status_lock[i] = OSNewLock();
-	}
-
-	kernel_status_inited = true;
-}
-
-// Release of the kernel status
-void FreeKernelStatus()
-{
-	UINT i;
-
-	kernel_status_inited = false;
-
-	// Lock release
-	for (i = 0;i < NUM_KERNEL_STATUS;i++)
-	{
-		OSDeleteLock(kernel_status_lock[i]);
-	}
-}
-
-// Lock the kernel status
-void LockKernelStatus(UINT id)
-{
-	// Validate arguments
-	if (id >= NUM_KERNEL_STATUS)
-	{
-		return;
-	}
-
-	OSLock(kernel_status_lock[id]);
-}
-
-// Unlock the kernel status
-void UnlockKernelStatus(UINT id)
-{
-	// Validate arguments
-	if (id >= NUM_KERNEL_STATUS)
-	{
-		return;
-	}
-
-	OSUnlock(kernel_status_lock[id]);
-}
-
-// Display the debug information
-void PrintDebugInformation()
-{
-	MEMORY_STATUS memory_status;
-	GetMemoryStatus(&memory_status);
-
-	// Header
-	Print("====== " CEDAR_PRODUCT_STR " VPN System Debug Information ======\n");
-
-	// Memory information
-	Print(" <Memory Status>\n"
-		"       Number of Allocated Memory Blocks: %u\n"
-		"   Total Size of Allocated Memory Blocks: %u bytes\n",
-		memory_status.MemoryBlocksNum, memory_status.MemorySize);
-
-	// Footer
-	Print("====================================================\n");
-
-	if (KS_GET(KS_CURRENT_MEM_COUNT) != 0 || KS_GET(KS_CURRENT_LOCK_COUNT) != 0 ||
-		KS_GET(KS_CURRENT_LOCKED_COUNT) != 0 || KS_GET(KS_CURRENT_REF_COUNT) != 0)
-	{
-		// Show a debug menu because memory leaks suspected
-		MemoryDebugMenu();
-	}
-}
-
-
-
-
+// SoftEther VPN Source Code - Developer Edition Master Branch
+// Mayaqua Kernel
+
+
+// Mayaqua.c
+// Mayaqua Kernel program
+
+#include "Mayaqua.h"
+
+#include "Encrypt.h"
+#include "FileIO.h"
+#include "GlobalConst.h"
+#include "Internat.h"
+#include "Memory.h"
+#include "Microsoft.h"
+#include "Network.h"
+#include "Object.h"
+#include "OS.h"
+#include "Secure.h"
+#include "Str.h"
+#include "Table.h"
+#include "Tick64.h"
+#include "Tracking.h"
+
+#include <locale.h>
+#include <stdlib.h>
+#ifdef __ANDROID__
+#include <androidhelpers.h>
+#endif
+
+// Global variable
+bool g_memcheck;								// Enable memory check
+bool g_debug;									// Debug mode
+UINT64 kernel_status[NUM_KERNEL_STATUS];		// Kernel state
+UINT64 kernel_status_max[NUM_KERNEL_STATUS];	// Kernel state (maximum value)
+LOCK *kernel_status_lock[NUM_KERNEL_STATUS];	// Kernel state lock
+bool kernel_status_inited = false;				// Kernel state initialization flag
+bool g_little_endian = true;
+char *cmdline = NULL;							// Command line
+wchar_t *uni_cmdline = NULL;					// Unicode command line
+bool g_foreground = false;					// Execute service in foreground mode
+
+// Static variable
+static char *exename = NULL;						// EXE file name (ANSI)
+static wchar_t *exename_w = NULL;					// EXE file name (Unicode)
+static TOKEN_LIST *cmdline_token = NULL;			// Command line token
+static UNI_TOKEN_LIST *cmdline_uni_token = NULL;	// Command line token (Unicode)
+static OS_INFO *os_info = NULL;						// OS information
+static bool dot_net_mode = false;
+static bool minimal_mode = false;
+static UINT last_time_check = 0;
+static UINT first_time_check = 0;
+static bool is_nt = false;
+static bool is_ham_mode = false;
+static UINT init_mayaqua_counter = 0;
+static bool use_probe = false;
+static BUF *probe_buf = NULL;
+static LOCK *probe_lock = NULL;
+static UINT64 probe_start = 0;
+static UINT64 probe_last = 0;
+static bool probe_enabled = false;
+
+// The function which should be called once as soon as possible after the process is started
+static bool init_proc_once_flag = false;
+void InitProcessCallOnce()
+{
+	if (init_proc_once_flag == false)
+	{
+		init_proc_once_flag = true;
+
+		InitCanaryRand();
+
+#ifdef	OS_WIN32
+		MsInitProcessCallOnce();
+#endif	// OS_WIN32
+	}
+}
+
+// Calculate the checksum
+USHORT CalcChecksum16(void *buf, UINT size)
+{
+	int sum = 0;
+	USHORT *addr = (USHORT *)buf;
+	int len = (int)size;
+	USHORT *w = addr;
+	int nleft = len;
+	USHORT answer = 0;
+
+	while (nleft > 1)
+	{
+		USHORT ww = 0;
+		Copy(&ww, w++, sizeof(USHORT));
+		sum += ww;
+		nleft -= 2;
+	}
+
+	if (nleft == 1)
+	{
+		*(UCHAR *)(&answer) = *(UCHAR *)w;
+		sum += answer;
+	}
+
+	sum = (sum >> 16) + (sum & 0xffff);
+	sum += (sum >> 16);
+
+	answer = ~sum;
+
+	return answer;
+}
+
+// Writing a probe with the data
+void WriteProbeData(char *filename, UINT line, char *str, void *data, UINT size)
+{
+	char tmp[MAX_SIZE];
+	USHORT cs;
+
+	if (IsProbeEnabled() == false)
+	{
+		return;
+	}
+
+	// Take a checksum of the data
+	if (size != 0)
+	{
+		cs = CalcChecksum16(data, size);
+	}
+	else
+	{
+		cs = 0;
+	}
+
+	// Generating a String
+	snprintf(tmp, sizeof(tmp), "\"%s\" (Size=%5u, Crc=0x%04X)", str, size, cs);
+
+	WriteProbe(filename, line, tmp);
+}
+
+// Writing Probe
+void WriteProbe(char *filename, UINT line, char *str)
+{
+#ifdef	OS_WIN32
+	char *s;
+	char tmp[MAX_SIZE];
+	char tmp2[MAX_SIZE];
+	UINT64 now = 0;
+	UINT64 time;
+
+	if (IsProbeEnabled() == false)
+	{
+		return;
+	}
+
+	now = MsGetHiResCounter();
+
+	Lock(probe_lock);
+	{
+		UINT64 diff;
+
+		time = MsGetHiResTimeSpanUSec(now - probe_start);
+
+		diff = time - probe_last;
+
+		if (time < probe_last)
+		{
+			diff = 0;
+		}
+
+		probe_last = time;
+
+		ToStr64(tmp, time);
+		MakeCharArray2(tmp2, ' ', (UINT)(MIN(12, (int)12 - (int)StrLen(tmp))));
+		WriteBuf(probe_buf, tmp2, StrLen(tmp2));
+		WriteBuf(probe_buf, tmp, StrLen(tmp));
+
+		s = " [+";
+		WriteBuf(probe_buf, s, StrLen(s));
+
+		ToStr64(tmp, diff);
+		MakeCharArray2(tmp2, ' ', (UINT)(MIN(12, (int)12 - (int)StrLen(tmp))));
+		WriteBuf(probe_buf, tmp2, StrLen(tmp2));
+		WriteBuf(probe_buf, tmp, StrLen(tmp));
+
+		s = "] - ";
+		WriteBuf(probe_buf, s, StrLen(s));
+
+		WriteBuf(probe_buf, filename, StrLen(filename));
+
+		s = "(";
+		WriteBuf(probe_buf, s, StrLen(s));
+
+		ToStr64(tmp, (UINT64)line);
+		WriteBuf(probe_buf, tmp, StrLen(tmp));
+
+		s = "): ";
+		WriteBuf(probe_buf, s, StrLen(s));
+
+		WriteBuf(probe_buf, str, StrLen(str));
+
+		s = "\r\n";
+		WriteBuf(probe_buf, s, StrLen(s));
+	}
+	Unlock(probe_lock);
+#endif	// OS_WIN32
+}
+
+// Initialization of Probe
+void InitProbe()
+{
+	probe_buf = NewBuf();
+	probe_lock = NewLock();
+	probe_enabled = false;
+
+	probe_start = 0;
+
+#ifdef	OS_WIN32
+	probe_start = MsGetHiResCounter();
+#endif	// OS_WIN32
+}
+
+// Release of Probe
+void FreeProbe()
+{
+	if (probe_buf->Size >= 1)
+	{
+		SYSTEMTIME st;
+		char filename[MAX_SIZE];
+
+		// Write all to the file
+		MakeDirEx("@probe_log");
+
+		LocalTime(&st);
+
+		snprintf(filename, sizeof(filename), "@probe_log/%04u%02u%02u_%02u%02u%02u.log",
+			st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
+
+		DumpBuf(probe_buf, filename);
+	}
+
+	FreeBuf(probe_buf);
+	DeleteLock(probe_lock);
+}
+
+// Set enable / disable the Probe
+void EnableProbe(bool enable)
+{
+	probe_enabled = enable;
+}
+
+// Get whether the Probe is enabled?
+bool IsProbeEnabled()
+{
+#ifndef	USE_PROBE
+	return false;
+#else	// USE_PROBE
+	return probe_enabled;
+#endif	// USE_PROBE
+}
+
+// Set the Ham mode
+void SetHamMode()
+{
+	is_ham_mode = true;
+}
+
+// Get whether in Ham mode
+bool IsHamMode()
+{
+	return is_ham_mode;
+}
+
+// Display the time from the previous call to now
+void TimeCheck()
+{
+#ifdef OS_WIN32
+	UINT now, ret, total;
+	now = Win32GetTick();
+	if (last_time_check == 0)
+	{
+		ret = 0;
+	}
+	else
+	{
+		ret = now - last_time_check;
+	}
+	last_time_check = now;
+
+	if (first_time_check == 0)
+	{
+		first_time_check = now;
+	}
+
+	total = now - first_time_check;
+
+	printf(" -- %3.3f / %3.3f\n", (double)ret / 1000.0f, (double)total / 1000.0f);
+#endif	// OS_WIN32
+}
+
+// Whether this system is IA64
+bool IsIA64()
+{
+	if (Is64() == false)
+	{
+		return false;
+	}
+
+#ifndef	MAYAQUA_IA_64
+	return false;
+#else	// MAYAQUA_IA_64
+	return true;
+#endif	// MAYAQUA_IA_64
+}
+
+// Whether in x64
+bool IsX64()
+{
+	if (Is64() == false)
+	{
+		return false;
+	}
+
+#ifndef	MAYAQUA_IA_64
+	return true;
+#else	// MAYAQUA_IA_64
+	return false;
+#endif	// MAYAQUA_IA_64
+}
+
+// Whether 64bit
+bool Is64()
+{
+#ifdef	CPU_64
+	return true;
+#else	// CPU_64
+	return false;
+#endif	// CPU_64
+}
+
+// Whether 32bit
+bool Is32()
+{
+	return Is64() ? false : true;
+}
+
+// Acquisition whether in .NET mode
+bool MayaquaIsDotNetMode()
+{
+	return dot_net_mode;
+}
+
+// Check the endian
+void CheckEndian()
+{
+	unsigned short test;
+	UCHAR *buf;
+
+	test = 0x1234;
+	buf = (UCHAR *)&test;
+	if (buf[0] == 0x12)
+	{
+		g_little_endian = false;
+	}
+	else
+	{
+		g_little_endian = true;
+	}
+}
+
+// Minimize mode
+void MayaquaMinimalMode()
+{
+	minimal_mode = true;
+}
+bool MayaquaIsMinimalMode()
+{
+	return minimal_mode;
+}
+
+// Whether in NT
+bool IsNt()
+{
+	return is_nt;
+}
+
+// Initialization of Mayaqua library
+void InitMayaqua(bool memcheck, bool debug, int argc, char **argv)
+{
+	wchar_t tmp[MAX_PATH];
+	UCHAR hash[SHA1_SIZE];
+
+	if ((init_mayaqua_counter++) > 0)
+	{
+		return;
+	}
+
+	InitProcessCallOnce();
+
+	g_memcheck = memcheck;
+	g_debug = debug;
+	cmdline = NULL;
+	if (dot_net_mode == false)
+	{
+		// Fail this for some reason when this is called this in .NET mode
+		setbuf(stdout, NULL);
+	}
+
+#ifdef OS_UNIX
+	g_foreground = (argc >= 3 && StrCmpi(argv[2], UNIX_SVC_ARG_FOREGROUND) == 0);
+#else
+	g_foreground = false;
+#endif // OS_UNIX
+
+	// Acquisition whether NT
+#ifdef	OS_WIN32
+	is_nt = Win32IsNt();
+#endif	// OS_WIN32
+
+	// Check endian
+	CheckEndian();
+
+#ifdef	OS_WIN32
+	_configthreadlocale(_DISABLE_PER_THREAD_LOCALE);
+#endif	// OS_WIN32
+
+	// Set the locale information of the CRT to the Japanese
+	setlocale(LC_ALL, "");
+
+	// Initialization of OS
+	OSInit();
+
+	// Initialize the random number
+	srand((UINT)SystemTime64());
+
+	tick_manual_lock = NewLock();
+
+	// Initialization of CRC32
+	InitCrc32();
+
+	// Initialization of the FIFO system
+	InitFifo();
+
+	// Initialize the Kernel status
+	InitKernelStatus();
+
+	if (IsTrackingEnabled())
+	{
+		// Initialize the tracking
+		InitTracking();
+	}
+
+	// Initialization of thread pool
+	InitThreading();
+
+	// Initialize the string library
+	InitStringLibrary();
+
+	// Initialization of the locale information
+	SetLocale(NULL);
+
+	// Initialization of the crypt library
+	InitCryptLibrary();
+
+	// Initialization of the real-time clock
+	InitTick64();
+
+	// Initialize the network communication module
+	InitNetwork();
+
+	// Initialization of the acquisition of the EXE file name
+	InitGetExeName(argc >= 1 ? argv[0] : NULL);
+
+	// Initialization of the command line string
+	InitCommandLineStr(argc, argv);
+
+	// Initialization of OS information
+	InitOsInfo();
+
+	// Initialization of the operating system-specific module
+#ifdef	OS_WIN32
+	MsInit();	// Microsoft Win32
+#endif	// OS_WIN32
+
+	// Initialization of the security token module
+	InitSecure();
+
+	if (OSIsSupportedOs() == false)
+	{
+		// Abort
+		exit(0);
+	}
+
+	// RSA Check
+	if (RsaCheckEx() == false)
+	{
+		// Abort
+		Alert("OpenSSL Library Init Failed. (too old?)\nPlease install the latest version of OpenSSL.\n\n", "RsaCheck()");
+		exit(0);
+	}
+
+	// Initialization of HamCore file system
+	InitHamcore();
+
+	// Initialization of string table routine
+	InitTable();
+
+	if (exename == NULL)
+	{
+		// Executable file name
+		exename = CopyStr("unknown");
+	}
+
+	// Check whether the executable file name of themselves is found
+	// (If not found, quit because this is started in strange path)
+	GetExeNameW(tmp, sizeof(tmp));
+	if (IsFileExistsW(tmp) == false)
+	{
+		wchar_t tmp2[MAX_SIZE];
+
+		UniFormat(tmp2, sizeof(tmp2),
+			L"Error: Executable binary file \"%s\" not found.\r\n\r\n"
+			L"Please execute program with full path.\r\n",
+			tmp);
+
+		AlertW(tmp2, NULL);
+		_exit(0);
+	}
+
+	CheckUnixTempDir();
+
+	// Initialization of Probe
+	InitProbe();
+
+	// Initialization of Machine Hash
+	GetCurrentMachineIpProcessHash(hash);
+
+	// Reading Private IP file
+	LoadPrivateIPFile();
+}
+
+// Release of Mayaqua library
+void FreeMayaqua()
+{
+	if ((--init_mayaqua_counter) > 0)
+	{
+		return;
+	}
+
+	// Release of Private IP File
+	FreePrivateIPFile();
+
+	// Release of Probe
+	FreeProbe();
+
+	// Delete the table
+	FreeTable();
+
+	// Release of security token module
+	FreeSecure();
+
+	// Release of the operating system specific module
+#ifdef	OS_WIN32
+	MsFree();
+#endif	// OS_WIN32
+
+	// Release of OS information
+	FreeOsInfo();
+
+	// Release of HamCore file system
+	FreeHamcore();
+
+	// Release of the command line string
+	FreeCommandLineStr();
+
+	// Release of the command line token
+	FreeCommandLineTokens();
+
+	// Release of network communication module
+	FreeNetwork();
+
+	// Release of real-time clock
+	FreeTick64();
+
+	// Release of the string library
+	FreeStringLibrary();
+
+	// Release of thread pool
+	FreeThreading();
+
+	// Release of crypt library
+	FreeCryptLibrary();
+
+	if (IsTrackingEnabled())
+	{
+		// Show the kernel status
+		if (g_debug)
+		{
+			PrintKernelStatus();
+		}
+
+		// Display the debug information
+		if (g_memcheck)
+		{
+			PrintDebugInformation();
+		}
+
+		// Release the tracking
+		FreeTracking();
+	}
+
+	// Release of the kernel status
+	FreeKernelStatus();
+
+	DeleteLock(tick_manual_lock);
+	tick_manual_lock = NULL;
+
+	// Release of OS
+	OSFree();
+}
+
+// Check whether /tmp is available in the UNIX
+void CheckUnixTempDir()
+{
+	if (OS_IS_UNIX(GetOsInfo()->OsType))
+	{
+		char tmp[128], tmp2[64];
+		UINT64 now = SystemTime64();
+		IO *o;
+
+		#ifdef __ANDROID__
+		char* tmpDir = GetAndroidTmpDir();
+		#else
+		char* tmpDir = "/tmp";
+		#endif
+
+		Format(tmp2, sizeof(tmp2), "%I64u", now);
+
+		Format(tmp, sizeof(tmp), "%s/.%s", tmpDir, tmp2);
+
+		o = FileCreate(tmp);
+		if (o == NULL)
+		{
+			o = FileOpen(tmp, false);
+			if (o == NULL)
+			{
+				Print("Unable to use temporary dir: (%s).\n\n", tmpDir);
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		FileClose(o);
+
+		FileDelete(tmp);
+		#ifdef __ANDROID__
+		free(tmpDir);
+		#endif
+	}
+}
+
+// Show an alert
+void Alert(char *msg, char *caption)
+{
+	OSAlert(msg, caption);
+}
+void AlertW(wchar_t *msg, wchar_t *caption)
+{
+	OSAlertW(msg, caption);
+}
+
+// Get the OS type
+UINT GetOsType()
+{
+	OS_INFO *i = GetOsInfo();
+
+	if (i == NULL)
+	{
+		return 0;
+	}
+
+	return i->OsType;
+}
+
+// Getting OS information
+OS_INFO *GetOsInfo()
+{
+	return os_info;
+}
+
+// Initialization of OS information
+void InitOsInfo()
+{
+	if (os_info != NULL)
+	{
+		return;
+	}
+
+	os_info = ZeroMalloc(sizeof(OS_INFO));
+
+	OSGetOsInfo(os_info);
+}
+
+// Release of OS information
+void FreeOsInfo()
+{
+	if (os_info == NULL)
+	{
+		return;
+	}
+
+	Free(os_info->OsSystemName);
+	Free(os_info->OsProductName);
+	Free(os_info->OsVendorName);
+	Free(os_info->OsVersion);
+	Free(os_info->KernelName);
+	Free(os_info->KernelVersion);
+	Free(os_info);
+
+	os_info = NULL;
+}
+
+// Get the Unicode command line tokens
+UNI_TOKEN_LIST *GetCommandLineUniToken()
+{
+	if (cmdline_uni_token == NULL)
+	{
+		return UniNullToken();
+	}
+	else
+	{
+		return UniCopyToken(cmdline_uni_token);
+	}
+}
+
+// Getting the command line tokens
+TOKEN_LIST *GetCommandLineToken()
+{
+	if (cmdline_token == NULL)
+	{
+		return NullToken();
+	}
+	else
+	{
+		return CopyToken(cmdline_token);
+	}
+}
+
+// Convert the command line string into tokens
+void ParseCommandLineTokens()
+{
+	if (cmdline_token != NULL)
+	{
+		FreeToken(cmdline_token);
+	}
+	cmdline_token = ParseCmdLine(cmdline);
+
+	if (cmdline_uni_token != NULL)
+	{
+		UniFreeToken(cmdline_uni_token);
+	}
+	cmdline_uni_token = UniParseCmdLine(uni_cmdline);
+}
+
+// Release command line tokens
+void FreeCommandLineTokens()
+{
+	if (cmdline_token != NULL)
+	{
+		FreeToken(cmdline_token);
+	}
+	cmdline_token = NULL;
+
+	if (cmdline_uni_token != NULL)
+	{
+		UniFreeToken(cmdline_uni_token);
+	}
+	cmdline_uni_token = NULL;
+}
+
+// Initialization of the command line string
+void InitCommandLineStr(int argc, char **argv)
+{
+	if (argc >= 1)
+	{
+#ifdef	OS_UNIX
+		exename_w = CopyUtfToUni(argv[0]);
+		exename = CopyUniToStr(exename_w);
+#else	// OS_UNIX
+		exename = CopyStr(argv[0]);
+		exename_w = CopyStrToUni(exename);
+#endif	// OS_UNIX
+	}
+	if (argc < 2 || argv == NULL)
+	{
+		// No command-line string
+		SetCommandLineStr(NULL);
+	}
+	else
+	{
+		// There are command-line string
+		int i, total_len = 1;
+		char *tmp;
+
+		for (i = 1;i < argc;i++)
+		{
+			total_len += StrLen(argv[i]) * 2 + 32;
+		}
+		tmp = ZeroMalloc(total_len);
+
+		for (i = 1;i < argc;i++)
+		{
+			UINT s_size = StrLen(argv[i]) * 2;
+			char *s = ZeroMalloc(s_size);
+			bool dq = (SearchStrEx(argv[i], " ", 0, true) != INFINITE);
+			ReplaceStrEx(s, s_size, argv[i], "\"", "\"\"", true);
+			if (dq)
+			{
+				StrCat(tmp, total_len, "\"");
+			}
+			StrCat(tmp, total_len, s);
+			if (dq)
+			{
+				StrCat(tmp, total_len, "\"");
+			}
+			StrCat(tmp, total_len, " ");
+			Free(s);
+		}
+
+		Trim(tmp);
+		SetCommandLineStr(tmp);
+		Free(tmp);
+	}
+}
+
+// Release of the command line string
+void FreeCommandLineStr()
+{
+	SetCommandLineStr(NULL);
+
+	if (exename != NULL)
+	{
+		Free(exename);
+		exename = NULL;
+	}
+
+	if (exename_w != NULL)
+	{
+		Free(exename_w);
+		exename_w = NULL;
+	}
+}
+
+// Get the Unicode command line string
+wchar_t *GetCommandLineUniStr()
+{
+	if (uni_cmdline == NULL)
+	{
+		return UniCopyStr(L"");
+	}
+	else
+	{
+		return UniCopyStr(uni_cmdline);
+	}
+}
+
+// Get the command line string
+char *GetCommandLineStr()
+{
+	if (cmdline == NULL)
+	{
+		return CopyStr("");
+	}
+	else
+	{
+		return CopyStr(cmdline);
+	}
+}
+
+// Set the Unicode command line string
+void SetCommandLineUniStr(wchar_t *str)
+{
+	if (uni_cmdline != NULL)
+	{
+		Free(uni_cmdline);
+	}
+	if (str == NULL)
+	{
+		uni_cmdline = NULL;
+	}
+	else
+	{
+		uni_cmdline = CopyUniStr(str);
+	}
+
+	ParseCommandLineTokens();
+}
+
+// Set the command-line string
+void SetCommandLineStr(char *str)
+{
+	// Validate arguments
+	if (str == NULL)
+	{
+		if (cmdline != NULL)
+		{
+			Free(cmdline);
+		}
+		cmdline = NULL;
+	}
+	else
+	{
+		if (cmdline != NULL)
+		{
+			Free(cmdline);
+		}
+		cmdline = CopyStr(str);
+	}
+
+	if (cmdline == NULL)
+	{
+		if (uni_cmdline != NULL)
+		{
+			Free(uni_cmdline);
+			uni_cmdline = NULL;
+		}
+	}
+	else
+	{
+		if (uni_cmdline != NULL)
+		{
+			Free(uni_cmdline);
+		}
+		uni_cmdline = CopyStrToUni(cmdline);
+	}
+
+	ParseCommandLineTokens();
+}
+
+// Display the kernel status
+void PrintKernelStatus()
+{
+	bool leaked = false;
+
+	Print("\n");
+	Print(
+		"     --------- Mayaqua Kernel Status ---------\n"
+		"        Malloc Count ............... %u\n"
+		"        ReAlloc Count .............. %u\n"
+		"        Free Count ................. %u\n"
+		"        Total Memory Size .......... %I64u bytes\n"
+		"      * Current Memory Blocks ...... %u Blocks (Peek: %u)\n"
+		"        Total Memory Blocks ........ %u Blocks\n"
+		"      * Current MemPool Blocks ..... %u Blocks (Peek: %u)\n"
+		"        Total MemPool Mallocs ...... %u Mallocs\n"
+		"        Total MemPool ReAllocs ..... %u ReAllocs\n"
+		"        NewLock Count .............. %u\n"
+		"        DeleteLock Count ........... %u\n"
+		"      * Current Lock Objects ....... %u Objects\n"
+		"      * Current Locked Objects ..... %u Objects\n"
+		"        NewRef Count ............... %u\n"
+		"        FreeRef Count .............. %u\n"
+		"      * Current Ref Objects ........ %u Objects\n"
+		"      * Current Ref Count .......... %u Refs\n"
+		"        GetTime Count .............. %u\n"
+		"        GetTick Count .............. %u\n"
+		"        NewThread Count ............ %u\n"
+		"        FreeThread Count ........... %u\n"
+		"      * Current Threads ............ %u Threads\n"
+		"        Wait For Event Count ....... %u\n\n",
+		KS_GET(KS_MALLOC_COUNT),
+		KS_GET(KS_REALLOC_COUNT),
+		KS_GET(KS_FREE_COUNT),
+		KS_GET64(KS_TOTAL_MEM_SIZE),
+		KS_GET(KS_CURRENT_MEM_COUNT),
+		KS_GETMAX(KS_CURRENT_MEM_COUNT),
+		KS_GET(KS_TOTAL_MEM_COUNT),
+		KS_GET(KS_MEMPOOL_CURRENT_NUM),
+		KS_GETMAX(KS_MEMPOOL_CURRENT_NUM),
+		KS_GET(KS_MEMPOOL_MALLOC_COUNT),
+		KS_GET(KS_MEMPOOL_REALLOC_COUNT),
+		KS_GET(KS_NEWLOCK_COUNT),
+		KS_GET(KS_DELETELOCK_COUNT),
+		KS_GET(KS_CURRENT_LOCK_COUNT),
+		KS_GET(KS_CURRENT_LOCKED_COUNT),
+		KS_GET(KS_NEWREF_COUNT),
+		KS_GET(KS_FREEREF_COUNT),
+		KS_GET(KS_CURRENT_REF_COUNT),
+		KS_GET(KS_CURRENT_REFED_COUNT),
+		KS_GET(KS_GETTIME_COUNT),
+		KS_GET(KS_GETTICK_COUNT),
+		KS_GET(KS_NEWTHREAD_COUNT),
+		KS_GET(KS_FREETHREAD_COUNT),
+		KS_GET(KS_NEWTHREAD_COUNT) - KS_GET(KS_FREETHREAD_COUNT),
+		KS_GET(KS_WAIT_COUNT)
+		);
+
+	if (KS_GET(KS_CURRENT_MEM_COUNT) != 0 || KS_GET(KS_CURRENT_LOCK_COUNT) != 0 ||
+		KS_GET(KS_MEMPOOL_CURRENT_NUM) != 0 ||
+		KS_GET(KS_CURRENT_LOCKED_COUNT) != 0 || KS_GET(KS_CURRENT_REF_COUNT) != 0)
+	{
+		leaked = true;
+	}
+
+	if (leaked)
+	{
+		Print("      !!! MEMORY LEAKS DETECTED !!!\n\n");
+		if (g_memcheck == false)
+		{
+			if (IsHamMode())
+			{
+				Print("    Enable /memcheck startup option to see the leaking memory heap.\n");
+				Print("    Press Enter key to exit the process.\n");
+			}
+			GetLine(NULL, 0);
+		}
+	}
+	else
+	{
+		Print("        @@@ NO MEMORY LEAKS @@@\n\n");
+	}
+}
+
+// Initialize Kernel status
+void InitKernelStatus()
+{
+	UINT i;
+
+	// Memory initialization
+	Zero(kernel_status, sizeof(kernel_status));
+	Zero(kernel_status_max, sizeof(kernel_status_max));
+
+	// Lock initialization
+	for (i = 0;i < NUM_KERNEL_STATUS;i++)
+	{
+		kernel_status_lock[i] = OSNewLock();
+	}
+
+	kernel_status_inited = true;
+}
+
+// Release of the kernel status
+void FreeKernelStatus()
+{
+	UINT i;
+
+	kernel_status_inited = false;
+
+	// Lock release
+	for (i = 0;i < NUM_KERNEL_STATUS;i++)
+	{
+		OSDeleteLock(kernel_status_lock[i]);
+	}
+}
+
+// Lock the kernel status
+void LockKernelStatus(UINT id)
+{
+	// Validate arguments
+	if (id >= NUM_KERNEL_STATUS)
+	{
+		return;
+	}
+
+	OSLock(kernel_status_lock[id]);
+}
+
+// Unlock the kernel status
+void UnlockKernelStatus(UINT id)
+{
+	// Validate arguments
+	if (id >= NUM_KERNEL_STATUS)
+	{
+		return;
+	}
+
+	OSUnlock(kernel_status_lock[id]);
+}
+
+// Display the debug information
+void PrintDebugInformation()
+{
+	MEMORY_STATUS memory_status;
+	GetMemoryStatus(&memory_status);
+
+	// Header
+	Print("====== " CEDAR_PRODUCT_STR " VPN System Debug Information ======\n");
+
+	// Memory information
+	Print(" <Memory Status>\n"
+		"       Number of Allocated Memory Blocks: %u\n"
+		"   Total Size of Allocated Memory Blocks: %u bytes\n",
+		memory_status.MemoryBlocksNum, memory_status.MemorySize);
+
+	// Footer
+	Print("====================================================\n");
+
+	if (KS_GET(KS_CURRENT_MEM_COUNT) != 0 || KS_GET(KS_CURRENT_LOCK_COUNT) != 0 ||
+		KS_GET(KS_CURRENT_LOCKED_COUNT) != 0 || KS_GET(KS_CURRENT_REF_COUNT) != 0)
+	{
+		// Show a debug menu because memory leaks suspected
+		MemoryDebugMenu();
+	}
+}
diff --git a/src/Mayaqua/Unix.c b/src/Mayaqua/Unix.c
index 0c3778d..f309dd4 100755
--- a/src/Mayaqua/Unix.c
+++ b/src/Mayaqua/Unix.c
@@ -1,2853 +1,2864 @@
-// SoftEther VPN Source Code - Developer Edition Master Branch
-// Mayaqua Kernel
-
-
-// Unix.c
-// UNIX dependent code
-
-#ifdef	OS_UNIX
-
-#include "Unix.h"
-
-#include "Cfg.h"
-#include "FileIO.h"
-#include "GlobalConst.h"
-#include "Internat.h"
-#include "Kernel.h"
-#include "Mayaqua.h"
-#include "Memory.h"
-#include "Network.h"
-#include "Object.h"
-#include "Str.h"
-#include "Table.h"
-#include "Tick64.h"
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <dirent.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <pthread.h>
-#include <signal.h>
-
-#include <sys/mount.h>
-#include <sys/param.h>
-#include <sys/resource.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/utsname.h>
-#include <sys/wait.h>
-
-#ifdef UNIX_LINUX
-#include <sys/statfs.h>
-#endif
-
-#ifdef UNIX_SOLARIS
-#define USE_STATVFS
-#include <sys/statvfs.h>
-#endif
-
-#ifdef	UNIX_MACOS
-#ifdef	NO_VLAN
-// Struct statfs for MacOS X
-typedef struct fsid { int32_t val[2]; } fsid_t;
-struct statfs {
-        short   f_otype;                /* TEMPORARY SHADOW COPY OF f_type */
-        short   f_oflags;               /* TEMPORARY SHADOW COPY OF f_flags */
-        long    f_bsize;                /* fundamental file system block size */
-        long    f_iosize;               /* optimal transfer block size */
-        long    f_blocks;               /* total data blocks in file system */
-        long    f_bfree;                /* free blocks in fs */
-        long    f_bavail;               /* free blocks avail to non-superuser */
-        long    f_files;                /* total file nodes in file system */
-        long    f_ffree;                /* free file nodes in fs */
-        fsid_t  f_fsid;                 /* file system id */
-        uid_t   f_owner;                /* user that mounted the filesystem */
-        short   f_reserved1;    /* spare for later */
-        short   f_type;                 /* type of filesystem */
-    long        f_flags;                /* copy of mount exported flags */
-        long    f_reserved2[2]; /* reserved for future use */
-        char    f_fstypename[15]; /* fs type name */
-        char    f_mntonname[90];  /* directory on which mounted */
-        char    f_mntfromname[90];/* mounted filesystem */
-};
-#else	// NO_VLAN
-#include <sys/mount.h>
-#endif	// NO_VLAN
-#endif	// UNIX_MACOS
-
-// Scandir() function for Solaris
-#ifdef	UNIX_SOLARIS
-#define scandir local_scandir
-#define	alphasort local_alphasort
-
-int local_scandir(const char *dir, struct dirent ***namelist,
-            int (*select)(const struct dirent *),
-            int (*compar)(const struct dirent **, const struct dirent **))
-{
-  DIR *d;
-  struct dirent *entry;
-  register int i=0;
-  size_t entrysize;
-
-  if ((d=opendir(dir)) == NULL)
-     return(-1);
-
-  *namelist=NULL;
-  while ((entry=readdir(d)) != NULL)
-  {
-    if (select == NULL || (*select)(entry))
-    {
-      *namelist=(struct dirent **)realloc((void *)(*namelist),
-                 (size_t)((i+1)*sizeof(struct dirent *)));
-	if (*namelist == NULL) return(-1);
-	entrysize=sizeof(struct dirent)-sizeof(entry->d_name)+strlen(entry->d_name)+1;
-	(*namelist)[i]=(struct dirent *)malloc(entrysize);
-	if ((*namelist)[i] == NULL) return(-1);
-	memcpy((*namelist)[i], entry, entrysize);
-	i++;
-    }
-  }
-  if (closedir(d)) return(-1);
-  if (i == 0) return(-1);
-  if (compar != NULL)
-    qsort((void *)(*namelist), (size_t)i, sizeof(struct dirent *), compar);
-    
-  return(i);
-}
-
-int local_alphasort(const struct dirent **a, const struct dirent **b)
-{
-  return(strcmp((*a)->d_name, (*b)->d_name));
-}
-
-
-#endif	// UNIX_SOLARIS
-
-// Thread data for UNIX
-typedef struct UNIXTHREAD
-{
-	pthread_t thread;
-	bool finished;
-} UNIXTHREAD;
-
-// Thread startup information for UNIX
-typedef struct UNIXTHREADSTARTUPINFO
-{
-	THREAD_PROC *thread_proc;
-	void *param;
-	THREAD *thread;
-} UNIXTHREADSTARTUPINFO;
-
-// Thread function prototype for UNIX
-void *UnixDefaultThreadProc(void *param);
-
-// Current process ID
-static pid_t current_process_id = 0;
-
-// File I/O data for UNIX
-typedef struct UNIXIO
-{
-	int fd;
-	bool write_mode;
-} UNIXIO;
-
-// Lock file data for UNIX
-typedef struct UNIXLOCKFILE
-{
-	char FileName[MAX_SIZE];
-	int fd;
-} UNIXLOCKFILE;
-
-// Event data for UNIX
-typedef struct UNIXEVENT
-{
-	pthread_mutex_t mutex;
-	pthread_cond_t cond;
-	bool signal;
-} UNIXEVENT;
-
-static pthread_mutex_t get_time_lock;
-static pthread_mutex_t malloc_lock;
-static bool high_process = false;
-
-static bool unix_svc_terminate = false;
-static int solaris_sleep_p1 = -1, solaris_sleep_p2 = -1;
-
-// Create a dispatch table
-OS_DISPATCH_TABLE *UnixGetDispatchTable()
-{
-	static OS_DISPATCH_TABLE t =
-	{
-		UnixInit,
-		UnixFree,
-		UnixMemoryAlloc,
-		UnixMemoryReAlloc,
-		UnixMemoryFree,
-		UnixGetTick,
-		UnixGetSystemTime,
-		UnixInc32,
-		UnixDec32,
-		UnixSleep,
-		UnixNewLock,
-		UnixLock,
-		UnixUnlock,
-		UnixDeleteLock,
-		UnixInitEvent,
-		UnixSetEvent,
-		UnixResetEvent,
-		UnixWaitEvent,
-		UnixFreeEvent,
-		UnixWaitThread,
-		UnixFreeThread,
-		UnixInitThread,
-		UnixThreadId,
-		UnixFileOpen,
-		UnixFileOpenW,
-		UnixFileCreate,
-		UnixFileCreateW,
-		UnixFileWrite,
-		UnixFileRead,
-		UnixFileClose,
-		UnixFileFlush,
-		UnixFileSize,
-		UnixFileSeek,
-		UnixFileDelete,
-		UnixFileDeleteW,
-		UnixMakeDir,
-		UnixMakeDirW,
-		UnixDeleteDir,
-		UnixDeleteDirW,
-		UnixGetCallStack,
-		UnixGetCallStackSymbolInfo,
-		UnixFileRename,
-		UnixFileRenameW,
-		UnixRun,
-		UnixRunW,
-		UnixIsSupportedOs,
-		UnixGetOsInfo,
-		UnixAlert,
-		UnixAlertW,
-		UnixGetProductId,
-		UnixSetHighPriority,
-		UnixRestorePriority,
-		UnixNewSingleInstance,
-		UnixFreeSingleInstance,
-		UnixGetMemInfo,
-		UnixYield,
-	};
-
-	return &t;
-}
-
-static void signal_received_for_ignore(int sig, siginfo_t *info, void *ucontext)
-{
-	(void)sig;
-	(void)info;
-	(void)ucontext;
-}
-
-// Ignore the signal flew to the thread
-void UnixIgnoreSignalForThread(int sig)
-{
-	struct sigaction sa;
-
-	Zero(&sa, sizeof(sa));
-	sa.sa_handler = NULL;
-	sa.sa_sigaction = &signal_received_for_ignore;
-	sa.sa_flags = SA_SIGINFO;
-
-	sigemptyset(&sa.sa_mask);
-
-	sigaction(SIGUSR1, &sa, NULL);
-}
-
-// Disable the off-loading function of the specific Ethernet device
-void UnixDisableInterfaceOffload(char *name)
-{
-#ifdef	UNIX_LINUX
-	char tmp[MAX_SIZE];
-	TOKEN_LIST *t;
-	char *names = "rx tx sg tso ufo gso gro lro rxvlan txvlan ntuple rxhash";
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	t = ParseToken(names, " ");
-
-	if (t != NULL)
-	{
-		UINT i;
-		for (i = 0;i < t->NumTokens;i++)
-		{
-			char *a = t->Token[i];
-
-			Format(tmp, sizeof(tmp), "ethtool -K %s %s off 2>/dev/null", name, a);
-			FreeToken(UnixExec(tmp));
-		}
-	}
-
-	FreeToken(t);
-#endif	// UNIX_LINUX
-}
-
-// Validate whether the Linux/FreeBSD is running in a VM
-// Not implemented yet on other OS
-bool UnixIsInVmMain()
-{
-	TOKEN_LIST *t = NULL;
-	bool ret = false;
-#if defined(UNIX_LINUX)
-	char *vm_str_list = "Hypervisor detected,VMware Virtual Platform,VMware Virtual USB,qemu,xen,paravirtualized,virtual hd,virtualhd,virtual pc,virtualpc,kvm,oracle vm,oraclevm,parallels,xvm,bochs";
-#elif defined(__FreeBSD__)
-	char *vm_str_list = "generic,xen,hv,vmware,kvm,bhyve";
-#endif
-
-#if defined(UNIX_LINUX)
-	t = UnixExec("/bin/dmesg");
-#elif defined(__FreeBSD__)
-	t = UnixExec("/sbin/sysctl -n kern.vm_guest");
-#endif
-
-#if defined(UNIX_LINUX) || defined(__FreeBSD__)
-	if (t != NULL)
-	{
-		BUF *b = NewBuf();
-		UINT i;
-
-		for (i = 0;i < t->NumTokens;i++)
-		{
-			char *line = t->Token[i];
-
-			AddBufStr(b, line);
-			AddBufStr(b, " ");
-		}
-
-		WriteBufInt(b, 0);
-
-//		printf("%s\n", b->Buf);
-
-		ret = InStrList(b->Buf, vm_str_list, ",", false);
-
-		FreeBuf(b);
-		FreeToken(t);
-	}
-#endif // defined(UNIX_LINUX) || defined(__FreeBSD)
-
-	return ret;
-}
-
-bool UnixIsInVm()
-{
-	static bool is_in_vm_flag = false;
-	static bool is_in_vm_ret = false;
-
-	if (is_in_vm_flag == false)
-	{
-		is_in_vm_ret = UnixIsInVmMain();
-		is_in_vm_flag = true;
-	}
-
-	return is_in_vm_ret;
-}
-
-// Run quietly in the UNIX
-void UnixExecSilent(char *cmd)
-{
-	char tmp[MAX_SIZE];
-	// Validate arguments
-	if (cmd == NULL)
-	{
-		return;
-	}
-
-	Format(tmp, sizeof(tmp), "%s 2>/dev/null", cmd);
-
-	FreeToken(UnixExec(tmp));
-}
-
-// Enable / disable the ESP processing in the kernel
-void UnixSetEnableKernelEspProcessing(bool b)
-{
-	if (GetOsInfo()->OsType == OSTYPE_MACOS_X)
-	{
-		// Mac OS X
-		if (b)
-		{
-			UnixExecSilent("/usr/sbin/sysctl -w net.inet.ipsec.esp_port=4500");
-		}
-		else
-		{
-			UnixExecSilent("/usr/sbin/sysctl -w net.inet.ipsec.esp_port=4501");
-		}
-	}
-}
-
-// Run a command and return its result
-TOKEN_LIST *UnixExec(char *cmd)
-{
-	FILE *fp;
-	char tmp[MAX_SIZE];
-	char *ptr;
-	LIST *o;
-	UINT i;
-	TOKEN_LIST *ret;
-	// Validate arguments
-	if (cmd == NULL)
-	{
-		return NULL;
-	}
-
-	fp = popen(cmd, "r");
-	if (fp == NULL)
-	{
-		return NULL;
-	}
-
-	o = NewList(NULL);
-
-	while (true)
-	{
-		fgets(tmp, sizeof(tmp), fp);
-		if (feof(fp))
-		{
-			break;
-		}
-
-		ptr = strchr(tmp, '\n');
-		if (ptr != NULL)
-		{
-			*ptr = 0;
-		}
-
-		ptr = strchr(tmp, '\r');
-		if (ptr != NULL)
-		{
-			*ptr = 0;
-		}
-
-		Add(o, CopyStr(tmp));
-	}
-
-	pclose(fp);
-
-	ret = ListToTokenList(o);
-
-	FreeStrList(o);
-
-	return ret;
-}
-
-// Initialize the Sleep for Solaris
-void UnixInitSolarisSleep()
-{
-	char tmp[MAX_SIZE];
-
-	UnixNewPipe(&solaris_sleep_p1, &solaris_sleep_p2);
-	(void)read(solaris_sleep_p1, tmp, sizeof(tmp));
-}
-
-// Release the Sleep for Solaris
-void UnixFreeSolarisSleep()
-{
-	UnixDeletePipe(solaris_sleep_p1, solaris_sleep_p2);
-	solaris_sleep_p1 = -1;
-	solaris_sleep_p2 = -1;
-}
-
-// Sleep for Solaris
-void UnixSolarisSleep(UINT msec)
-{
-	struct pollfd p;
-
-	memset(&p, 0, sizeof(p));
-	p.fd = solaris_sleep_p1;
-	p.events = POLLIN;
-
-	(void)poll(&p, 1, msec == INFINITE ? -1 : (int)msec);
-}
-
-// Get the free space of the disk
-bool UnixGetDiskFree(char *path, UINT64 *free_size, UINT64 *used_size, UINT64 *total_size)
-{
-	char tmp[MAX_PATH];
-	bool ret = false;
-	// Validate arguments
-	if (path == NULL)
-	{
-		return false;
-	}
-
-	NormalizePath(tmp, sizeof(tmp), path);
-
-	while ((ret = UnixGetDiskFreeMain(tmp, free_size, used_size, total_size)) == false)
-	{
-		if (StrCmpi(tmp, "/") == 0)
-		{
-			break;
-		}
-
-		GetDirNameFromFilePath(tmp, sizeof(tmp), tmp);
-	}
-
-	return ret;
-}
-bool UnixGetDiskFreeMain(char *path, UINT64 *free_size, UINT64 *used_size, UINT64 *total_size)
-{
-#ifndef	USE_STATVFS
-	struct statfs st;
-	char tmp[MAX_PATH];
-	UINT64 v1 = 0, v2 = 0;
-	bool ret = false;
-	// Validate arguments
-	if (path == NULL)
-	{
-		return false;
-	}
-
-	NormalizePath(tmp, sizeof(tmp), path);
-
-	Zero(&st, sizeof(st));
-	if (statfs(tmp, &st) == 0)
-	{
-		v1 = (UINT64)st.f_bsize * (UINT64)st.f_bavail;
-		v2 = (UINT64)st.f_bsize * (UINT64)st.f_blocks;
-		ret = true;
-	}
-
-	if (free_size != NULL)
-	{
-		*free_size = v1;
-	}
-
-	if (total_size != NULL)
-	{
-		*total_size = v2;
-	}
-
-	if (used_size != NULL)
-	{
-		*used_size = v2 - v1;
-	}
-
-	return ret;
-#else	// USE_STATVFS
-	struct statvfs st;
-	char tmp[MAX_PATH];
-	UINT64 v1 = 0, v2 = 0;
-	bool ret = false;
-	// Validate arguments
-	if (path == NULL)
-	{
-		return false;
-	}
-
-	NormalizePath(tmp, sizeof(tmp), path);
-
-	Zero(&st, sizeof(st));
-
-	if (statvfs(tmp, &st) == 0)
-	{
-		v1 = (UINT64)st.f_bsize * (UINT64)st.f_bavail;
-		v2 = (UINT64)st.f_bsize * (UINT64)st.f_blocks;
-		ret = true;
-	}
-
-	if (free_size != NULL)
-	{
-		*free_size = v1;
-	}
-
-	if (total_size != NULL)
-	{
-		*total_size = v2;
-	}
-
-	if (used_size != NULL)
-	{
-		*used_size = v2 - v1;
-	}
-
-	return ret;
-#endif	// USE_STATVFS
-}
-
-// Directory enumeration
-DIRLIST *UnixEnumDirEx(char *dirname, COMPARE *compare)
-{
-	char tmp[MAX_PATH];
-	DIRLIST *d;
-	int n;
-	struct dirent **e;
-	LIST *o;
-	// Validate arguments
-	if (dirname == NULL)
-	{
-		return NULL;
-	}
-
-	o = NewListFast(compare);
-
-	NormalizePath(tmp, sizeof(tmp), dirname);
-
-	if (StrLen(tmp) >= 1 && tmp[StrLen(tmp) - 1] != '/')
-	{
-		StrCat(tmp, sizeof(tmp), "/");
-	}
-
-	e = NULL;
-	n = scandir(tmp, &e, 0, alphasort);
-
-	if (StrLen(tmp) >= 1 && tmp[StrLen(tmp) - 1] == '/')
-	{
-		tmp[StrLen(tmp) - 1] = 0;
-	}
-
-	if (n >= 0 && e != NULL)
-	{
-		UINT i;
-
-		for (i = 0;i < (UINT)n;i++)
-		{
-			char *filename = e[i]->d_name;
-
-			if (filename != NULL)
-			{
-				if (StrCmpi(filename, "..") != 0 && StrCmpi(filename, ".") != 0)
-				{
-					char fullpath[MAX_PATH];
-					struct stat st;
-					Format(fullpath, sizeof(fullpath), "%s/%s", tmp, filename);
-
-					Zero(&st, sizeof(st));
-
-					if (stat(fullpath, &st) == 0)
-					{
-						DIRENT *f = ZeroMalloc(sizeof(DIRENT));
-						SYSTEMTIME t;
-
-						f->Folder = S_ISDIR(st.st_mode) ? true : false;
-						f->FileName = CopyStr(filename);
-						f->FileNameW = CopyUtfToUni(f->FileName);
-
-						Zero(&t, sizeof(t));
-						TimeToSystem(&t, st.st_ctime);
-						f->CreateDate = SystemToUINT64(&t);
-
-						Zero(&t, sizeof(t));
-						TimeToSystem(&t, st.st_mtime);
-						f->UpdateDate = SystemToUINT64(&t);
-
-						if (f->Folder == false)
-						{
-							f->FileSize = st.st_size;
-						}
-
-						Add(o, f);
-					}
-				}
-			}
-
-			free(e[i]);
-		}
-
-		free(e);
-	}
-
-	Sort(o);
-
-	d = ZeroMalloc(sizeof(DIRLIST));
-	d->NumFiles = LIST_NUM(o);
-	d->File = ToArray(o);
-
-	ReleaseList(o);
-
-	return d;
-}
-DIRLIST *UnixEnumDirExW(wchar_t *dirname, COMPARE *compare)
-{
-	char *dirname_a = CopyUniToUtf(dirname);
-	DIRLIST *ret;
-
-	ret = UnixEnumDirEx(dirname_a, compare);
-
-	Free(dirname_a);
-
-	return ret;
-}
-
-// Check the execute permissions of the specified file
-bool UnixCheckExecAccess(char *name)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	if (access(name, X_OK) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-bool UnixCheckExecAccessW(wchar_t *name)
-{
-	char *name_a;
-	bool ret;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	name_a = CopyUniToUtf(name);
-
-	ret = UnixCheckExecAccess(name_a);
-
-	Free(name_a);
-
-	return ret;
-}
-
-// Raise the priority of the thread to highest
-void UnixSetThreadPriorityRealtime()
-{
-	struct sched_param p;
-	Zero(&p, sizeof(p));
-	p.sched_priority = 255;
-	pthread_setschedparam(pthread_self(), SCHED_RR, &p);
-}
-
-// Get the current directory
-void UnixGetCurrentDir(char *dir, UINT size)
-{
-	// Validate arguments
-	if (dir == NULL)
-	{
-		return;
-	}
-
-	getcwd(dir, size);
-}
-void UnixGetCurrentDirW(wchar_t *dir, UINT size)
-{
-	char dir_a[MAX_PATH];
-
-	UnixGetCurrentDir(dir_a, sizeof(dir_a));
-
-	UtfToUni(dir, size, dir_a);
-}
-
-// Yield
-void UnixYield()
-{
-#ifdef UNIX_SOLARIS
-	UnixSolarisSleep(1);
-#else
-	usleep(1000);
-#endif
-}
-
-// Get the memory information
-void UnixGetMemInfo(MEMINFO *info)
-{
-	// Validate arguments
-	if (info == NULL)
-	{
-		return;
-	}
-
-	// I don't know!!
-	Zero(info, sizeof(MEMINFO));
-}
-
-// Release of the single instance
-void UnixFreeSingleInstance(void *data)
-{
-	UNIXLOCKFILE *o;
-	struct flock lock;
-	// Validate arguments
-	if (data == NULL)
-	{
-		return;
-	}
-
-	o = (UNIXLOCKFILE *)data;
-
-	Zero(&lock, sizeof(lock));
-	lock.l_type = F_UNLCK;
-	lock.l_whence = SEEK_SET;
-
-	(void)fcntl(o->fd, F_SETLK, &lock);
-	close(o->fd);
-
-	(void)remove(o->FileName);
-
-	Free(data);
-}
-
-// Creating a single instance
-void *UnixNewSingleInstance(char *instance_name)
-{
-	UNIXLOCKFILE *ret;
-	char tmp[MAX_SIZE];
-	char name[MAX_SIZE];
-	char dir[MAX_PATH];
-	int fd;
-	struct flock lock;
-	int mode = S_IRUSR | S_IWUSR;
-	// Validate arguments
-	if (instance_name == NULL)
-	{
-		GetExeName(tmp, sizeof(tmp));
-		HashInstanceName(tmp, sizeof(tmp), tmp);
-	}
-	else
-	{
-		StrCpy(tmp, sizeof(tmp), instance_name);
-	}
-
-	GetPidDir(dir, sizeof(dir));
-
-	// File name generation
-	Format(name, sizeof(name), "%s/.%s", dir, tmp);
-
-	fd = open(name, O_WRONLY);
-	if (fd == -1)
-	{
-		fd = creat(name, mode);
-	}
-	if (fd == -1)
-	{
-		Format(tmp, sizeof(tmp), "Unable to create %s.", name);
-		Alert(tmp, NULL);
-		exit(0);
-		return NULL;
-	}
-
-	fchmod(fd, mode);
-	(void)chmod(name, mode);
-
-	Zero(&lock, sizeof(lock));
-	lock.l_type = F_WRLCK;
-	lock.l_whence = SEEK_SET;
-
-	if (fcntl(fd, F_SETLK, &lock) == -1)
-	{
-		close(fd);
-		return NULL;
-	}
-	else
-	{
-		ret = ZeroMalloc(sizeof(UNIXLOCKFILE));
-		ret->fd = fd;
-		StrCpy(ret->FileName, sizeof(ret->FileName), name);
-		return (void *)ret;
-	}
-}
-
-// Set the high oom score
-void UnixSetHighOomScore()
-{
-	IO *o;
-	char tmp[256];
-
-	sprintf(tmp, "/proc/%u/oom_score_adj", getpid());
-
-	o = UnixFileCreate(tmp);
-	if (o != NULL)
-	{
-		char tmp[128];
-		sprintf(tmp, "%u\n", 800);
-		UnixFileWrite(o, tmp, strlen(tmp));
-		UnixFileClose(o, false);
-	}
-}
-
-// Raise the priority of the process
-void UnixSetHighPriority()
-{
-	if (high_process == false)
-	{
-		UINT pid = getpid();
-		UINT pgid = getpgid(pid);
-
-		high_process = true;
-		nice(-20);
-
-		setpriority(PRIO_PROCESS, pid, -20);
-		setpriority(PRIO_PGRP, pgid, -20);
-	}
-}
-
-// Restore the priority of the process
-void UnixRestorePriority()
-{
-	if (high_process != false)
-	{
-		high_process = false;
-		nice(20);
-	}
-}
-
-UINT UnixGetNumberOfCpuInner()
-{
-	BUF *b;
-	UINT ret = 0;
-
-	b = ReadDump("/proc/cpuinfo");
-	if (b != NULL)
-	{
-		while (true)
-		{
-			char *line = CfgReadNextLine(b);
-
-			if (line == NULL)
-			{
-				break;
-			}
-
-			if (IsEmptyStr(line) == false)
-			{
-				TOKEN_LIST *t = ParseToken(line, ":");
-				if (t != NULL)
-				{
-					if (t->NumTokens >= 2)
-					{
-						char *key = t->Token[0];
-						char *value = t->Token[1];
-
-						Trim(key);
-						Trim(value);
-
-						if (StrCmpi(key, "processor") == 0)
-						{
-							if (IsNum(value))
-							{
-								UINT i = ToInt(value) + 1;
-
-								if (i >= 1 && i <= 128)
-								{
-									ret = MAX(ret, i);
-								}
-							}
-						}
-					}
-
-					FreeToken(t);
-				}
-			}
-
-			Free(line);
-		}
-
-		FreeBuf(b);
-	}
-
-	return ret;
-}
-
-// Get the product ID
-char *UnixGetProductId()
-{
-	return CopyStr("--");
-}
-
-// Display an alert
-void UnixAlertW(wchar_t *msg, wchar_t *caption)
-{
-	char *msg8 = CopyUniToUtf(msg);
-	char *caption8 = CopyUniToUtf(caption);
-
-	UnixAlert(msg8, caption8);
-
-	Free(msg8);
-	Free(caption8);
-}
-void UnixAlert(char *msg, char *caption)
-{
-	char *tag =
-		"-- Alert: %s --\n%s\n";
-	// Validate arguments
-	if (msg == NULL)
-	{
-		msg = "Alert";
-	}
-	if (caption == NULL)
-	{
-		caption = CEDAR_PRODUCT_STR " VPN Kernel";
-	}
-
-	printf(tag, caption, msg);
-}
-
-// Get the information of the current OS
-void UnixGetOsInfo(OS_INFO *info)
-{
-	struct utsname unix_info;
-
-	// Validate arguments
-	if (info == NULL)
-	{
-		return;
-	}
-
-	Zero(info, sizeof(OS_INFO));
-
-#ifdef	UNIX_SOLARIS
-	info->OsType = OSTYPE_SOLARIS;
-#elif	UNIX_CYGWIN
-	info->OsType = OSTYPE_CYGWIN;
-#elif	UNIX_MACOS
-	info->OsType = OSTYPE_MACOS_X;
-#elif	UNIX_BSD
-	info->OsType = OSTYPE_BSD;
-#elif	UNIX_LINUX
-	info->OsType = OSTYPE_LINUX;
-#else
-	info->OsType = OSTYPE_UNIX_UNKNOWN;
-#endif
-
-	info->OsSystemName = CopyStr(OsTypeToStr(info->OsType));
-	info->KernelName = CopyStr("UNIX");
-
-	if (uname(&unix_info) > -1)
-	{
-		info->OsProductName = CopyStr(unix_info.sysname);
-		info->OsVersion = CopyStr(unix_info.release);
-		info->KernelVersion = CopyStr(unix_info.version);
-	}
-	else
-	{
-		Debug("UnixGetOsInfo(): uname() failed with error: %s\n", strerror(errno));
-
-		info->OsProductName = CopyStr(OsTypeToStr(info->OsType));
-		info->OsVersion = CopyStr("Unknown");
-		info->KernelVersion = CopyStr("Unknown");
-	}
-#ifdef	UNIX_LINUX
-	{
-		BUF *buffer = ReadDump("/etc/os-release");
-		if (buffer == NULL)
-		{
-			buffer = ReadDump("/usr/lib/os-release");
-		}
-
-		if (buffer != NULL)
-		{
-			LIST *values = NewEntryList(buffer->Buf, "\n", "=");
-
-			FreeBuf(buffer);
-
-			if (EntryListHasKey(values, "NAME"))
-			{
-				char *str = EntryListStrValue(values, "NAME");
-				TrimQuotes(str);
-				Free(info->OsProductName);
-				info->OsProductName = CopyStr(str);
-			}
-
-			if (EntryListHasKey(values, "HOME_URL"))
-			{
-				char *str = EntryListStrValue(values, "HOME_URL");
-				TrimQuotes(str);
-				info->OsVendorName = CopyStr(str);
-			}
-
-			if (EntryListHasKey(values, "VERSION"))
-			{
-				char *str = EntryListStrValue(values, "VERSION");
-				TrimQuotes(str);
-				Free(info->OsVersion);
-				info->OsVersion = CopyStr(str);
-			}
-			else
-			{
-				// Debian testing/sid doesn't provide the version in /etc/os-release
-				buffer = ReadDump("/etc/debian_version");
-				if (buffer != NULL)
-				{
-					Free(info->OsVersion);
-					info->OsVersion = CfgReadNextLine(buffer);
-					FreeBuf(buffer);
-				}
-			}
-
-			FreeEntryList(values);
-		}
-	}
-#endif
-}
-
-// Examine whether the current OS is supported by the PacketiX VPN Kernel
-bool UnixIsSupportedOs()
-{
-	// Support all UNIX OS which can run PacketiX VPN
-	return true;
-}
-
-// Run a specified command
-bool UnixRunW(wchar_t *filename, wchar_t *arg, bool hide, bool wait)
-{
-	char *filename8 = CopyUniToUtf(filename);
-	char *arg8 = CopyUniToUtf(arg);
-	bool ret = UnixRun(filename8, arg8, hide, wait);
-
-	Free(filename8);
-	Free(arg8);
-
-	return ret;
-}
-bool UnixRun(char *filename, char *arg, bool hide, bool wait)
-{
-	TOKEN_LIST *t;
-	char **args;
-	UINT ret;
-
-	// Validate arguments
-	if (filename == NULL)
-	{
-		return false;
-	}
-	if (arg == NULL)
-	{
-		arg = "";
-	}
-
-	Print("", filename, arg);
-	t = ParseToken(arg, " ");
-	if (t == NULL)
-	{
-		return false;
-	}
-	else
-	{
-		UINT num_args;
-		UINT i;
-		num_args = t->NumTokens + 2;
-		args = ZeroMalloc(sizeof(char *) * num_args);
-		args[0] = filename;
-		for (i = 1;i < num_args - 1;i++)
-		{
-			args[i] = t->Token[i - 1];
-		}
-	}
-	
-	// Create a child process
-	ret = fork();
-	if (ret == -1)
-	{
-		// Child process creation failure
-		return false;
-	}
-
-	if (ret == 0)
-	{
-		// Child process
-		if (hide)
-		{
-			// Close the standard I/O
-			UnixCloseIO();
-		}
-		execvp(filename, args);
-		AbortExit();
-	}
-	else
-	{
-		// Parent process
-		pid_t pid = (pid_t)ret;
-		Free(args);
-		FreeToken(t);
-
-		if (wait)
-		{
-			int status = 0;
-			// Wait for the termination of the child process
-			if (waitpid(pid, &status, 0) == -1)
-			{
-				return false;
-			}
-
-			if (WEXITSTATUS(status) == 0)
-			{
-				return true;
-			}
-			else
-			{
-				return false;
-			}
-		}
-
-		return true;
-	}
-}
-
-// Close the standard I/O
-void UnixCloseIO()
-{
-	static bool close_io_first = false;
-
-	// Execute only once
-	if (close_io_first)
-	{
-		return;
-	}
-	else
-	{
-		close(0);
-		close(1);
-		close(2);
-		(void)open("/dev/null", O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		close_io_first = false;
-	}
-}
-
-// Change the file name
-bool UnixFileRenameW(wchar_t *old_name, wchar_t *new_name)
-{
-	char *old_name8 = CopyUniToUtf(old_name);
-	char *new_name8 = CopyUniToUtf(new_name);
-	bool ret = UnixFileRename(old_name8, new_name8);
-
-	Free(old_name8);
-	Free(new_name8);
-
-	return ret;
-}
-bool UnixFileRename(char *old_name, char *new_name)
-{
-	// Validate arguments
-	if (old_name == NULL || new_name == NULL)
-	{
-		return false;
-	}
-
-	if (rename(old_name, new_name) != 0)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Get the call stack
-CALLSTACK_DATA *UnixGetCallStack()
-{
-	// This is not supported on non-Win32
-	return NULL;
-}
-
-// Get the symbol information from the call stack
-bool UnixGetCallStackSymbolInfo(CALLSTACK_DATA *s)
-{
-	// This is not supported on non-Win32
-	return false;
-}
-
-// Delete the directory
-bool UnixDeleteDirW(wchar_t *name)
-{
-	char *name8 = CopyUniToUtf(name);
-	bool ret = UnixDeleteDir(name8);
-
-	Free(name8);
-
-	return ret;
-}
-bool UnixDeleteDir(char *name)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	if (rmdir(name) != 0)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Create a directory
-bool UnixMakeDirW(wchar_t *name)
-{
-	char *name8 = CopyUniToUtf(name);
-	bool ret = UnixMakeDir(name8);
-
-	Free(name8);
-
-	return ret;
-}
-bool UnixMakeDir(char *name)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	if (mkdir(name, 0700) != 0)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Delete the file
-bool UnixFileDeleteW(wchar_t *name)
-{
-	bool ret;
-	char *name8 = CopyUniToUtf(name);
-
-	ret = UnixFileDelete(name8);
-
-	Free(name8);
-
-	return ret;
-}
-bool UnixFileDelete(char *name)
-{
-	// Validate arguments
-	if (name == NULL)
-	{
-		return false;
-	}
-
-	if (remove(name) != 0)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Seek the file
-bool UnixFileSeek(void *pData, UINT mode, int offset)
-{
-	UNIXIO *p;
-	UINT ret;
-	// Validate arguments
-	if (pData == NULL)
-	{
-		return 0;
-	}
-	if (mode != FILE_BEGIN && mode != FILE_END && mode != FILE_CURRENT)
-	{
-		return false;
-	}
-
-	p = (UNIXIO *)pData;
-
-	ret = lseek(p->fd, offset, mode);
-
-	if (ret == -1)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Get the file size
-UINT64 UnixFileSize(void *pData)
-{
-	struct stat st;
-	UNIXIO *p;
-	int r;
-	// Validate arguments
-	if (pData == NULL)
-	{
-		return 0;
-	}
-
-	p = (UNIXIO *)pData;
-
-	Zero(&st, sizeof(st));
-	r = fstat(p->fd, &st);
-	if (r != 0)
-	{
-		return 0;
-	}
-
-	return (UINT64)st.st_size;
-}
-
-// Write to the file
-bool UnixFileWrite(void *pData, void *buf, UINT size)
-{
-	UNIXIO *p;
-	UINT ret;
-	// Validate arguments
-	if (pData == NULL || buf == NULL || size == 0)
-	{
-		return false;
-	}
-
-	p = (UNIXIO *)pData;
-
-	ret = write(p->fd, buf, size);
-	if (ret != size)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Read from the file
-bool UnixFileRead(void *pData, void *buf, UINT size)
-{
-	UNIXIO *p;
-	UINT ret;
-	// Validate arguments
-	if (pData == NULL || buf == NULL || size == 0)
-	{
-		return false;
-	}
-
-	p = (UNIXIO *)pData;
-
-	ret = read(p->fd, buf, size);
-	if (ret != size)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Flush to the file
-void UnixFileFlush(void *pData)
-{
-	UNIXIO *p;
-	bool write_mode;
-	// Validate arguments
-	if (pData == NULL)
-	{
-		return;
-	}
-
-	p = (UNIXIO *)pData;
-
-	write_mode = p->write_mode;
-
-	if (write_mode)
-	{
-		fsync(p->fd);
-	}
-}
-
-// Close the file
-void UnixFileClose(void *pData, bool no_flush)
-{
-	UNIXIO *p;
-	bool write_mode;
-	// Validate arguments
-	if (pData == NULL)
-	{
-		return;
-	}
-
-	p = (UNIXIO *)pData;
-
-	write_mode = p->write_mode;
-
-	if (write_mode && no_flush == false)
-	{
-		fsync(p->fd);
-	}
-
-	close(p->fd);
-
-	UnixMemoryFree(p);
-
-	if (write_mode)
-	{
-		//sync();
-	}
-}
-
-// Create a file
-void *UnixFileCreateW(wchar_t *name)
-{
-	void *ret;
-	char *name8 = CopyUniToUtf(name);
-
-	ret = UnixFileCreate(name8);
-
-	Free(name8);
-
-	return ret;
-}
-void *UnixFileCreate(char *name)
-{
-	UNIXIO *p;
-	int fd;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return NULL;
-	}
-
-	fd = creat(name, 0600);
-	if (fd == -1)
-	{
-		return NULL;
-	}
-
-	// Memory allocation
-	p = UnixMemoryAlloc(sizeof(UNIXIO));
-	p->fd = fd;
-	p->write_mode = true;
-
-	return (void *)p;
-}
-
-// Open the file
-void *UnixFileOpenW(wchar_t *name, bool write_mode, bool read_lock)
-{
-	char *name8 = CopyUniToUtf(name);
-	void *ret;
-
-	ret = UnixFileOpen(name8, write_mode, read_lock);
-
-	Free(name8);
-
-	return ret;
-}
-void *UnixFileOpen(char *name, bool write_mode, bool read_lock)
-{
-	UNIXIO *p;
-	int fd;
-	int mode;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return NULL;
-	}
-
-	if (write_mode == false)
-	{
-		mode = O_RDONLY;
-	}
-	else
-	{
-		mode = O_RDWR;
-	}
-
-	// Open the file
-	fd = open(name, mode);
-	if (fd == -1)
-	{
-		return NULL;
-	}
-
-	// Memory allocation
-	p = UnixMemoryAlloc(sizeof(UNIXIO));
-	p->fd = fd;
-	p->write_mode = write_mode;
-
-	return (void *)p;
-}
-
-// Get UNIXIO object for stdout
-void* GetUnixio4Stdout()
-{
-	static UNIXIO unixio =
-	{
-		.fd = -1,
-		.write_mode = true
-	};
-
-	if (g_foreground)
-	{
-		unixio.fd = STDOUT_FILENO;
-		return &unixio;
-	}
-	return NULL;
-}
-
-// Return the current thread ID
-UINT UnixThreadId()
-{
-	UINT ret;
-
-	ret = (UINT)pthread_self();
-
-	return ret;
-}
-
-// Thread function
-void *UnixDefaultThreadProc(void *param)
-{
-	UNIXTHREAD *ut;
-	UNIXTHREADSTARTUPINFO *info = (UNIXTHREADSTARTUPINFO *)param;
-	if (info == NULL)
-	{
-		return 0;
-	}
-
-	ut = (UNIXTHREAD *)info->thread->pData;
-
-	// Call the thread function
-	info->thread_proc(info->thread, info->param);
-
-	// Set a termination flag
-	ut->finished = true;
-
-	// Release of reference
-	ReleaseThread(info->thread);
-
-	UnixMemoryFree(info);
-
-	FreeOpenSSLThreadState();
-
-	return 0;
-}
-
-// Release of thread
-void UnixFreeThread(THREAD *t)
-{
-	// Validate arguments
-	if (t == NULL)
-	{
-		return;
-	}
-
-	// Free memory
-	UnixMemoryFree(t->pData);
-}
-
-// Wait for the termination of the thread
-bool UnixWaitThread(THREAD *t)
-{
-	UNIXTHREAD *ut;
-	void *retcode = NULL;
-	// Validate arguments
-	if (t == NULL)
-	{
-		return false;
-	}
-	ut = (UNIXTHREAD *)t->pData;
-	if (ut == NULL)
-	{
-		return false;
-	}
-
-	pthread_join(ut->thread, &retcode);
-
-	return true;
-}
-
-// Thread initialization
-bool UnixInitThread(THREAD *t)
-{
-	UNIXTHREAD *ut;
-	UNIXTHREADSTARTUPINFO *info;
-	pthread_attr_t attr;
-	// Validate arguments
-	if (t == NULL || t->thread_proc == NULL)
-	{
-		return false;
-	}
-
-	// Thread data creation
-	ut = UnixMemoryAlloc(sizeof(UNIXTHREAD));
-	Zero(ut, sizeof(UNIXTHREAD));
-
-	// Creating the startup information
-	info = UnixMemoryAlloc(sizeof(UNIXTHREADSTARTUPINFO));
-	Zero(info, sizeof(UNIXTHREADSTARTUPINFO));
-	info->param = t->param;
-	info->thread_proc = t->thread_proc;
-	info->thread = t;
-	AddRef(t->ref);
-
-	// Thread creation
-	pthread_attr_init(&attr);
-	pthread_attr_setstacksize(&attr, UNIX_THREAD_STACK_SIZE);
-
-	t->pData = (void *)ut;
-
-	if (pthread_create(&ut->thread, &attr, UnixDefaultThreadProc, info) != 0)
-	{
-		// An error has occured
-		t->pData = NULL;
-		(void)Release(t->ref);
-		UnixMemoryFree(ut);
-		UnixMemoryFree(info);
-		pthread_attr_destroy(&attr);
-		return false;
-	}
-
-	pthread_attr_destroy(&attr);
-
-	return true;
-}
-
-// Release the event
-void UnixFreeEvent(EVENT *event)
-{
-	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
-	if (ue == NULL)
-	{
-		return;
-	}
-
-	pthread_cond_destroy(&ue->cond);
-	pthread_mutex_destroy(&ue->mutex);
-
-	UnixMemoryFree(ue);
-}
-
-// Wait for a event
-bool UnixWaitEvent(EVENT *event, UINT timeout)
-{
-	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
-	struct timeval now;
-	struct timespec to;
-	bool ret;
-	if (ue == NULL)
-	{
-		return false;
-	}
-
-	pthread_mutex_lock(&ue->mutex);
-	gettimeofday(&now, NULL);
-	to.tv_sec = now.tv_sec + timeout / 1000;
-	to.tv_nsec = now.tv_usec * 1000 + (timeout % 1000) * 1000 * 1000;
-	if ((to.tv_nsec / 1000000000) >= 1)
-	{
-		to.tv_sec += to.tv_nsec / 1000000000;
-		to.tv_nsec = to.tv_nsec % 1000000000;
-	}
-
-	ret = true;
-
-	while (ue->signal == false)
-	{
-		if (timeout != INFINITE)
-		{
-			if (pthread_cond_timedwait(&ue->cond, &ue->mutex, &to))
-			{
-				ret = false;
-				break;
-			}
-		}
-		else
-		{
-			pthread_cond_wait(&ue->cond, &ue->mutex);
-		}
-	}
-	ue->signal = false;
-
-	pthread_mutex_unlock(&ue->mutex);
-
-	return ret;
-}
-
-// Reset the event
-void UnixResetEvent(EVENT *event)
-{
-	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
-	if (ue == NULL)
-	{
-		return;
-	}
-
-	pthread_mutex_lock(&ue->mutex);
-	ue->signal = false;
-	pthread_cond_signal(&ue->cond);
-	pthread_mutex_unlock(&ue->mutex);
-}
-
-// Set the event
-void UnixSetEvent(EVENT *event)
-{
-	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
-	if (ue == NULL)
-	{
-		return;
-	}
-
-	pthread_mutex_lock(&ue->mutex);
-	ue->signal = true;
-	pthread_cond_signal(&ue->cond);
-	pthread_mutex_unlock(&ue->mutex);
-}
-
-// Initialize the event
-void UnixInitEvent(EVENT *event)
-{
-	UNIXEVENT *ue = UnixMemoryAlloc(sizeof(UNIXEVENT));
-
-	Zero(ue, sizeof(UNIXEVENT));
-
-	pthread_cond_init(&ue->cond, NULL);
-	pthread_mutex_init(&ue->mutex, NULL);
-	ue->signal = false;
-
-	event->pData = (void *)ue;
-}
-
-// Delete the lock
-void UnixDeleteLock(LOCK *lock)
-{
-	pthread_mutex_t *mutex;
-	// Reset Ready flag safely
-	UnixLock(lock);
-	lock->Ready = false;
-	UnixUnlockEx(lock, true);
-
-	// Delete the mutex
-	mutex = (pthread_mutex_t *)lock->pData;
-	pthread_mutex_destroy(mutex);
-
-	// Memory release
-	UnixMemoryFree(mutex);
-	UnixMemoryFree(lock);
-}
-
-// Unlock
-void UnixUnlock(LOCK *lock)
-{
-	UnixUnlockEx(lock, false);
-}
-void UnixUnlockEx(LOCK *lock, bool inner)
-{
-	pthread_mutex_t *mutex;
-	if (lock->Ready == false && inner == false)
-	{
-		// State is invalid
-		return;
-	}
-	mutex = (pthread_mutex_t *)lock->pData;
-
-	if ((--lock->locked_count) > 0)
-	{
-		return;
-	}
-
-	lock->thread_id = INFINITE;
-
-	pthread_mutex_unlock(mutex);
-
-	return;
-}
-
-// Lock
-bool UnixLock(LOCK *lock)
-{
-	pthread_mutex_t *mutex;
-	UINT thread_id = UnixThreadId();
-	if (lock->Ready == false)
-	{
-		// State is invalid
-		return false;
-	}
-
-	if (lock->thread_id == thread_id)
-	{
-		lock->locked_count++;
-		return true;
-	}
-
-	mutex = (pthread_mutex_t *)lock->pData;
-
-	pthread_mutex_lock(mutex);
-
-	lock->thread_id = thread_id;
-	lock->locked_count++;
-
-	return true;
-}
-
-// Creating a new lock
-LOCK *UnixNewLock()
-{
-	pthread_mutex_t *mutex;
-	// Memory allocation
-	LOCK *lock = UnixMemoryAlloc(sizeof(LOCK));
-	if (lock == NULL)
-	{
-		return NULL;
-	}
-
-	// Create a mutex
-	mutex = UnixMemoryAlloc(sizeof(pthread_mutex_t));
-	if (mutex == NULL)
-	{
-		UnixMemoryFree(lock);
-		return NULL;
-	}
-
-	// Initialization of the mutex
-	pthread_mutex_init(mutex, NULL);
-
-	lock->pData = (void *)mutex;
-	lock->Ready = true;
-
-	lock->thread_id = INFINITE;
-	lock->locked_count = 0;
-
-	return lock;
-}
-
-// Sleep
-void UnixSleep(UINT time)
-{
-	UINT sec = 0, millisec = 0;
-	// Validate arguments
-	if (time == 0)
-	{
-		return;
-	}
-
-	if (time == INFINITE)
-	{
-		// Wait forever
-		while (true)
-		{
-#ifdef UNIX_SOLARIS
-			UnixSolarisSleep(time);
-#else
-			sleep(1000000);
-#endif
-		}
-	}
-
-#ifdef UNIX_SOLARIS
-	UnixSolarisSleep(time);
-#else
-
-	// Prevent overflow
-	sec = time / 1000;
-	millisec = time % 1000;
-
-	if (sec != 0)
-	{
-		sleep(sec);
-	}
-	if (millisec != 0)
-	{
-		usleep(millisec * 1000);
-	}
-#endif
-}
-
-// Decrement
-void UnixDec32(UINT *value)
-{
-	if (value != NULL)
-	{
-		(*value)--;
-	}
-}
-
-// Increment
-void UnixInc32(UINT *value)
-{
-	if (value != NULL)
-	{
-		(*value)++;
-	}
-}
-
-// Get the System Time
-void UnixGetSystemTime(SYSTEMTIME *system_time)
-{
-	time_t now = 0;
-	time_64t now2 = 0;
-	struct tm tm;
-	struct timeval tv;
-	struct timezone tz;
-	// Validate arguments
-	if (system_time == NULL)
-	{
-		return;
-	}
-
-	pthread_mutex_lock(&get_time_lock);
-
-	Zero(system_time, sizeof(SYSTEMTIME));
-	Zero(&tv, sizeof(tv));
-	Zero(&tz, sizeof(tz));
-
-	time(&now);
-
-	if (sizeof(time_t) == 4)
-	{
-		now2 = (time_64t)((UINT64)((UINT)now));
-	}
-	else
-	{
-		now2 = now;
-	}
-
-	c_gmtime_r(&now2, &tm);
-
-	TmToSystem(system_time, &tm);
-
-	gettimeofday(&tv, &tz);
-
-	system_time->wMilliseconds = tv.tv_usec / 1000;
-
-	pthread_mutex_unlock(&get_time_lock);
-}
-
-UINT64 UnixGetHighresTickNano64(bool raw)
-{
-#if	defined(OS_WIN32) || defined(CLOCK_REALTIME) || defined(CLOCK_MONOTONIC) || defined(CLOCK_HIGHRES)
-	struct timespec t;
-	UINT64 ret;
-	static bool akirame = false;
-
-	if (akirame)
-	{
-		return UnixGetTick64() * 1000000ULL;
-	}
-
-	Zero(&t, sizeof(t));
-
-	if (raw == false)
-	{
-		// Function to get the boot time of the system
-		// Be careful. The Implementation is depend on the system.
-#ifdef	CLOCK_HIGHRES
-		clock_gettime(CLOCK_HIGHRES, &t);
-#else	// CLOCK_HIGHRES
-#ifdef	CLOCK_MONOTONIC
-		clock_gettime(CLOCK_MONOTONIC, &t);
-#else	// CLOCK_MONOTONIC
-		clock_gettime(CLOCK_REALTIME, &t);
-#endif	// CLOCK_MONOTONIC
-#endif	// CLOCK_HIGHRES
-	}
-	else
-	{
-		// Function to get the boot time of the system
-		// Be careful. The Implementation is depend on the system.
-#ifdef	CLOCK_HIGHRES
-		clock_gettime(CLOCK_HIGHRES, &t);
-#else	// CLOCK_HIGHRES
-#ifdef	CLOCK_MONOTONIC_RAW
-		clock_gettime(CLOCK_MONOTONIC_RAW, &t);
-#else	// CLOCK_MONOTONIC_RAW
-#ifdef	CLOCK_MONOTONIC
-		clock_gettime(CLOCK_MONOTONIC, &t);
-#else	// CLOCK_MONOTONIC
-		clock_gettime(CLOCK_REALTIME, &t);
-#endif	// CLOCK_MONOTONIC
-#endif	// CLOCK_MONOTONIC_RAW
-#endif	// CLOCK_HIGHRES
-	}
-
-	ret = ((UINT64)((UINT)t.tv_sec)) * 1000000000LL + (UINT64)t.tv_nsec;
-
-	if (akirame == false && ret == 0)
-	{
-		ret = UnixGetTick64() * 1000000ULL;
-		akirame = true;
-	}
-
-	return ret;
-
-#else	
-	return UnixGetTick64() * 1000000ULL;
-#endif
-}
-
-// Get the system timer (64bit)
-UINT64 UnixGetTick64()
-{
-#if	defined(OS_WIN32) || defined(CLOCK_REALTIME) || defined(CLOCK_MONOTONIC) || defined(CLOCK_HIGHRES)
-
-	struct timespec t;
-	UINT64 ret;
-
-	Zero(&t, sizeof(t));
-
-	// Function to get the boot time of the system
-	// Be careful. The Implementation is depend on the system.
-#ifdef	CLOCK_HIGHRES
-	clock_gettime(CLOCK_HIGHRES, &t);
-#elif	CLOCK_MONOTONIC
-	clock_gettime(CLOCK_MONOTONIC, &t);
-#else
-	clock_gettime(CLOCK_REALTIME, &t);
-#endif
-
-	ret = ((UINT64)((UINT)t.tv_sec)) * 1000LL + (UINT64)t.tv_nsec / 1000000LL;
-
-	if (ret == 0)
-	{
-		ret = TickRealtimeManual();
-	}
-
-	return ret;
-#else
-	return TickRealtimeManual();
-#endif
-}
-
-// Get the system timer
-UINT UnixGetTick()
-{
-	return (UINT)UnixGetTick64();
-}
-
-// Memory allocation
-void *UnixMemoryAlloc(UINT size)
-{
-	void *r;
-	pthread_mutex_lock(&malloc_lock);
-	r = malloc(size);
-	pthread_mutex_unlock(&malloc_lock);
-	return r;
-}
-
-// Reallocation of the memory
-void *UnixMemoryReAlloc(void *addr, UINT size)
-{
-	void *r;
-	pthread_mutex_lock(&malloc_lock);
-	r = realloc(addr, size);
-	pthread_mutex_unlock(&malloc_lock);
-	return r;
-}
-
-// Free the memory
-void UnixMemoryFree(void *addr)
-{
-	pthread_mutex_lock(&malloc_lock);
-	free(addr);
-	pthread_mutex_unlock(&malloc_lock);
-}
-
-// SIGCHLD handler
-void UnixSigChldHandler(int sig)
-{
-	// Recall the zombie processes
-	while (waitpid(-1, NULL, WNOHANG) > 0);
-	signal(SIGCHLD, UnixSigChldHandler);
-}
-
-// Disable core dump
-void UnixDisableCoreDump()
-{
-#ifdef	RLIMIT_CORE
-	UnixSetResourceLimit(RLIMIT_CORE, 0);
-#endif	// RLIMIT_CORE
-}
-
-// Initialize the library for UNIX
-void UnixInit()
-{
-	UNIXIO *o;
-	UINT64 max_memory = UNIX_MAX_MEMORY;
-
-	if (UnixIs64BitRlimSupported())
-	{
-		max_memory = UNIX_MAX_MEMORY_64;
-	}
-
-	UnixInitSolarisSleep();
-
-	// Global lock
-	pthread_mutex_init(&get_time_lock, NULL);
-	pthread_mutex_init(&malloc_lock, NULL);
-
-	// Get the Process ID
-	current_process_id = getpid();
-
-#ifdef	RLIMIT_CORE
-	UnixSetResourceLimit(RLIMIT_CORE, max_memory);
-#endif	// RLIMIT_CORE
-
-#ifdef	RLIMIT_DATA
-	UnixSetResourceLimit(RLIMIT_DATA, max_memory);
-#endif	// RLIMIT_DATA
-
-#ifdef	RLIMIT_NOFILE
-#ifndef	UNIX_MACOS
-	UnixSetResourceLimit(RLIMIT_NOFILE, UNIX_MAX_FD);
-#else	// UNIX_MACOS
-	UnixSetResourceLimit(RLIMIT_NOFILE, UNIX_MAX_FD_MACOS);
-#endif	// UNIX_MACOS
-#endif	// RLIMIT_NOFILE
-
-#ifdef	RLIMIT_STACK
-//	UnixSetResourceLimit(RLIMIT_STACK, max_memory);
-#endif	// RLIMIT_STACK
-
-#ifdef	RLIMIT_RSS
-	UnixSetResourceLimit(RLIMIT_RSS, max_memory);
-#endif	// RLIMIT_RSS
-
-#ifdef	RLIMIT_LOCKS
-	UnixSetResourceLimit(RLIMIT_LOCKS, UNIX_MAX_LOCKS);
-#endif	// RLIMIT_LOCKS
-
-#ifdef	RLIMIT_MEMLOCK
-	UnixSetResourceLimit(RLIMIT_MEMLOCK, max_memory);
-#endif	// RLIMIT_MEMLOCK
-
-#ifdef	RLIMIT_NPROC
-	UnixSetResourceLimit(RLIMIT_NPROC, UNIX_MAX_CHILD_PROCESSES);
-#endif	// RLIMIT_NPROC
-
-	// Write a value to the threads-max of the proc file system
-	o = UnixFileCreate("/proc/sys/kernel/threads-max");
-	if (o != NULL)
-	{
-		char tmp[128];
-		sprintf(tmp, "%u\n", UNIX_LINUX_MAX_THREADS);
-		UnixFileWrite(o, tmp, strlen(tmp));
-		UnixFileClose(o, false);
-	}
-
-	// Set the signals that is to be ignored
-	signal(SIGPIPE, SIG_IGN);
-	signal(SIGALRM, SIG_IGN);
-
-#ifdef	UNIX_BSD
-	signal(64, SIG_IGN);
-#endif	// UNIX_BSD
-
-#ifdef	SIGXFSZ
-	signal(SIGXFSZ, SIG_IGN);
-#endif	// SIGXFSZ
-
-	// Set a signal handler to salvage the child processes
-	signal(SIGCHLD, UnixSigChldHandler);
-}
-
-// Release the library for UNIX
-void UnixFree()
-{
-	UnixFreeSolarisSleep();
-
-	current_process_id = 0;
-
-	pthread_mutex_destroy(&get_time_lock);
-}
-
-// Adjust the upper limit of resources that may be occupied
-void UnixSetResourceLimit(UINT id, UINT64 value)
-{
-	struct rlimit t;
-	UINT64 hard_limit;
-
-	if (UnixIs64BitRlimSupported() == false)
-	{
-		if (value > (UINT64)4294967295ULL)
-		{
-			value = (UINT64)4294967295ULL;
-		}
-	}
-
-	Zero(&t, sizeof(t));
-	getrlimit(id, &t);
-
-	hard_limit = (UINT64)t.rlim_max;
-
-	Zero(&t, sizeof(t));
-	t.rlim_cur = (rlim_t)MIN(value, hard_limit);
-	t.rlim_max = (rlim_t)hard_limit;
-	setrlimit(id, &t);
-
-	Zero(&t, sizeof(t));
-	t.rlim_cur = (rlim_t)value;
-	t.rlim_max = (rlim_t)value;
-	setrlimit(id, &t);
-}
-
-// Is the rlim_t type 64-bit?
-bool UnixIs64BitRlimSupported()
-{
-	if (sizeof(rlim_t) >= 8)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-// Generate the PID file name
-void UnixGenPidFileName(char *name, UINT size)
-{
-	char exe_name[MAX_PATH];
-	UCHAR hash[MD5_SIZE];
-	char tmp1[64];
-	char dir[MAX_PATH];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	GetPidDir(dir, sizeof(dir));
-
-	GetExeName(exe_name, sizeof(exe_name));
-	StrCat(exe_name, sizeof(exe_name), ":pid_hash");
-	StrUpper(exe_name);
-
-	Md5(hash, exe_name, StrLen(exe_name));
-	BinToStr(tmp1, sizeof(tmp1), hash, sizeof(hash));
-
-	Format(name, size, "%s/.pid_%s", dir, tmp1);
-}
-
-// Delete the PID file
-void UnixDeletePidFile()
-{
-	char tmp[MAX_PATH];
-
-	UnixGenPidFileName(tmp, sizeof(tmp));
-
-	UnixFileDelete(tmp);
-}
-
-// Delete the CTL file
-void UnixDeleteCtlFile()
-{
-	char tmp[MAX_PATH];
-
-	UnixGenCtlFileName(tmp, sizeof(tmp));
-
-	UnixFileDelete(tmp);
-}
-
-// Generate the CTL file name
-void UnixGenCtlFileName(char *name, UINT size)
-{
-	char exe_name[MAX_PATH];
-	UCHAR hash[MD5_SIZE];
-	char tmp1[64];
-	char dir[MAX_PATH];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	GetPidDir(dir, sizeof(dir));
-
-	GetExeName(exe_name, sizeof(exe_name));
-	StrCat(exe_name, sizeof(exe_name), ":pid_hash");
-	StrUpper(exe_name);
-
-	Md5(hash, exe_name, StrLen(exe_name));
-	BinToStr(tmp1, sizeof(tmp1), hash, sizeof(hash));
-
-	Format(name, size, "%s/.ctl_%s", dir, tmp1);
-}
-
-// Write the CTL file
-void UnixWriteCtlFile(UINT i)
-{
-	char tmp[MAX_PATH];
-	char tmp2[64];
-	IO *o;
-
-	UnixGenCtlFileName(tmp, sizeof(tmp));
-	Format(tmp2, sizeof(tmp2), "%u\n", i);
-
-	o = FileCreate(tmp);
-	if (o != NULL)
-	{
-		FileWrite(o, tmp2, StrLen(tmp2));
-		FileClose(o);
-	}
-}
-
-// Write to the PID file
-void UnixWritePidFile(UINT pid)
-{
-	char tmp[MAX_PATH];
-	char tmp2[64];
-	IO *o;
-
-	UnixGenPidFileName(tmp, sizeof(tmp));
-	Format(tmp2, sizeof(tmp2), "%u\n", pid);
-
-	o = FileCreate(tmp);
-	if (o != NULL)
-	{
-		FileWrite(o, tmp2, StrLen(tmp2));
-		FileClose(o);
-	}
-}
-
-// Read the PID file
-UINT UnixReadPidFile()
-{
-	char tmp[MAX_PATH];
-	BUF *buf;
-
-	UnixGenPidFileName(tmp, sizeof(tmp));
-
-	buf = ReadDump(tmp);
-	if (buf == NULL)
-	{
-		return 0;
-	}
-
-	Zero(tmp, sizeof(tmp));
-	Copy(tmp, buf->Buf, MIN(buf->Size, sizeof(tmp)));
-	FreeBuf(buf);
-
-	return ToInt(tmp);
-}
-
-// Read the CTL file
-UINT UnixReadCtlFile()
-{
-	char tmp[MAX_PATH];
-	BUF *buf;
-
-	UnixGenCtlFileName(tmp, sizeof(tmp));
-
-	buf = ReadDump(tmp);
-	if (buf == NULL)
-	{
-		return 0;
-	}
-
-	Zero(tmp, sizeof(tmp));
-	Copy(tmp, buf->Buf, MIN(buf->Size, sizeof(tmp)));
-	FreeBuf(buf);
-
-	return ToInt(tmp);
-}
-
-// Get the UID
-UINT UnixGetUID()
-{
-	return (UINT)getuid();
-}
-
-// Start the service
-void UnixStartService(char *name)
-{
-	char *svc_name, *svc_title;
-	char tmp[128];
-	INSTANCE *inst;
-	char exe[MAX_PATH];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	GetExeName(exe, sizeof(exe));
-
-	Format(tmp, sizeof(tmp), SVC_NAME, name);
-	svc_name = _SS(tmp);
-	Format(tmp, sizeof(tmp), SVC_TITLE, name);
-	svc_title = _SS(tmp);
-
-	// Examine whether the service has not been started already
-	inst = NewSingleInstance(NULL);
-	if (inst == NULL)
-	{
-		// Service is already running
-		UniPrint(_UU("UNIX_SVC_ALREADY_START"), svc_title, svc_name);
-	}
-	else
-	{
-		int pid;
-		// Begin to start the service
-		UniPrint(_UU("UNIX_SVC_STARTED"), svc_title);
-
-		if (UnixGetUID() != 0)
-		{
-			// Non-root warning
-			UniPrint(_UU("UNIX_SVC_NONROOT"));
-		}
-
-		FreeSingleInstance(inst);
-
-		// Create a child process
-		pid = fork();
-		if (pid == -1)
-		{
-			UniPrint(_UU("UNIX_SVC_ERROR_FORK"), svc_title);
-		}
-		else
-		{
-			if (pid == 0)
-			{
-				// Child process
-				char *param = UNIX_SVC_ARG_EXEC_SVC;
-				char **args;
-
-				// Daemonize
-				setsid();
-				UnixCloseIO();
-				signal(SIGHUP, SIG_IGN);
-
-				// Prepare arguments
-				args = ZeroMalloc(sizeof(char *) * 3);
-				args[0] = exe;
-				args[1] = param;
-				args[2] = NULL;
-
-				execvp(exe, args);
-				AbortExit();
-			}
-			else
-			{
-				// Don't write the child process number to the file
-//				UnixWritePidFile(pid);
-			}
-		}
-	}
-}
-
-// Stop the Service
-void UnixStopService(char *name)
-{
-	char *svc_name, *svc_title;
-	char tmp[128];
-	INSTANCE *inst;
-	char exe[MAX_PATH];
-	UINT pid;
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	GetExeName(exe, sizeof(exe));
-
-	Format(tmp, sizeof(tmp), SVC_NAME, name);
-	svc_name = _SS(tmp);
-	Format(tmp, sizeof(tmp), SVC_TITLE, name);
-	svc_title = _SS(tmp);
-
-	inst = NewSingleInstance(NULL);
-	pid = UnixReadPidFile();
-	if (inst != NULL || pid == 0)
-	{
-		// Service is not running yet
-		UniPrint(_UU("UNIX_SVC_NOT_STARTED"), svc_title, svc_name);
-	}
-	else
-	{
-		// Stop the service
-		UniPrint(_UU("UNIX_SVC_STOPPING"), svc_title);
-
-		// Terminate the process
-		kill(pid, SIGTERM);
-#ifdef	UNIX_BSD
-		UnixWriteCtlFile(Rand32());
-#endif	// UNIX_BSD
-		if (UnixWaitProcessEx(pid, UNIX_SERVICE_STOP_TIMEOUT_2))
-		{
-			UniPrint(_UU("UNIX_SVC_STOPPED"), svc_title);
-		}
-		else
-		{
-			// SIGKILL
-			char tmp[256];
-
-			Format(tmp, sizeof(tmp), "killall -KILL %s", name);
-
-			UniPrint(_UU("UNIX_SVC_STOP_FAILED"), svc_title);
-			system(tmp);
-		}
-	}
-
-	FreeSingleInstance(inst);
-}
-
-// Handler of the stop signal to the process
-void UnixSigTermHandler(int signum)
-{
-	if (signum == SIGTERM)
-	{
-		unix_svc_terminate = true;
-	}
-}
-
-// The thread for stop service
-void UnixStopThread(THREAD *t, void *param)
-{
-	SERVICE_FUNCTION *stop = (SERVICE_FUNCTION *)param;
-	// Validate arguments
-	if (t == NULL || param == NULL)
-	{
-		return;
-	}
-
-	stop();
-}
-
-// Execute the main body of the service
-void UnixExecService(char *name, SERVICE_FUNCTION *start, SERVICE_FUNCTION *stop)
-{
-	char *svc_name, *svc_title;
-	char tmp[128];
-	INSTANCE *inst;
-	UINT yobi_size = 1024 * 128;
-	void *yobi1, *yobi2;
-	UINT saved_ctl;
-	// Validate arguments
-	if (start == NULL || stop == NULL || name == NULL)
-	{
-		return;
-	}
-
-	Format(tmp, sizeof(tmp), SVC_NAME, name);
-	svc_name = _SS(tmp);
-	Format(tmp, sizeof(tmp), SVC_TITLE, name);
-	svc_title = _SS(tmp);
-
-	UnixWriteCtlFile(Rand32());
-	saved_ctl = UnixReadCtlFile();
-
-	inst = NewSingleInstance(NULL);
-	if (inst != NULL)
-	{
-		THREAD *t;
-
-		yobi1 = ZeroMalloc(yobi_size);
-		yobi2 = ZeroMalloc(yobi_size);
-
-		// Start
-		UnixWritePidFile(getpid());
-
-		start();
-
-		// Starting complete. wait for arriving SIGTERM from another process
-		signal(SIGTERM, &UnixSigTermHandler);
-		while (unix_svc_terminate == false)
-		{
-#if	!(defined(UNIX_BSD) || defined(UNIX_MACOS))
-			pause();
-#else	// defined(UNIX_BSD) || defined(UNIX_MACOS)
-			if (UnixReadCtlFile() != saved_ctl)
-			{
-				break;
-			}
-
-			SleepThread(1394);
-#endif	// defined(UNIX_BSD) || defined(UNIX_MACOS)
-		}
-
-		// Stop
-		Free(yobi1);
-		t = NewThread(UnixStopThread, stop);
-		if (t == NULL || (WaitThread(t, UNIX_SERVICE_STOP_TIMEOUT_1) == false))
-		{
-			// Terminate forcibly if creation of a halting thread have
-			// failed or timed out
-			Free(yobi2);
-			FreeSingleInstance(inst);
-			UnixDeletePidFile();
-			_exit(0);
-		}
-		ReleaseThread(t);
-
-		// Delete the PID file
-		UnixDeletePidFile();
-
-		// Delete the CTL file
-		UnixDeleteCtlFile();
-
-		FreeSingleInstance(inst);
-
-		Free(yobi2);
-	}
-}
-
-// Get whether the process with the specified pid exists
-bool UnixIsProcess(UINT pid)
-{
-	if (getsid((pid_t)pid) == -1)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-// Wait for the termination of the specified process
-bool UnixWaitProcessEx(UINT pid,  UINT timeout)
-{
-	UINT64 start_tick = Tick64();
-	UINT64 end_tick = start_tick + (UINT64)timeout;
-	if (timeout == INFINITE)
-	{
-		end_tick = 0;
-	}
-	while (UnixIsProcess(pid))
-	{
-		if (end_tick != 0)
-		{
-			if (end_tick < Tick64())
-			{
-				return false;
-			}
-		}
-		SleepThread(100);
-	}
-	return true;
-}
-
-// Description of how to start
-void UnixUsage(char *name)
-{
-	char *svc_name, *svc_title;
-	char tmp[128];
-	// Validate arguments
-	if (name == NULL)
-	{
-		return;
-	}
-
-	Format(tmp, sizeof(tmp), SVC_NAME, name);
-	svc_name = _SS(tmp);
-	Format(tmp, sizeof(tmp), SVC_TITLE, name);
-	svc_title = _SS(tmp);
-
-	UniPrint(_UU("UNIX_SVC_HELP"), svc_title, svc_name, svc_name, svc_title, svc_name, svc_title);
-}
-
-// Main function of the UNIX service
-UINT UnixService(int argc, char *argv[], char *name, SERVICE_FUNCTION *start, SERVICE_FUNCTION *stop)
-{
-	// Validate arguments
-	if (name == NULL || start == NULL || stop == NULL)
-	{
-		return 0;
-	}
-
-	if (argc >= 2 && StrCmpi(argv[1], UNIX_SVC_ARG_EXEC_SVC) == 0)
-	{
-		UINT pid;
-		// Start a child process
-		// Restart if the child process didn't exit properly
-
-RESTART_PROCESS:
-		pid = fork();
-		if ((int)pid != -1)
-		{
-			if (pid == 0)
-			{
-				// Run the main process
-				UnixServiceMain(argc, argv, name, start, stop);
-			}
-			else
-			{
-				int status = 0, ret;
-
-				// Wait for the termination of the child process
-				ret = waitpid(pid, &status, 0);
-
-				if (WIFEXITED(status) == 0)
-				{
-					// Aborted
-					UnixSleep(100);
-					goto RESTART_PROCESS;
-				}
-			}
-		}
-	}
-	else if (argc >= 3 && StrCmpi(argv[1], UNIX_SVC_ARG_START) == 0 && StrCmpi(argv[2], UNIX_SVC_ARG_FOREGROUND) == 0)
-	{
-#ifdef DEBUG
-		// If set memcheck = true, the program will be vitally slow since it will log all malloc() / realloc() / free() calls to find the cause of memory leak.
-		// For normal debug we set memcheck = false.
-		// Please set memcheck = true if you want to test the cause of memory leaks.
-		InitMayaqua(false, true, argc, argv);
-#else
-		InitMayaqua(false, false, argc, argv);
-#endif
-		UnixExecService(name, start, stop);
-		FreeMayaqua();
-	}
-	else
-	{
-		// Start normally
-		UnixServiceMain(argc, argv, name, start, stop);
-	}
-
-	return 0;
-}
-void UnixServiceMain(int argc, char *argv[], char *name, SERVICE_FUNCTION *start, SERVICE_FUNCTION *stop)
-{
-	UINT mode = 0;
-	// Start of the Mayaqua
-#ifdef DEBUG
-	// If set memcheck = true, the program will be vitally slow since it will log all malloc() / realloc() / free() calls to find the cause of memory leak.
-	// For normal debug we set memcheck = false.
-	// Please set memcheck = true if you want to test the cause of memory leaks.
-	InitMayaqua(false, true, argc, argv);
-#else
-	InitMayaqua(false, false, argc, argv);
-#endif
-
-	if (argc >= 2)
-	{
-		if (StrCmpi(argv[1], UNIX_SVC_ARG_START) == 0)
-		{
-			mode = UNIX_SVC_MODE_START;
-		}
-		if (StrCmpi(argv[1], UNIX_SVC_ARG_STOP) == 0)
-		{
-			mode = UNIX_SVC_MODE_STOP;
-		}
-		if (StrCmpi(argv[1], UNIX_SVC_ARG_EXEC_SVC) == 0)
-		{
-			mode = UNIX_SVC_MODE_EXEC_SVC;
-		}
-		if (StrCmpi(argv[1], UNIX_ARG_EXIT) == 0)
-		{
-			mode = UNIX_SVC_MODE_EXIT;
-		}
-	}
-
-	switch (mode)
-	{
-	case UNIX_SVC_MODE_EXIT:
-		break;
-
-	case UNIX_SVC_MODE_START:
-		UnixStartService(name);
-		break;
-
-	case UNIX_SVC_MODE_STOP:
-		UnixStopService(name);
-		break;
-
-	case UNIX_SVC_MODE_EXEC_SVC:
-		UnixExecService(name, start, stop);
-		break;
-
-	default:
-		UnixUsage(name);
-		break;
-	}
-
-	// End of the Mayaqua
-	FreeMayaqua();
-
-	return;
-}
-
-#endif	// UNIX
+// SoftEther VPN Source Code - Developer Edition Master Branch
+// Mayaqua Kernel
+
+
+// Unix.c
+// UNIX dependent code
+
+#ifdef	OS_UNIX
+
+#include "Unix.h"
+
+#include "Cfg.h"
+#include "FileIO.h"
+#include "GlobalConst.h"
+#include "Internat.h"
+#include "Kernel.h"
+#include "Mayaqua.h"
+#include "Memory.h"
+#include "Network.h"
+#include "Object.h"
+#include "Str.h"
+#include "Table.h"
+#include "Tick64.h"
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <pthread.h>
+#include <signal.h>
+
+#include <sys/mount.h>
+#include <sys/param.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+#include <sys/wait.h>
+
+#ifdef UNIX_LINUX
+#include <sys/statfs.h>
+#endif
+
+#ifdef UNIX_SOLARIS
+#define USE_STATVFS
+#include <sys/statvfs.h>
+#endif
+
+#ifdef __ANDROID__
+#include <sys/vfs.h>
+#endif
+
+#ifdef	UNIX_MACOS
+#ifdef	NO_VLAN
+// Struct statfs for MacOS X
+typedef struct fsid { int32_t val[2]; } fsid_t;
+struct statfs {
+        short   f_otype;                /* TEMPORARY SHADOW COPY OF f_type */
+        short   f_oflags;               /* TEMPORARY SHADOW COPY OF f_flags */
+        long    f_bsize;                /* fundamental file system block size */
+        long    f_iosize;               /* optimal transfer block size */
+        long    f_blocks;               /* total data blocks in file system */
+        long    f_bfree;                /* free blocks in fs */
+        long    f_bavail;               /* free blocks avail to non-superuser */
+        long    f_files;                /* total file nodes in file system */
+        long    f_ffree;                /* free file nodes in fs */
+        fsid_t  f_fsid;                 /* file system id */
+        uid_t   f_owner;                /* user that mounted the filesystem */
+        short   f_reserved1;    /* spare for later */
+        short   f_type;                 /* type of filesystem */
+    long        f_flags;                /* copy of mount exported flags */
+        long    f_reserved2[2]; /* reserved for future use */
+        char    f_fstypename[15]; /* fs type name */
+        char    f_mntonname[90];  /* directory on which mounted */
+        char    f_mntfromname[90];/* mounted filesystem */
+};
+#else	// NO_VLAN
+#include <sys/mount.h>
+#endif	// NO_VLAN
+#endif	// UNIX_MACOS
+
+// Scandir() function for Solaris
+#ifdef	UNIX_SOLARIS
+#define scandir local_scandir
+#define	alphasort local_alphasort
+
+int local_scandir(const char *dir, struct dirent ***namelist,
+            int (*select)(const struct dirent *),
+            int (*compar)(const struct dirent **, const struct dirent **))
+{
+  DIR *d;
+  struct dirent *entry;
+  register int i=0;
+  size_t entrysize;
+
+  if ((d=opendir(dir)) == NULL)
+     return(-1);
+
+  *namelist=NULL;
+  while ((entry=readdir(d)) != NULL)
+  {
+    if (select == NULL || (*select)(entry))
+    {
+      *namelist=(struct dirent **)realloc((void *)(*namelist),
+                 (size_t)((i+1)*sizeof(struct dirent *)));
+	if (*namelist == NULL) return(-1);
+	entrysize=sizeof(struct dirent)-sizeof(entry->d_name)+strlen(entry->d_name)+1;
+	(*namelist)[i]=(struct dirent *)malloc(entrysize);
+	if ((*namelist)[i] == NULL) return(-1);
+	memcpy((*namelist)[i], entry, entrysize);
+	i++;
+    }
+  }
+  if (closedir(d)) return(-1);
+  if (i == 0) return(-1);
+  if (compar != NULL)
+    qsort((void *)(*namelist), (size_t)i, sizeof(struct dirent *), compar);
+
+  return(i);
+}
+
+int local_alphasort(const struct dirent **a, const struct dirent **b)
+{
+  return(strcmp((*a)->d_name, (*b)->d_name));
+}
+
+
+#endif	// UNIX_SOLARIS
+
+// Thread data for UNIX
+typedef struct UNIXTHREAD
+{
+	pthread_t thread;
+	bool finished;
+} UNIXTHREAD;
+
+// Thread startup information for UNIX
+typedef struct UNIXTHREADSTARTUPINFO
+{
+	THREAD_PROC *thread_proc;
+	void *param;
+	THREAD *thread;
+} UNIXTHREADSTARTUPINFO;
+
+// Thread function prototype for UNIX
+void *UnixDefaultThreadProc(void *param);
+
+// Current process ID
+static pid_t current_process_id = 0;
+
+// File I/O data for UNIX
+typedef struct UNIXIO
+{
+	int fd;
+	bool write_mode;
+} UNIXIO;
+
+// Lock file data for UNIX
+typedef struct UNIXLOCKFILE
+{
+	char FileName[MAX_SIZE];
+	int fd;
+} UNIXLOCKFILE;
+
+// Event data for UNIX
+typedef struct UNIXEVENT
+{
+	pthread_mutex_t mutex;
+	pthread_cond_t cond;
+	bool signal;
+} UNIXEVENT;
+
+static pthread_mutex_t get_time_lock;
+static pthread_mutex_t malloc_lock;
+static bool high_process = false;
+
+static bool unix_svc_terminate = false;
+static int solaris_sleep_p1 = -1, solaris_sleep_p2 = -1;
+
+// Create a dispatch table
+OS_DISPATCH_TABLE *UnixGetDispatchTable()
+{
+	static OS_DISPATCH_TABLE t =
+	{
+		UnixInit,
+		UnixFree,
+		UnixMemoryAlloc,
+		UnixMemoryReAlloc,
+		UnixMemoryFree,
+		UnixGetTick,
+		UnixGetSystemTime,
+		UnixInc32,
+		UnixDec32,
+		UnixSleep,
+		UnixNewLock,
+		UnixLock,
+		UnixUnlock,
+		UnixDeleteLock,
+		UnixInitEvent,
+		UnixSetEvent,
+		UnixResetEvent,
+		UnixWaitEvent,
+		UnixFreeEvent,
+		UnixWaitThread,
+		UnixFreeThread,
+		UnixInitThread,
+		UnixThreadId,
+		UnixFileOpen,
+		UnixFileOpenW,
+		UnixFileCreate,
+		UnixFileCreateW,
+		UnixFileWrite,
+		UnixFileRead,
+		UnixFileClose,
+		UnixFileFlush,
+		UnixFileSize,
+		UnixFileSeek,
+		UnixFileDelete,
+		UnixFileDeleteW,
+		UnixMakeDir,
+		UnixMakeDirW,
+		UnixDeleteDir,
+		UnixDeleteDirW,
+		UnixGetCallStack,
+		UnixGetCallStackSymbolInfo,
+		UnixFileRename,
+		UnixFileRenameW,
+		UnixRun,
+		UnixRunW,
+		UnixIsSupportedOs,
+		UnixGetOsInfo,
+		UnixAlert,
+		UnixAlertW,
+		UnixGetProductId,
+		UnixSetHighPriority,
+		UnixRestorePriority,
+		UnixNewSingleInstance,
+		UnixFreeSingleInstance,
+		UnixGetMemInfo,
+		UnixYield,
+	};
+
+	return &t;
+}
+
+static void signal_received_for_ignore(int sig, siginfo_t *info, void *ucontext)
+{
+	(void)sig;
+	(void)info;
+	(void)ucontext;
+}
+
+// Ignore the signal flew to the thread
+void UnixIgnoreSignalForThread(int sig)
+{
+	struct sigaction sa;
+
+	Zero(&sa, sizeof(sa));
+	sa.sa_handler = NULL;
+	sa.sa_sigaction = &signal_received_for_ignore;
+	sa.sa_flags = SA_SIGINFO;
+
+	sigemptyset(&sa.sa_mask);
+
+	sigaction(SIGUSR1, &sa, NULL);
+}
+
+// Disable the off-loading function of the specific Ethernet device
+void UnixDisableInterfaceOffload(char *name)
+{
+#ifdef	UNIX_LINUX
+	char tmp[MAX_SIZE];
+	TOKEN_LIST *t;
+	char *names = "rx tx sg tso ufo gso gro lro rxvlan txvlan ntuple rxhash";
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	t = ParseToken(names, " ");
+
+	if (t != NULL)
+	{
+		UINT i;
+		for (i = 0;i < t->NumTokens;i++)
+		{
+			char *a = t->Token[i];
+
+			Format(tmp, sizeof(tmp), "ethtool -K %s %s off 2>/dev/null", name, a);
+			FreeToken(UnixExec(tmp));
+		}
+	}
+
+	FreeToken(t);
+#endif	// UNIX_LINUX
+}
+
+// Validate whether the Linux/FreeBSD is running in a VM
+// Not implemented yet on other OS
+bool UnixIsInVmMain()
+{
+	TOKEN_LIST *t = NULL;
+	bool ret = false;
+#if defined(UNIX_LINUX)
+	char *vm_str_list = "Hypervisor detected,VMware Virtual Platform,VMware Virtual USB,qemu,xen,paravirtualized,virtual hd,virtualhd,virtual pc,virtualpc,kvm,oracle vm,oraclevm,parallels,xvm,bochs";
+#elif defined(__FreeBSD__)
+	char *vm_str_list = "generic,xen,hv,vmware,kvm,bhyve";
+#endif
+
+#if defined(UNIX_LINUX)
+	t = UnixExec("/bin/dmesg");
+#elif defined(__FreeBSD__)
+	t = UnixExec("/sbin/sysctl -n kern.vm_guest");
+#endif
+
+#if defined(UNIX_LINUX) || defined(__FreeBSD__)
+	if (t != NULL)
+	{
+		BUF *b = NewBuf();
+		UINT i;
+
+		for (i = 0;i < t->NumTokens;i++)
+		{
+			char *line = t->Token[i];
+
+			AddBufStr(b, line);
+			AddBufStr(b, " ");
+		}
+
+		WriteBufInt(b, 0);
+
+//		printf("%s\n", b->Buf);
+
+		ret = InStrList(b->Buf, vm_str_list, ",", false);
+
+		FreeBuf(b);
+		FreeToken(t);
+	}
+#endif // defined(UNIX_LINUX) || defined(__FreeBSD)
+
+	return ret;
+}
+
+bool UnixIsInVm()
+{
+	static bool is_in_vm_flag = false;
+	static bool is_in_vm_ret = false;
+
+	if (is_in_vm_flag == false)
+	{
+		is_in_vm_ret = UnixIsInVmMain();
+		is_in_vm_flag = true;
+	}
+
+	return is_in_vm_ret;
+}
+
+// Run quietly in the UNIX
+void UnixExecSilent(char *cmd)
+{
+	char tmp[MAX_SIZE];
+	// Validate arguments
+	if (cmd == NULL)
+	{
+		return;
+	}
+
+	Format(tmp, sizeof(tmp), "%s 2>/dev/null", cmd);
+
+	FreeToken(UnixExec(tmp));
+}
+
+// Enable / disable the ESP processing in the kernel
+void UnixSetEnableKernelEspProcessing(bool b)
+{
+	if (GetOsInfo()->OsType == OSTYPE_MACOS_X)
+	{
+		// Mac OS X
+		if (b)
+		{
+			UnixExecSilent("/usr/sbin/sysctl -w net.inet.ipsec.esp_port=4500");
+		}
+		else
+		{
+			UnixExecSilent("/usr/sbin/sysctl -w net.inet.ipsec.esp_port=4501");
+		}
+	}
+}
+
+// Run a command and return its result
+TOKEN_LIST *UnixExec(char *cmd)
+{
+	FILE *fp;
+	char tmp[MAX_SIZE];
+	char *ptr;
+	LIST *o;
+	UINT i;
+	TOKEN_LIST *ret;
+	// Validate arguments
+	if (cmd == NULL)
+	{
+		return NULL;
+	}
+
+	fp = popen(cmd, "r");
+	if (fp == NULL)
+	{
+		return NULL;
+	}
+
+	o = NewList(NULL);
+
+	while (true)
+	{
+		fgets(tmp, sizeof(tmp), fp);
+		if (feof(fp))
+		{
+			break;
+		}
+
+		ptr = strchr(tmp, '\n');
+		if (ptr != NULL)
+		{
+			*ptr = 0;
+		}
+
+		ptr = strchr(tmp, '\r');
+		if (ptr != NULL)
+		{
+			*ptr = 0;
+		}
+
+		Add(o, CopyStr(tmp));
+	}
+
+	pclose(fp);
+
+	ret = ListToTokenList(o);
+
+	FreeStrList(o);
+
+	return ret;
+}
+
+// Initialize the Sleep for Solaris
+void UnixInitSolarisSleep()
+{
+	char tmp[MAX_SIZE];
+
+	UnixNewPipe(&solaris_sleep_p1, &solaris_sleep_p2);
+	(void)read(solaris_sleep_p1, tmp, sizeof(tmp));
+}
+
+// Release the Sleep for Solaris
+void UnixFreeSolarisSleep()
+{
+	UnixDeletePipe(solaris_sleep_p1, solaris_sleep_p2);
+	solaris_sleep_p1 = -1;
+	solaris_sleep_p2 = -1;
+}
+
+// Sleep for Solaris
+void UnixSolarisSleep(UINT msec)
+{
+	struct pollfd p;
+
+	memset(&p, 0, sizeof(p));
+	p.fd = solaris_sleep_p1;
+	p.events = POLLIN;
+
+	(void)poll(&p, 1, msec == INFINITE ? -1 : (int)msec);
+}
+
+// Get the free space of the disk
+bool UnixGetDiskFree(char *path, UINT64 *free_size, UINT64 *used_size, UINT64 *total_size)
+{
+	char tmp[MAX_PATH];
+	bool ret = false;
+	// Validate arguments
+	if (path == NULL)
+	{
+		return false;
+	}
+
+	NormalizePath(tmp, sizeof(tmp), path);
+
+	while ((ret = UnixGetDiskFreeMain(tmp, free_size, used_size, total_size)) == false)
+	{
+		if (StrCmpi(tmp, "/") == 0)
+		{
+			break;
+		}
+
+		GetDirNameFromFilePath(tmp, sizeof(tmp), tmp);
+	}
+
+	return ret;
+}
+bool UnixGetDiskFreeMain(char *path, UINT64 *free_size, UINT64 *used_size, UINT64 *total_size)
+{
+#ifndef	USE_STATVFS
+	struct statfs st;
+	char tmp[MAX_PATH];
+	UINT64 v1 = 0, v2 = 0;
+	bool ret = false;
+	// Validate arguments
+	if (path == NULL)
+	{
+		return false;
+	}
+
+	NormalizePath(tmp, sizeof(tmp), path);
+
+	Zero(&st, sizeof(st));
+	if (statfs(tmp, &st) == 0)
+	{
+		v1 = (UINT64)st.f_bsize * (UINT64)st.f_bavail;
+		v2 = (UINT64)st.f_bsize * (UINT64)st.f_blocks;
+		ret = true;
+	}
+
+	if (free_size != NULL)
+	{
+		*free_size = v1;
+	}
+
+	if (total_size != NULL)
+	{
+		*total_size = v2;
+	}
+
+	if (used_size != NULL)
+	{
+		*used_size = v2 - v1;
+	}
+
+	return ret;
+#else	// USE_STATVFS
+	struct statvfs st;
+	char tmp[MAX_PATH];
+	UINT64 v1 = 0, v2 = 0;
+	bool ret = false;
+	// Validate arguments
+	if (path == NULL)
+	{
+		return false;
+	}
+
+	NormalizePath(tmp, sizeof(tmp), path);
+
+	Zero(&st, sizeof(st));
+
+	if (statvfs(tmp, &st) == 0)
+	{
+		v1 = (UINT64)st.f_bsize * (UINT64)st.f_bavail;
+		v2 = (UINT64)st.f_bsize * (UINT64)st.f_blocks;
+		ret = true;
+	}
+
+	if (free_size != NULL)
+	{
+		*free_size = v1;
+	}
+
+	if (total_size != NULL)
+	{
+		*total_size = v2;
+	}
+
+	if (used_size != NULL)
+	{
+		*used_size = v2 - v1;
+	}
+
+	return ret;
+#endif	// USE_STATVFS
+}
+
+// Directory enumeration
+DIRLIST *UnixEnumDirEx(char *dirname, COMPARE *compare)
+{
+	char tmp[MAX_PATH];
+	DIRLIST *d;
+	int n;
+	struct dirent **e;
+	LIST *o;
+	// Validate arguments
+	if (dirname == NULL)
+	{
+		return NULL;
+	}
+
+	o = NewListFast(compare);
+
+	NormalizePath(tmp, sizeof(tmp), dirname);
+
+	if (StrLen(tmp) >= 1 && tmp[StrLen(tmp) - 1] != '/')
+	{
+		StrCat(tmp, sizeof(tmp), "/");
+	}
+
+	e = NULL;
+	n = scandir(tmp, &e, 0, alphasort);
+
+	if (StrLen(tmp) >= 1 && tmp[StrLen(tmp) - 1] == '/')
+	{
+		tmp[StrLen(tmp) - 1] = 0;
+	}
+
+	if (n >= 0 && e != NULL)
+	{
+		UINT i;
+
+		for (i = 0;i < (UINT)n;i++)
+		{
+			char *filename = e[i]->d_name;
+
+			if (filename != NULL)
+			{
+				if (StrCmpi(filename, "..") != 0 && StrCmpi(filename, ".") != 0)
+				{
+					char fullpath[MAX_PATH];
+					struct stat st;
+					Format(fullpath, sizeof(fullpath), "%s/%s", tmp, filename);
+
+					Zero(&st, sizeof(st));
+
+					if (stat(fullpath, &st) == 0)
+					{
+						DIRENT *f = ZeroMalloc(sizeof(DIRENT));
+						SYSTEMTIME t;
+
+						f->Folder = S_ISDIR(st.st_mode) ? true : false;
+						f->FileName = CopyStr(filename);
+						f->FileNameW = CopyUtfToUni(f->FileName);
+
+						Zero(&t, sizeof(t));
+						TimeToSystem(&t, st.st_ctime);
+						f->CreateDate = SystemToUINT64(&t);
+
+						Zero(&t, sizeof(t));
+						TimeToSystem(&t, st.st_mtime);
+						f->UpdateDate = SystemToUINT64(&t);
+
+						if (f->Folder == false)
+						{
+							f->FileSize = st.st_size;
+						}
+
+						Add(o, f);
+					}
+				}
+			}
+
+			free(e[i]);
+		}
+
+		free(e);
+	}
+
+	Sort(o);
+
+	d = ZeroMalloc(sizeof(DIRLIST));
+	d->NumFiles = LIST_NUM(o);
+	d->File = ToArray(o);
+
+	ReleaseList(o);
+
+	return d;
+}
+DIRLIST *UnixEnumDirExW(wchar_t *dirname, COMPARE *compare)
+{
+	char *dirname_a = CopyUniToUtf(dirname);
+	DIRLIST *ret;
+
+	ret = UnixEnumDirEx(dirname_a, compare);
+
+	Free(dirname_a);
+
+	return ret;
+}
+
+// Check the execute permissions of the specified file
+bool UnixCheckExecAccess(char *name)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	if (access(name, X_OK) == 0)
+	{
+		return true;
+	}
+
+	return false;
+}
+bool UnixCheckExecAccessW(wchar_t *name)
+{
+	char *name_a;
+	bool ret;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	name_a = CopyUniToUtf(name);
+
+	ret = UnixCheckExecAccess(name_a);
+
+	Free(name_a);
+
+	return ret;
+}
+
+// Raise the priority of the thread to highest
+void UnixSetThreadPriorityRealtime()
+{
+	struct sched_param p;
+	Zero(&p, sizeof(p));
+	p.sched_priority = 255;
+	pthread_setschedparam(pthread_self(), SCHED_RR, &p);
+}
+
+// Get the current directory
+void UnixGetCurrentDir(char *dir, UINT size)
+{
+	// Validate arguments
+	if (dir == NULL)
+	{
+		return;
+	}
+
+	getcwd(dir, size);
+}
+void UnixGetCurrentDirW(wchar_t *dir, UINT size)
+{
+	char dir_a[MAX_PATH];
+
+	UnixGetCurrentDir(dir_a, sizeof(dir_a));
+
+	UtfToUni(dir, size, dir_a);
+}
+
+// Yield
+void UnixYield()
+{
+#ifdef UNIX_SOLARIS
+	UnixSolarisSleep(1);
+#else
+	usleep(1000);
+#endif
+}
+
+// Get the memory information
+void UnixGetMemInfo(MEMINFO *info)
+{
+	// Validate arguments
+	if (info == NULL)
+	{
+		return;
+	}
+
+	// I don't know!!
+	Zero(info, sizeof(MEMINFO));
+}
+
+// Release of the single instance
+void UnixFreeSingleInstance(void *data)
+{
+	UNIXLOCKFILE *o;
+	struct flock lock;
+	// Validate arguments
+	if (data == NULL)
+	{
+		return;
+	}
+
+	o = (UNIXLOCKFILE *)data;
+
+	Zero(&lock, sizeof(lock));
+	lock.l_type = F_UNLCK;
+	lock.l_whence = SEEK_SET;
+
+	(void)fcntl(o->fd, F_SETLK, &lock);
+	close(o->fd);
+
+	(void)remove(o->FileName);
+
+	Free(data);
+}
+
+// Creating a single instance
+void *UnixNewSingleInstance(char *instance_name)
+{
+	UNIXLOCKFILE *ret;
+	char tmp[MAX_SIZE];
+	char name[MAX_SIZE];
+	char dir[MAX_PATH];
+	int fd;
+	struct flock lock;
+	int mode = S_IRUSR | S_IWUSR;
+	// Validate arguments
+	if (instance_name == NULL)
+	{
+		GetExeName(tmp, sizeof(tmp));
+		HashInstanceName(tmp, sizeof(tmp), tmp);
+	}
+	else
+	{
+		StrCpy(tmp, sizeof(tmp), instance_name);
+	}
+
+	GetPidDir(dir, sizeof(dir));
+
+	// File name generation
+	Format(name, sizeof(name), "%s/.%s", dir, tmp);
+
+	fd = open(name, O_WRONLY);
+	if (fd == -1)
+	{
+		fd = creat(name, mode);
+	}
+	if (fd == -1)
+	{
+		Format(tmp, sizeof(tmp), "Unable to create %s.", name);
+		Alert(tmp, NULL);
+		exit(0);
+		return NULL;
+	}
+
+	fchmod(fd, mode);
+	(void)chmod(name, mode);
+
+	Zero(&lock, sizeof(lock));
+	lock.l_type = F_WRLCK;
+	lock.l_whence = SEEK_SET;
+
+	if (fcntl(fd, F_SETLK, &lock) == -1)
+	{
+		close(fd);
+		return NULL;
+	}
+	else
+	{
+		ret = ZeroMalloc(sizeof(UNIXLOCKFILE));
+		ret->fd = fd;
+		StrCpy(ret->FileName, sizeof(ret->FileName), name);
+		return (void *)ret;
+	}
+}
+
+// Set the high oom score
+void UnixSetHighOomScore()
+{
+	IO *o;
+	char tmp[256];
+
+	sprintf(tmp, "/proc/%u/oom_score_adj", getpid());
+
+	o = UnixFileCreate(tmp);
+	if (o != NULL)
+	{
+		char tmp[128];
+		sprintf(tmp, "%u\n", 800);
+		UnixFileWrite(o, tmp, strlen(tmp));
+		UnixFileClose(o, false);
+	}
+}
+
+// Raise the priority of the process
+void UnixSetHighPriority()
+{
+	if (high_process == false)
+	{
+		UINT pid = getpid();
+		UINT pgid = getpgid(pid);
+
+		high_process = true;
+		nice(-20);
+
+		setpriority(PRIO_PROCESS, pid, -20);
+		setpriority(PRIO_PGRP, pgid, -20);
+	}
+}
+
+// Restore the priority of the process
+void UnixRestorePriority()
+{
+	if (high_process != false)
+	{
+		high_process = false;
+		nice(20);
+	}
+}
+
+UINT UnixGetNumberOfCpuInner()
+{
+	BUF *b;
+	UINT ret = 0;
+
+	b = ReadDump("/proc/cpuinfo");
+	if (b != NULL)
+	{
+		while (true)
+		{
+			char *line = CfgReadNextLine(b);
+
+			if (line == NULL)
+			{
+				break;
+			}
+
+			if (IsEmptyStr(line) == false)
+			{
+				TOKEN_LIST *t = ParseToken(line, ":");
+				if (t != NULL)
+				{
+					if (t->NumTokens >= 2)
+					{
+						char *key = t->Token[0];
+						char *value = t->Token[1];
+
+						Trim(key);
+						Trim(value);
+
+						if (StrCmpi(key, "processor") == 0)
+						{
+							if (IsNum(value))
+							{
+								UINT i = ToInt(value) + 1;
+
+								if (i >= 1 && i <= 128)
+								{
+									ret = MAX(ret, i);
+								}
+							}
+						}
+					}
+
+					FreeToken(t);
+				}
+			}
+
+			Free(line);
+		}
+
+		FreeBuf(b);
+	}
+
+	return ret;
+}
+
+// Get the product ID
+char *UnixGetProductId()
+{
+	return CopyStr("--");
+}
+
+// Display an alert
+void UnixAlertW(wchar_t *msg, wchar_t *caption)
+{
+	char *msg8 = CopyUniToUtf(msg);
+	char *caption8 = CopyUniToUtf(caption);
+
+	UnixAlert(msg8, caption8);
+
+	Free(msg8);
+	Free(caption8);
+}
+void UnixAlert(char *msg, char *caption)
+{
+	char *tag =
+		"-- Alert: %s --\n%s\n";
+	// Validate arguments
+	if (msg == NULL)
+	{
+		msg = "Alert";
+	}
+	if (caption == NULL)
+	{
+		caption = CEDAR_PRODUCT_STR " VPN Kernel";
+	}
+
+	printf(tag, caption, msg);
+}
+
+// Get the information of the current OS
+void UnixGetOsInfo(OS_INFO *info)
+{
+	struct utsname unix_info;
+
+	// Validate arguments
+	if (info == NULL)
+	{
+		return;
+	}
+
+	Zero(info, sizeof(OS_INFO));
+
+#ifdef	UNIX_SOLARIS
+	info->OsType = OSTYPE_SOLARIS;
+#elif	UNIX_CYGWIN
+	info->OsType = OSTYPE_CYGWIN;
+#elif	UNIX_MACOS
+	info->OsType = OSTYPE_MACOS_X;
+#elif	UNIX_BSD
+	info->OsType = OSTYPE_BSD;
+#elif	UNIX_LINUX
+	info->OsType = OSTYPE_LINUX;
+#else
+	info->OsType = OSTYPE_UNIX_UNKNOWN;
+#endif
+
+	info->OsSystemName = CopyStr(OsTypeToStr(info->OsType));
+	info->KernelName = CopyStr("UNIX");
+
+	if (uname(&unix_info) > -1)
+	{
+		info->OsProductName = CopyStr(unix_info.sysname);
+		info->OsVersion = CopyStr(unix_info.release);
+		info->KernelVersion = CopyStr(unix_info.version);
+	}
+	else
+	{
+		Debug("UnixGetOsInfo(): uname() failed with error: %s\n", strerror(errno));
+
+		info->OsProductName = CopyStr(OsTypeToStr(info->OsType));
+		info->OsVersion = CopyStr("Unknown");
+		info->KernelVersion = CopyStr("Unknown");
+	}
+#ifdef	UNIX_LINUX
+	{
+		BUF *buffer = ReadDump("/etc/os-release");
+		if (buffer == NULL)
+		{
+			buffer = ReadDump("/usr/lib/os-release");
+		}
+
+		if (buffer != NULL)
+		{
+			LIST *values = NewEntryList(buffer->Buf, "\n", "=");
+
+			FreeBuf(buffer);
+
+			if (EntryListHasKey(values, "NAME"))
+			{
+				char *str = EntryListStrValue(values, "NAME");
+				TrimQuotes(str);
+				Free(info->OsProductName);
+				info->OsProductName = CopyStr(str);
+			}
+
+			if (EntryListHasKey(values, "HOME_URL"))
+			{
+				char *str = EntryListStrValue(values, "HOME_URL");
+				TrimQuotes(str);
+				info->OsVendorName = CopyStr(str);
+			}
+
+			if (EntryListHasKey(values, "VERSION"))
+			{
+				char *str = EntryListStrValue(values, "VERSION");
+				TrimQuotes(str);
+				Free(info->OsVersion);
+				info->OsVersion = CopyStr(str);
+			}
+			else
+			{
+				// Debian testing/sid doesn't provide the version in /etc/os-release
+				buffer = ReadDump("/etc/debian_version");
+				if (buffer != NULL)
+				{
+					Free(info->OsVersion);
+					info->OsVersion = CfgReadNextLine(buffer);
+					FreeBuf(buffer);
+				}
+			}
+
+			FreeEntryList(values);
+		}
+	}
+#endif
+}
+
+// Examine whether the current OS is supported by the PacketiX VPN Kernel
+bool UnixIsSupportedOs()
+{
+	// Support all UNIX OS which can run PacketiX VPN
+	return true;
+}
+
+// Run a specified command
+bool UnixRunW(wchar_t *filename, wchar_t *arg, bool hide, bool wait)
+{
+	char *filename8 = CopyUniToUtf(filename);
+	char *arg8 = CopyUniToUtf(arg);
+	bool ret = UnixRun(filename8, arg8, hide, wait);
+
+	Free(filename8);
+	Free(arg8);
+
+	return ret;
+}
+bool UnixRun(char *filename, char *arg, bool hide, bool wait)
+{
+	TOKEN_LIST *t;
+	char **args;
+	UINT ret;
+
+	// Validate arguments
+	if (filename == NULL)
+	{
+		return false;
+	}
+	if (arg == NULL)
+	{
+		arg = "";
+	}
+
+	Print("", filename, arg);
+	t = ParseToken(arg, " ");
+	if (t == NULL)
+	{
+		return false;
+	}
+	else
+	{
+		UINT num_args;
+		UINT i;
+		num_args = t->NumTokens + 2;
+		args = ZeroMalloc(sizeof(char *) * num_args);
+		args[0] = filename;
+		for (i = 1;i < num_args - 1;i++)
+		{
+			args[i] = t->Token[i - 1];
+		}
+	}
+
+	// Create a child process
+	ret = fork();
+	if (ret == -1)
+	{
+		// Child process creation failure
+		return false;
+	}
+
+	if (ret == 0)
+	{
+		// Child process
+		if (hide)
+		{
+			// Close the standard I/O
+			UnixCloseIO();
+		}
+		execvp(filename, args);
+		AbortExit();
+	}
+	else
+	{
+		// Parent process
+		pid_t pid = (pid_t)ret;
+		Free(args);
+		FreeToken(t);
+
+		if (wait)
+		{
+			int status = 0;
+			// Wait for the termination of the child process
+			if (waitpid(pid, &status, 0) == -1)
+			{
+				return false;
+			}
+
+			if (WEXITSTATUS(status) == 0)
+			{
+				return true;
+			}
+			else
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
+}
+
+// Close the standard I/O
+void UnixCloseIO()
+{
+	static bool close_io_first = false;
+
+	// Execute only once
+	if (close_io_first)
+	{
+		return;
+	}
+	else
+	{
+		close(0);
+		close(1);
+		close(2);
+		(void)open("/dev/null", O_RDWR);
+		dup2(0, 1);
+		dup2(0, 2);
+		close_io_first = false;
+	}
+}
+
+// Change the file name
+bool UnixFileRenameW(wchar_t *old_name, wchar_t *new_name)
+{
+	char *old_name8 = CopyUniToUtf(old_name);
+	char *new_name8 = CopyUniToUtf(new_name);
+	bool ret = UnixFileRename(old_name8, new_name8);
+
+	Free(old_name8);
+	Free(new_name8);
+
+	return ret;
+}
+bool UnixFileRename(char *old_name, char *new_name)
+{
+	// Validate arguments
+	if (old_name == NULL || new_name == NULL)
+	{
+		return false;
+	}
+
+	if (rename(old_name, new_name) != 0)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Get the call stack
+CALLSTACK_DATA *UnixGetCallStack()
+{
+	// This is not supported on non-Win32
+	return NULL;
+}
+
+// Get the symbol information from the call stack
+bool UnixGetCallStackSymbolInfo(CALLSTACK_DATA *s)
+{
+	// This is not supported on non-Win32
+	return false;
+}
+
+// Delete the directory
+bool UnixDeleteDirW(wchar_t *name)
+{
+	char *name8 = CopyUniToUtf(name);
+	bool ret = UnixDeleteDir(name8);
+
+	Free(name8);
+
+	return ret;
+}
+bool UnixDeleteDir(char *name)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	if (rmdir(name) != 0)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Create a directory
+bool UnixMakeDirW(wchar_t *name)
+{
+	char *name8 = CopyUniToUtf(name);
+	bool ret = UnixMakeDir(name8);
+
+	Free(name8);
+
+	return ret;
+}
+bool UnixMakeDir(char *name)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	if (mkdir(name, 0700) != 0)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Delete the file
+bool UnixFileDeleteW(wchar_t *name)
+{
+	bool ret;
+	char *name8 = CopyUniToUtf(name);
+
+	ret = UnixFileDelete(name8);
+
+	Free(name8);
+
+	return ret;
+}
+bool UnixFileDelete(char *name)
+{
+	// Validate arguments
+	if (name == NULL)
+	{
+		return false;
+	}
+
+	if (remove(name) != 0)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Seek the file
+bool UnixFileSeek(void *pData, UINT mode, int offset)
+{
+	UNIXIO *p;
+	UINT ret;
+	// Validate arguments
+	if (pData == NULL)
+	{
+		return 0;
+	}
+	if (mode != FILE_BEGIN && mode != FILE_END && mode != FILE_CURRENT)
+	{
+		return false;
+	}
+
+	p = (UNIXIO *)pData;
+
+	ret = lseek(p->fd, offset, mode);
+
+	if (ret == -1)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Get the file size
+UINT64 UnixFileSize(void *pData)
+{
+	struct stat st;
+	UNIXIO *p;
+	int r;
+	// Validate arguments
+	if (pData == NULL)
+	{
+		return 0;
+	}
+
+	p = (UNIXIO *)pData;
+
+	Zero(&st, sizeof(st));
+	r = fstat(p->fd, &st);
+	if (r != 0)
+	{
+		return 0;
+	}
+
+	return (UINT64)st.st_size;
+}
+
+// Write to the file
+bool UnixFileWrite(void *pData, void *buf, UINT size)
+{
+	UNIXIO *p;
+	UINT ret;
+	// Validate arguments
+	if (pData == NULL || buf == NULL || size == 0)
+	{
+		return false;
+	}
+
+	p = (UNIXIO *)pData;
+
+	ret = write(p->fd, buf, size);
+	if (ret != size)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Read from the file
+bool UnixFileRead(void *pData, void *buf, UINT size)
+{
+	UNIXIO *p;
+	UINT ret;
+	// Validate arguments
+	if (pData == NULL || buf == NULL || size == 0)
+	{
+		return false;
+	}
+
+	p = (UNIXIO *)pData;
+
+	ret = read(p->fd, buf, size);
+	if (ret != size)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Flush to the file
+void UnixFileFlush(void *pData)
+{
+	UNIXIO *p;
+	bool write_mode;
+	// Validate arguments
+	if (pData == NULL)
+	{
+		return;
+	}
+
+	p = (UNIXIO *)pData;
+
+	write_mode = p->write_mode;
+
+	if (write_mode)
+	{
+		fsync(p->fd);
+	}
+}
+
+// Close the file
+void UnixFileClose(void *pData, bool no_flush)
+{
+	UNIXIO *p;
+	bool write_mode;
+	// Validate arguments
+	if (pData == NULL)
+	{
+		return;
+	}
+
+	p = (UNIXIO *)pData;
+
+	write_mode = p->write_mode;
+
+	if (write_mode && no_flush == false)
+	{
+		fsync(p->fd);
+	}
+
+	close(p->fd);
+
+	UnixMemoryFree(p);
+
+	if (write_mode)
+	{
+		//sync();
+	}
+}
+
+// Create a file
+void *UnixFileCreateW(wchar_t *name)
+{
+	void *ret;
+	char *name8 = CopyUniToUtf(name);
+
+	ret = UnixFileCreate(name8);
+
+	Free(name8);
+
+	return ret;
+}
+void *UnixFileCreate(char *name)
+{
+	UNIXIO *p;
+	int fd;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	fd = creat(name, 0600);
+	if (fd == -1)
+	{
+		return NULL;
+	}
+
+	// Memory allocation
+	p = UnixMemoryAlloc(sizeof(UNIXIO));
+	p->fd = fd;
+	p->write_mode = true;
+
+	return (void *)p;
+}
+
+// Open the file
+void *UnixFileOpenW(wchar_t *name, bool write_mode, bool read_lock)
+{
+	char *name8 = CopyUniToUtf(name);
+	void *ret;
+
+	ret = UnixFileOpen(name8, write_mode, read_lock);
+
+	Free(name8);
+
+	return ret;
+}
+void *UnixFileOpen(char *name, bool write_mode, bool read_lock)
+{
+	UNIXIO *p;
+	int fd;
+	int mode;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	if (write_mode == false)
+	{
+		mode = O_RDONLY;
+	}
+	else
+	{
+		mode = O_RDWR;
+	}
+
+	// Open the file
+	fd = open(name, mode);
+	if (fd == -1)
+	{
+		return NULL;
+	}
+
+	// Memory allocation
+	p = UnixMemoryAlloc(sizeof(UNIXIO));
+	p->fd = fd;
+	p->write_mode = write_mode;
+
+	return (void *)p;
+}
+
+// Get UNIXIO object for stdout
+void* GetUnixio4Stdout()
+{
+	static UNIXIO unixio =
+	{
+		.fd = -1,
+		.write_mode = true
+	};
+
+	if (g_foreground)
+	{
+		unixio.fd = STDOUT_FILENO;
+		return &unixio;
+	}
+	return NULL;
+}
+
+// Return the current thread ID
+UINT UnixThreadId()
+{
+	UINT ret;
+
+	ret = (UINT)pthread_self();
+
+	return ret;
+}
+
+// Thread function
+void *UnixDefaultThreadProc(void *param)
+{
+	UNIXTHREAD *ut;
+	UNIXTHREADSTARTUPINFO *info = (UNIXTHREADSTARTUPINFO *)param;
+	if (info == NULL)
+	{
+		return 0;
+	}
+
+	ut = (UNIXTHREAD *)info->thread->pData;
+
+	// Call the thread function
+	info->thread_proc(info->thread, info->param);
+
+	// Set a termination flag
+	ut->finished = true;
+
+	// Release of reference
+	ReleaseThread(info->thread);
+
+	UnixMemoryFree(info);
+
+	FreeOpenSSLThreadState();
+
+	return 0;
+}
+
+// Release of thread
+void UnixFreeThread(THREAD *t)
+{
+	// Validate arguments
+	if (t == NULL)
+	{
+		return;
+	}
+
+	// Free memory
+	UnixMemoryFree(t->pData);
+}
+
+// Wait for the termination of the thread
+bool UnixWaitThread(THREAD *t)
+{
+	UNIXTHREAD *ut;
+	void *retcode = NULL;
+	// Validate arguments
+	if (t == NULL)
+	{
+		return false;
+	}
+	ut = (UNIXTHREAD *)t->pData;
+	if (ut == NULL)
+	{
+		return false;
+	}
+
+	pthread_join(ut->thread, &retcode);
+
+	return true;
+}
+
+// Thread initialization
+bool UnixInitThread(THREAD *t)
+{
+	UNIXTHREAD *ut;
+	UNIXTHREADSTARTUPINFO *info;
+	pthread_attr_t attr;
+	// Validate arguments
+	if (t == NULL || t->thread_proc == NULL)
+	{
+		return false;
+	}
+
+	// Thread data creation
+	ut = UnixMemoryAlloc(sizeof(UNIXTHREAD));
+	Zero(ut, sizeof(UNIXTHREAD));
+
+	// Creating the startup information
+	info = UnixMemoryAlloc(sizeof(UNIXTHREADSTARTUPINFO));
+	Zero(info, sizeof(UNIXTHREADSTARTUPINFO));
+	info->param = t->param;
+	info->thread_proc = t->thread_proc;
+	info->thread = t;
+	AddRef(t->ref);
+
+	// Thread creation
+	pthread_attr_init(&attr);
+	pthread_attr_setstacksize(&attr, UNIX_THREAD_STACK_SIZE);
+
+	t->pData = (void *)ut;
+
+	if (pthread_create(&ut->thread, &attr, UnixDefaultThreadProc, info) != 0)
+	{
+		// An error has occured
+		t->pData = NULL;
+		(void)Release(t->ref);
+		UnixMemoryFree(ut);
+		UnixMemoryFree(info);
+		pthread_attr_destroy(&attr);
+		return false;
+	}
+
+	pthread_attr_destroy(&attr);
+
+	return true;
+}
+
+// Release the event
+void UnixFreeEvent(EVENT *event)
+{
+	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
+	if (ue == NULL)
+	{
+		return;
+	}
+
+	pthread_cond_destroy(&ue->cond);
+	pthread_mutex_destroy(&ue->mutex);
+
+	UnixMemoryFree(ue);
+}
+
+// Wait for a event
+bool UnixWaitEvent(EVENT *event, UINT timeout)
+{
+	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
+	struct timeval now;
+	struct timespec to;
+	bool ret;
+	if (ue == NULL)
+	{
+		return false;
+	}
+
+	pthread_mutex_lock(&ue->mutex);
+	gettimeofday(&now, NULL);
+	to.tv_sec = now.tv_sec + timeout / 1000;
+	to.tv_nsec = now.tv_usec * 1000 + (timeout % 1000) * 1000 * 1000;
+	if ((to.tv_nsec / 1000000000) >= 1)
+	{
+		to.tv_sec += to.tv_nsec / 1000000000;
+		to.tv_nsec = to.tv_nsec % 1000000000;
+	}
+
+	ret = true;
+
+	while (ue->signal == false)
+	{
+		if (timeout != INFINITE)
+		{
+			if (pthread_cond_timedwait(&ue->cond, &ue->mutex, &to))
+			{
+				ret = false;
+				break;
+			}
+		}
+		else
+		{
+			pthread_cond_wait(&ue->cond, &ue->mutex);
+		}
+	}
+	ue->signal = false;
+
+	pthread_mutex_unlock(&ue->mutex);
+
+	return ret;
+}
+
+// Reset the event
+void UnixResetEvent(EVENT *event)
+{
+	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
+	if (ue == NULL)
+	{
+		return;
+	}
+
+	pthread_mutex_lock(&ue->mutex);
+	ue->signal = false;
+	pthread_cond_signal(&ue->cond);
+	pthread_mutex_unlock(&ue->mutex);
+}
+
+// Set the event
+void UnixSetEvent(EVENT *event)
+{
+	UNIXEVENT *ue = (UNIXEVENT *)event->pData;
+	if (ue == NULL)
+	{
+		return;
+	}
+
+	pthread_mutex_lock(&ue->mutex);
+	ue->signal = true;
+	pthread_cond_signal(&ue->cond);
+	pthread_mutex_unlock(&ue->mutex);
+}
+
+// Initialize the event
+void UnixInitEvent(EVENT *event)
+{
+	UNIXEVENT *ue = UnixMemoryAlloc(sizeof(UNIXEVENT));
+
+	Zero(ue, sizeof(UNIXEVENT));
+
+	pthread_cond_init(&ue->cond, NULL);
+	pthread_mutex_init(&ue->mutex, NULL);
+	ue->signal = false;
+
+	event->pData = (void *)ue;
+}
+
+// Delete the lock
+void UnixDeleteLock(LOCK *lock)
+{
+	pthread_mutex_t *mutex;
+	// Reset Ready flag safely
+	UnixLock(lock);
+	lock->Ready = false;
+	UnixUnlockEx(lock, true);
+
+	// Delete the mutex
+	mutex = (pthread_mutex_t *)lock->pData;
+	pthread_mutex_destroy(mutex);
+
+	// Memory release
+	UnixMemoryFree(mutex);
+	UnixMemoryFree(lock);
+}
+
+// Unlock
+void UnixUnlock(LOCK *lock)
+{
+	UnixUnlockEx(lock, false);
+}
+void UnixUnlockEx(LOCK *lock, bool inner)
+{
+	pthread_mutex_t *mutex;
+	if (lock->Ready == false && inner == false)
+	{
+		// State is invalid
+		return;
+	}
+	mutex = (pthread_mutex_t *)lock->pData;
+
+	if ((--lock->locked_count) > 0)
+	{
+		return;
+	}
+
+	lock->thread_id = INFINITE;
+
+	pthread_mutex_unlock(mutex);
+
+	return;
+}
+
+// Lock
+bool UnixLock(LOCK *lock)
+{
+	pthread_mutex_t *mutex;
+	UINT thread_id = UnixThreadId();
+	if (lock->Ready == false)
+	{
+		// State is invalid
+		return false;
+	}
+
+	if (lock->thread_id == thread_id)
+	{
+		lock->locked_count++;
+		return true;
+	}
+
+	mutex = (pthread_mutex_t *)lock->pData;
+
+	pthread_mutex_lock(mutex);
+
+	lock->thread_id = thread_id;
+	lock->locked_count++;
+
+	return true;
+}
+
+// Creating a new lock
+LOCK *UnixNewLock()
+{
+	pthread_mutex_t *mutex;
+	// Memory allocation
+	LOCK *lock = UnixMemoryAlloc(sizeof(LOCK));
+	if (lock == NULL)
+	{
+		return NULL;
+	}
+
+	// Create a mutex
+	mutex = UnixMemoryAlloc(sizeof(pthread_mutex_t));
+	if (mutex == NULL)
+	{
+		UnixMemoryFree(lock);
+		return NULL;
+	}
+
+	// Initialization of the mutex
+	pthread_mutex_init(mutex, NULL);
+
+	lock->pData = (void *)mutex;
+	lock->Ready = true;
+
+	lock->thread_id = INFINITE;
+	lock->locked_count = 0;
+
+	return lock;
+}
+
+// Sleep
+void UnixSleep(UINT time)
+{
+	UINT sec = 0, millisec = 0;
+	// Validate arguments
+	if (time == 0)
+	{
+		return;
+	}
+
+	if (time == INFINITE)
+	{
+		// Wait forever
+		while (true)
+		{
+#ifdef UNIX_SOLARIS
+			UnixSolarisSleep(time);
+#else
+			sleep(1000000);
+#endif
+		}
+	}
+
+#ifdef UNIX_SOLARIS
+	UnixSolarisSleep(time);
+#else
+
+	// Prevent overflow
+	sec = time / 1000;
+	millisec = time % 1000;
+
+	if (sec != 0)
+	{
+		sleep(sec);
+	}
+	if (millisec != 0)
+	{
+		usleep(millisec * 1000);
+	}
+#endif
+}
+
+// Decrement
+void UnixDec32(UINT *value)
+{
+	if (value != NULL)
+	{
+		(*value)--;
+	}
+}
+
+// Increment
+void UnixInc32(UINT *value)
+{
+	if (value != NULL)
+	{
+		(*value)++;
+	}
+}
+
+// Get the System Time
+void UnixGetSystemTime(SYSTEMTIME *system_time)
+{
+	time_t now = 0;
+	time_64t now2 = 0;
+	struct tm tm;
+	struct timeval tv;
+	struct timezone tz;
+	// Validate arguments
+	if (system_time == NULL)
+	{
+		return;
+	}
+
+	pthread_mutex_lock(&get_time_lock);
+
+	Zero(system_time, sizeof(SYSTEMTIME));
+	Zero(&tv, sizeof(tv));
+	Zero(&tz, sizeof(tz));
+
+	time(&now);
+
+	if (sizeof(time_t) == 4)
+	{
+		now2 = (time_64t)((UINT64)((UINT)now));
+	}
+	else
+	{
+		now2 = now;
+	}
+
+	c_gmtime_r(&now2, &tm);
+
+	TmToSystem(system_time, &tm);
+
+	gettimeofday(&tv, &tz);
+
+	system_time->wMilliseconds = tv.tv_usec / 1000;
+
+	pthread_mutex_unlock(&get_time_lock);
+}
+
+UINT64 UnixGetHighresTickNano64(bool raw)
+{
+#if	defined(OS_WIN32) || defined(CLOCK_REALTIME) || defined(CLOCK_MONOTONIC) || defined(CLOCK_HIGHRES)
+	struct timespec t;
+	UINT64 ret;
+	static bool akirame = false;
+
+	if (akirame)
+	{
+		return UnixGetTick64() * 1000000ULL;
+	}
+
+	Zero(&t, sizeof(t));
+
+	if (raw == false)
+	{
+		// Function to get the boot time of the system
+		// Be careful. The Implementation is depend on the system.
+#ifdef	CLOCK_HIGHRES
+		clock_gettime(CLOCK_HIGHRES, &t);
+#else	// CLOCK_HIGHRES
+#ifdef	CLOCK_MONOTONIC
+		clock_gettime(CLOCK_MONOTONIC, &t);
+#else	// CLOCK_MONOTONIC
+		clock_gettime(CLOCK_REALTIME, &t);
+#endif	// CLOCK_MONOTONIC
+#endif	// CLOCK_HIGHRES
+	}
+	else
+	{
+		// Function to get the boot time of the system
+		// Be careful. The Implementation is depend on the system.
+#ifdef	CLOCK_HIGHRES
+		clock_gettime(CLOCK_HIGHRES, &t);
+#else	// CLOCK_HIGHRES
+#ifdef	CLOCK_MONOTONIC_RAW
+		clock_gettime(CLOCK_MONOTONIC_RAW, &t);
+#else	// CLOCK_MONOTONIC_RAW
+#ifdef	CLOCK_MONOTONIC
+		clock_gettime(CLOCK_MONOTONIC, &t);
+#else	// CLOCK_MONOTONIC
+		clock_gettime(CLOCK_REALTIME, &t);
+#endif	// CLOCK_MONOTONIC
+#endif	// CLOCK_MONOTONIC_RAW
+#endif	// CLOCK_HIGHRES
+	}
+
+	ret = ((UINT64)((UINT)t.tv_sec)) * 1000000000LL + (UINT64)t.tv_nsec;
+
+	if (akirame == false && ret == 0)
+	{
+		ret = UnixGetTick64() * 1000000ULL;
+		akirame = true;
+	}
+
+	return ret;
+
+#else
+	return UnixGetTick64() * 1000000ULL;
+#endif
+}
+
+// Get the system timer (64bit)
+UINT64 UnixGetTick64()
+{
+#if	defined(OS_WIN32) || defined(CLOCK_REALTIME) || defined(CLOCK_MONOTONIC) || defined(CLOCK_HIGHRES)
+
+	struct timespec t;
+	UINT64 ret;
+
+	Zero(&t, sizeof(t));
+
+	// Function to get the boot time of the system
+	// Be careful. The Implementation is depend on the system.
+#ifdef	CLOCK_HIGHRES
+	clock_gettime(CLOCK_HIGHRES, &t);
+#elif	CLOCK_MONOTONIC
+	clock_gettime(CLOCK_MONOTONIC, &t);
+#else
+	clock_gettime(CLOCK_REALTIME, &t);
+#endif
+
+	ret = ((UINT64)((UINT)t.tv_sec)) * 1000LL + (UINT64)t.tv_nsec / 1000000LL;
+
+	if (ret == 0)
+	{
+		ret = TickRealtimeManual();
+	}
+
+	return ret;
+#else
+	return TickRealtimeManual();
+#endif
+}
+
+// Get the system timer
+UINT UnixGetTick()
+{
+	return (UINT)UnixGetTick64();
+}
+
+// Memory allocation
+void *UnixMemoryAlloc(UINT size)
+{
+	void *r;
+	pthread_mutex_lock(&malloc_lock);
+	r = malloc(size);
+	pthread_mutex_unlock(&malloc_lock);
+	return r;
+}
+
+// Reallocation of the memory
+void *UnixMemoryReAlloc(void *addr, UINT size)
+{
+	void *r;
+	pthread_mutex_lock(&malloc_lock);
+	r = realloc(addr, size);
+	pthread_mutex_unlock(&malloc_lock);
+	return r;
+}
+
+// Free the memory
+void UnixMemoryFree(void *addr)
+{
+	pthread_mutex_lock(&malloc_lock);
+	free(addr);
+	pthread_mutex_unlock(&malloc_lock);
+}
+
+// SIGCHLD handler
+void UnixSigChldHandler(int sig)
+{
+	// Recall the zombie processes
+	while (waitpid(-1, NULL, WNOHANG) > 0);
+	signal(SIGCHLD, UnixSigChldHandler);
+}
+
+// Disable core dump
+void UnixDisableCoreDump()
+{
+#ifdef	RLIMIT_CORE
+	UnixSetResourceLimit(RLIMIT_CORE, 0);
+#endif	// RLIMIT_CORE
+}
+
+// Initialize the library for UNIX
+void UnixInit()
+{
+	UNIXIO *o;
+	UINT64 max_memory = UNIX_MAX_MEMORY;
+
+	if (UnixIs64BitRlimSupported())
+	{
+		max_memory = UNIX_MAX_MEMORY_64;
+	}
+
+	UnixInitSolarisSleep();
+
+	// Global lock
+	pthread_mutex_init(&get_time_lock, NULL);
+	pthread_mutex_init(&malloc_lock, NULL);
+
+	// Get the Process ID
+	current_process_id = getpid();
+
+#ifdef	RLIMIT_CORE
+	UnixSetResourceLimit(RLIMIT_CORE, max_memory);
+#endif	// RLIMIT_CORE
+
+#ifdef	RLIMIT_DATA
+	UnixSetResourceLimit(RLIMIT_DATA, max_memory);
+#endif	// RLIMIT_DATA
+
+#ifdef	RLIMIT_NOFILE
+#ifndef	UNIX_MACOS
+	UnixSetResourceLimit(RLIMIT_NOFILE, UNIX_MAX_FD);
+#else	// UNIX_MACOS
+	UnixSetResourceLimit(RLIMIT_NOFILE, UNIX_MAX_FD_MACOS);
+#endif	// UNIX_MACOS
+#endif	// RLIMIT_NOFILE
+
+#ifdef	RLIMIT_STACK
+//	UnixSetResourceLimit(RLIMIT_STACK, max_memory);
+#endif	// RLIMIT_STACK
+
+#ifdef	RLIMIT_RSS
+	UnixSetResourceLimit(RLIMIT_RSS, max_memory);
+#endif	// RLIMIT_RSS
+
+#ifdef	RLIMIT_LOCKS
+	UnixSetResourceLimit(RLIMIT_LOCKS, UNIX_MAX_LOCKS);
+#endif	// RLIMIT_LOCKS
+
+#ifdef	RLIMIT_MEMLOCK
+	UnixSetResourceLimit(RLIMIT_MEMLOCK, max_memory);
+#endif	// RLIMIT_MEMLOCK
+
+#ifdef	RLIMIT_NPROC
+	UnixSetResourceLimit(RLIMIT_NPROC, UNIX_MAX_CHILD_PROCESSES);
+#endif	// RLIMIT_NPROC
+
+	// Write a value to the threads-max of the proc file system
+	o = UnixFileCreate("/proc/sys/kernel/threads-max");
+	if (o != NULL)
+	{
+		char tmp[128];
+		sprintf(tmp, "%u\n", UNIX_LINUX_MAX_THREADS);
+		UnixFileWrite(o, tmp, strlen(tmp));
+		UnixFileClose(o, false);
+	}
+
+	// Set the signals that is to be ignored
+	signal(SIGPIPE, SIG_IGN);
+	signal(SIGALRM, SIG_IGN);
+
+#ifdef	UNIX_BSD
+	signal(64, SIG_IGN);
+#endif	// UNIX_BSD
+
+#ifdef	SIGXFSZ
+	signal(SIGXFSZ, SIG_IGN);
+#endif	// SIGXFSZ
+
+	// Set a signal handler to salvage the child processes
+	signal(SIGCHLD, UnixSigChldHandler);
+}
+
+// Release the library for UNIX
+void UnixFree()
+{
+	UnixFreeSolarisSleep();
+
+	current_process_id = 0;
+
+	pthread_mutex_destroy(&get_time_lock);
+}
+
+// Adjust the upper limit of resources that may be occupied
+void UnixSetResourceLimit(UINT id, UINT64 value)
+{
+	struct rlimit t;
+	UINT64 hard_limit;
+
+	if (UnixIs64BitRlimSupported() == false)
+	{
+		if (value > (UINT64)4294967295ULL)
+		{
+			value = (UINT64)4294967295ULL;
+		}
+	}
+
+	Zero(&t, sizeof(t));
+	getrlimit(id, &t);
+
+	hard_limit = (UINT64)t.rlim_max;
+
+	Zero(&t, sizeof(t));
+	t.rlim_cur = (rlim_t)MIN(value, hard_limit);
+	t.rlim_max = (rlim_t)hard_limit;
+	setrlimit(id, &t);
+
+	Zero(&t, sizeof(t));
+	t.rlim_cur = (rlim_t)value;
+	t.rlim_max = (rlim_t)value;
+	setrlimit(id, &t);
+}
+
+// Is the rlim_t type 64-bit?
+bool UnixIs64BitRlimSupported()
+{
+	if (sizeof(rlim_t) >= 8)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+// Generate the PID file name
+void UnixGenPidFileName(char *name, UINT size)
+{
+	char exe_name[MAX_PATH];
+	UCHAR hash[MD5_SIZE];
+	char tmp1[64];
+	char dir[MAX_PATH];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	GetPidDir(dir, sizeof(dir));
+
+	GetExeName(exe_name, sizeof(exe_name));
+	StrCat(exe_name, sizeof(exe_name), ":pid_hash");
+	StrUpper(exe_name);
+
+	Md5(hash, exe_name, StrLen(exe_name));
+	BinToStr(tmp1, sizeof(tmp1), hash, sizeof(hash));
+
+	Format(name, size, "%s/.pid_%s", dir, tmp1);
+}
+
+// Delete the PID file
+void UnixDeletePidFile()
+{
+	char tmp[MAX_PATH];
+
+	UnixGenPidFileName(tmp, sizeof(tmp));
+
+	UnixFileDelete(tmp);
+}
+
+// Delete the CTL file
+void UnixDeleteCtlFile()
+{
+	char tmp[MAX_PATH];
+
+	UnixGenCtlFileName(tmp, sizeof(tmp));
+
+	UnixFileDelete(tmp);
+}
+
+// Generate the CTL file name
+void UnixGenCtlFileName(char *name, UINT size)
+{
+	char exe_name[MAX_PATH];
+	UCHAR hash[MD5_SIZE];
+	char tmp1[64];
+	char dir[MAX_PATH];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	GetPidDir(dir, sizeof(dir));
+
+	GetExeName(exe_name, sizeof(exe_name));
+	StrCat(exe_name, sizeof(exe_name), ":pid_hash");
+	StrUpper(exe_name);
+
+	Md5(hash, exe_name, StrLen(exe_name));
+	BinToStr(tmp1, sizeof(tmp1), hash, sizeof(hash));
+
+	Format(name, size, "%s/.ctl_%s", dir, tmp1);
+}
+
+// Write the CTL file
+void UnixWriteCtlFile(UINT i)
+{
+	char tmp[MAX_PATH];
+	char tmp2[64];
+	IO *o;
+
+	UnixGenCtlFileName(tmp, sizeof(tmp));
+	Format(tmp2, sizeof(tmp2), "%u\n", i);
+
+	o = FileCreate(tmp);
+	if (o != NULL)
+	{
+		FileWrite(o, tmp2, StrLen(tmp2));
+		FileClose(o);
+	}
+}
+
+// Write to the PID file
+void UnixWritePidFile(UINT pid)
+{
+	char tmp[MAX_PATH];
+	char tmp2[64];
+	IO *o;
+
+	UnixGenPidFileName(tmp, sizeof(tmp));
+	Format(tmp2, sizeof(tmp2), "%u\n", pid);
+
+	o = FileCreate(tmp);
+	if (o != NULL)
+	{
+		FileWrite(o, tmp2, StrLen(tmp2));
+		FileClose(o);
+	}
+}
+
+// Read the PID file
+UINT UnixReadPidFile()
+{
+	char tmp[MAX_PATH];
+	BUF *buf;
+
+	UnixGenPidFileName(tmp, sizeof(tmp));
+
+	buf = ReadDump(tmp);
+	if (buf == NULL)
+	{
+		return 0;
+	}
+
+	Zero(tmp, sizeof(tmp));
+	Copy(tmp, buf->Buf, MIN(buf->Size, sizeof(tmp)));
+	FreeBuf(buf);
+
+	return ToInt(tmp);
+}
+
+// Read the CTL file
+UINT UnixReadCtlFile()
+{
+	char tmp[MAX_PATH];
+	BUF *buf;
+
+	UnixGenCtlFileName(tmp, sizeof(tmp));
+
+	buf = ReadDump(tmp);
+	if (buf == NULL)
+	{
+		return 0;
+	}
+
+	Zero(tmp, sizeof(tmp));
+	Copy(tmp, buf->Buf, MIN(buf->Size, sizeof(tmp)));
+	FreeBuf(buf);
+
+	return ToInt(tmp);
+}
+
+// Get the UID
+UINT UnixGetUID()
+{
+	return (UINT)getuid();
+}
+
+// Start the service
+void UnixStartService(char *name)
+{
+	char *svc_name, *svc_title;
+	char tmp[128];
+	INSTANCE *inst;
+	char exe[MAX_PATH];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	GetExeName(exe, sizeof(exe));
+
+	Format(tmp, sizeof(tmp), SVC_NAME, name);
+	svc_name = _SS(tmp);
+	Format(tmp, sizeof(tmp), SVC_TITLE, name);
+	svc_title = _SS(tmp);
+
+	// Examine whether the service has not been started already
+	inst = NewSingleInstance(NULL);
+	if (inst == NULL)
+	{
+		// Service is already running
+		UniPrint(_UU("UNIX_SVC_ALREADY_START"), svc_title, svc_name);
+	}
+	else
+	{
+		int pid;
+		// Begin to start the service
+		UniPrint(_UU("UNIX_SVC_STARTED"), svc_title);
+
+		if (UnixGetUID() != 0)
+		{
+			// Non-root warning
+			UniPrint(_UU("UNIX_SVC_NONROOT"));
+		}
+
+		FreeSingleInstance(inst);
+
+		// Create a child process
+		pid = fork();
+		if (pid == -1)
+		{
+			UniPrint(_UU("UNIX_SVC_ERROR_FORK"), svc_title);
+		}
+		else
+		{
+			if (pid == 0)
+			{
+				// Child process
+				char *param = UNIX_SVC_ARG_EXEC_SVC;
+				char **args;
+
+				// Daemonize
+				setsid();
+				UnixCloseIO();
+				signal(SIGHUP, SIG_IGN);
+
+				// Prepare arguments
+				args = ZeroMalloc(sizeof(char *) * 3);
+				args[0] = exe;
+				args[1] = param;
+				args[2] = NULL;
+
+				execvp(exe, args);
+				AbortExit();
+			}
+			else
+			{
+				// Don't write the child process number to the file
+//				UnixWritePidFile(pid);
+			}
+		}
+	}
+}
+
+// Stop the Service
+void UnixStopService(char *name)
+{
+	char *svc_name, *svc_title;
+	char tmp[128];
+	INSTANCE *inst;
+	char exe[MAX_PATH];
+	UINT pid;
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	GetExeName(exe, sizeof(exe));
+
+	Format(tmp, sizeof(tmp), SVC_NAME, name);
+	svc_name = _SS(tmp);
+	Format(tmp, sizeof(tmp), SVC_TITLE, name);
+	svc_title = _SS(tmp);
+
+	inst = NewSingleInstance(NULL);
+	pid = UnixReadPidFile();
+	if (inst != NULL || pid == 0)
+	{
+		// Service is not running yet
+		UniPrint(_UU("UNIX_SVC_NOT_STARTED"), svc_title, svc_name);
+	}
+	else
+	{
+		// Stop the service
+		UniPrint(_UU("UNIX_SVC_STOPPING"), svc_title);
+
+		// Terminate the process
+		kill(pid, SIGTERM);
+#ifdef	UNIX_BSD
+		UnixWriteCtlFile(Rand32());
+#endif	// UNIX_BSD
+		if (UnixWaitProcessEx(pid, UNIX_SERVICE_STOP_TIMEOUT_2))
+		{
+			UniPrint(_UU("UNIX_SVC_STOPPED"), svc_title);
+		}
+		else
+		{
+			// SIGKILL
+			char tmp[256];
+
+			Format(tmp, sizeof(tmp), "killall -KILL %s", name);
+
+			UniPrint(_UU("UNIX_SVC_STOP_FAILED"), svc_title);
+			system(tmp);
+		}
+	}
+
+	FreeSingleInstance(inst);
+}
+
+// Handler of the stop signal to the process
+void UnixSigTermHandler(int signum)
+{
+	if (signum == SIGTERM)
+	{
+		unix_svc_terminate = true;
+	}
+}
+
+// The thread for stop service
+void UnixStopThread(THREAD *t, void *param)
+{
+	SERVICE_FUNCTION *stop = (SERVICE_FUNCTION *)param;
+	// Validate arguments
+	if (t == NULL || param == NULL)
+	{
+		return;
+	}
+
+	stop();
+}
+
+// Execute the main body of the service
+void UnixExecService(char *name, SERVICE_FUNCTION *start, SERVICE_FUNCTION *stop)
+{
+	char *svc_name, *svc_title;
+	char tmp[128];
+	INSTANCE *inst;
+	UINT yobi_size = 1024 * 128;
+	void *yobi1, *yobi2;
+	UINT saved_ctl;
+	// Validate arguments
+	if (start == NULL || stop == NULL || name == NULL)
+	{
+		return;
+	}
+
+	Format(tmp, sizeof(tmp), SVC_NAME, name);
+	svc_name = _SS(tmp);
+	Format(tmp, sizeof(tmp), SVC_TITLE, name);
+	svc_title = _SS(tmp);
+
+	UnixWriteCtlFile(Rand32());
+	saved_ctl = UnixReadCtlFile();
+
+	inst = NewSingleInstance(NULL);
+	if (inst != NULL)
+	{
+		THREAD *t;
+
+		yobi1 = ZeroMalloc(yobi_size);
+		yobi2 = ZeroMalloc(yobi_size);
+
+		// Start
+		UnixWritePidFile(getpid());
+
+		start();
+
+		// Starting complete. wait for arriving SIGTERM from another process
+		signal(SIGTERM, &UnixSigTermHandler);
+		while (unix_svc_terminate == false)
+		{
+#if	!(defined(UNIX_BSD) || defined(UNIX_MACOS))
+			pause();
+#else	// defined(UNIX_BSD) || defined(UNIX_MACOS)
+			if (UnixReadCtlFile() != saved_ctl)
+			{
+				break;
+			}
+
+			SleepThread(1394);
+#endif	// defined(UNIX_BSD) || defined(UNIX_MACOS)
+		}
+
+		// Stop
+		Free(yobi1);
+		t = NewThread(UnixStopThread, stop);
+		if (t == NULL || (WaitThread(t, UNIX_SERVICE_STOP_TIMEOUT_1) == false))
+		{
+			// Terminate forcibly if creation of a halting thread have
+			// failed or timed out
+			Free(yobi2);
+			FreeSingleInstance(inst);
+			UnixDeletePidFile();
+			_exit(0);
+		}
+		ReleaseThread(t);
+
+		// Delete the PID file
+		UnixDeletePidFile();
+
+		// Delete the CTL file
+		UnixDeleteCtlFile();
+
+		FreeSingleInstance(inst);
+
+		Free(yobi2);
+	}
+}
+
+// Get whether the process with the specified pid exists
+bool UnixIsProcess(UINT pid)
+{
+	if (getsid((pid_t)pid) == -1)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+// Wait for the termination of the specified process
+bool UnixWaitProcessEx(UINT pid,  UINT timeout)
+{
+	UINT64 start_tick = Tick64();
+	UINT64 end_tick = start_tick + (UINT64)timeout;
+	if (timeout == INFINITE)
+	{
+		end_tick = 0;
+	}
+	while (UnixIsProcess(pid))
+	{
+		if (end_tick != 0)
+		{
+			if (end_tick < Tick64())
+			{
+				return false;
+			}
+		}
+		SleepThread(100);
+	}
+	return true;
+}
+
+// Description of how to start
+void UnixUsage(char *name)
+{
+	char *svc_name, *svc_title;
+	char tmp[128];
+	// Validate arguments
+	if (name == NULL)
+	{
+		return;
+	}
+
+	Format(tmp, sizeof(tmp), SVC_NAME, name);
+	svc_name = _SS(tmp);
+	Format(tmp, sizeof(tmp), SVC_TITLE, name);
+	svc_title = _SS(tmp);
+
+	UniPrint(_UU("UNIX_SVC_HELP"), svc_title, svc_name, svc_name, svc_title, svc_name, svc_title);
+}
+
+// Main function of the UNIX service
+UINT UnixService(int argc, char *argv[], char *name, SERVICE_FUNCTION *start, SERVICE_FUNCTION *stop)
+{
+	// Validate arguments
+	if (name == NULL || start == NULL || stop == NULL)
+	{
+		return 0;
+	}
+#ifdef __ANDROID__
+		// On Android, directly call UnixServiceMain without forking
+		if (argc >= 2 && StrCmpi(argv[1], UNIX_SVC_ARG_EXEC_SVC) == 0) {
+			UnixServiceMain(argc, argv, name, start, stop);
+		} else {
+			exit(EXIT_FAILURE);
+		}
+#else
+	if (argc >= 2 && StrCmpi(argv[1], UNIX_SVC_ARG_EXEC_SVC) == 0)
+	{
+		UINT pid;
+		// Start a child process
+		// Restart if the child process didn't exit properly
+
+RESTART_PROCESS:
+		pid = fork();
+		if ((int)pid != -1)
+		{
+			if (pid == 0)
+			{
+				// Run the main process
+				UnixServiceMain(argc, argv, name, start, stop);
+			}
+			else
+			{
+				int status = 0, ret;
+
+				// Wait for the termination of the child process
+				ret = waitpid(pid, &status, 0);
+
+				if (WIFEXITED(status) == 0)
+				{
+					// Aborted
+					UnixSleep(100);
+					goto RESTART_PROCESS;
+				}
+			}
+		}
+	}
+	else if (argc >= 3 && StrCmpi(argv[1], UNIX_SVC_ARG_START) == 0 && StrCmpi(argv[2], UNIX_SVC_ARG_FOREGROUND) == 0)
+	{
+#ifdef DEBUG
+		// If set memcheck = true, the program will be vitally slow since it will log all malloc() / realloc() / free() calls to find the cause of memory leak.
+		// For normal debug we set memcheck = false.
+		// Please set memcheck = true if you want to test the cause of memory leaks.
+		InitMayaqua(false, true, argc, argv);
+#else
+		InitMayaqua(false, false, argc, argv);
+#endif
+		UnixExecService(name, start, stop);
+		FreeMayaqua();
+	}
+	else
+	{
+		// Start normally
+		UnixServiceMain(argc, argv, name, start, stop);
+	}
+#endif
+	return 0;
+}
+void UnixServiceMain(int argc, char *argv[], char *name, SERVICE_FUNCTION *start, SERVICE_FUNCTION *stop)
+{
+	UINT mode = 0;
+	// Start of the Mayaqua
+#ifdef DEBUG
+	// If set memcheck = true, the program will be vitally slow since it will log all malloc() / realloc() / free() calls to find the cause of memory leak.
+	// For normal debug we set memcheck = false.
+	// Please set memcheck = true if you want to test the cause of memory leaks.
+	InitMayaqua(false, true, argc, argv);
+#else
+	InitMayaqua(false, false, argc, argv);
+#endif
+
+	if (argc >= 2)
+	{
+		if (StrCmpi(argv[1], UNIX_SVC_ARG_START) == 0)
+		{
+			mode = UNIX_SVC_MODE_START;
+		}
+		if (StrCmpi(argv[1], UNIX_SVC_ARG_STOP) == 0)
+		{
+			mode = UNIX_SVC_MODE_STOP;
+		}
+		if (StrCmpi(argv[1], UNIX_SVC_ARG_EXEC_SVC) == 0)
+		{
+			mode = UNIX_SVC_MODE_EXEC_SVC;
+		}
+		if (StrCmpi(argv[1], UNIX_ARG_EXIT) == 0)
+		{
+			mode = UNIX_SVC_MODE_EXIT;
+		}
+	}
+
+	switch (mode)
+	{
+	case UNIX_SVC_MODE_EXIT:
+		break;
+
+	case UNIX_SVC_MODE_START:
+		UnixStartService(name);
+		break;
+
+	case UNIX_SVC_MODE_STOP:
+		UnixStopService(name);
+		break;
+
+	case UNIX_SVC_MODE_EXEC_SVC:
+		UnixExecService(name, start, stop);
+		break;
+
+	default:
+		UnixUsage(name);
+		break;
+	}
+
+	// End of the Mayaqua
+	FreeMayaqua();
+
+	return;
+}
+
+#endif	// UNIX
diff --git a/src/vpnclient/CMakeLists.txt b/src/vpnclient/CMakeLists.txt
index 528a637..d48856a 100644
--- a/src/vpnclient/CMakeLists.txt
+++ b/src/vpnclient/CMakeLists.txt
@@ -19,7 +19,9 @@ if(WIN32)
   configure_file("${TOP_DIRECTORY}/src/BuildFiles/VerScript/ver.rc" "${CMAKE_CURRENT_BINARY_DIR}/ver.rc")
   target_sources(vpnclient PRIVATE "vpnclient.rc" "${CMAKE_CURRENT_BINARY_DIR}/ver.rc")
 else()
-  add_executable(vpnclient "vpncsvc.c")
+  add_library(vpnclient SHARED
+    vpncsvc.c
+)
 endif()
 
 set_target_properties(vpnclient
diff --git a/src/vpnclient/vpncsvc.c b/src/vpnclient/vpncsvc.c
index 74d6da0..2b94e00 100644
--- a/src/vpnclient/vpncsvc.c
+++ b/src/vpnclient/vpncsvc.c
@@ -1,46 +1,50 @@
-// SoftEther VPN Source Code - Developer Edition Master Branch
-// Cedar Communication Module
-
-
-// vpncsvc.c
-// VPN Client Service Program
-
-#define	VPN_EXE
-
-#include "Cedar/Client.h"
-
-#include "Mayaqua/Mayaqua.h"
-#include "Mayaqua/Microsoft.h"
-#include "Mayaqua/Unix.h"
-#include "Mayaqua/Win32.h"
-
-// Process start function
-void StartProcess()
-{
-	// Start the client
-	InitCedar();
-	CtStartClient();
-}
-
-// Process termination function
-void StopProcess()
-{
-  	// Stop the client
-	CtStopClient();
-	FreeCedar();
-}
-
-// WinMain function
-int main(int argc, char *argv[])
-{
-	InitProcessCallOnce();
-
-#ifdef	OS_WIN32
-
-	return MsService(GC_SVC_NAME_VPNCLIENT, StartProcess, StopProcess, ICO_MACHINE, argv[0]);
-#else	// OS_WIN32
-	return UnixService(argc, argv, "vpnclient", StartProcess, StopProcess);
-#endif	// OS_WIN32
-}
-
-
+// SoftEther VPN Source Code - Developer Edition Master Branch
+// Cedar Communication Module
+
+
+// vpncsvc.c
+// VPN Client Service Program
+
+#define	VPN_EXE
+
+#include "Cedar/Client.h"
+
+#include "Mayaqua/Mayaqua.h"
+#include "Mayaqua/Microsoft.h"
+#include "Mayaqua/Unix.h"
+#include "Mayaqua/Win32.h"
+
+// Process start function
+void StartProcess()
+{
+	// Start the client
+	InitCedar();
+	CtStartClient();
+}
+
+// Process termination function
+void StopProcess()
+{
+	// Stop the client
+	CtStopClient();
+	FreeCedar();
+}
+
+// WinMain function
+int main(int argc, char *argv[])
+{
+	InitProcessCallOnce();
+
+#ifdef	OS_WIN32
+
+	return MsService(GC_SVC_NAME_VPNCLIENT, StartProcess, StopProcess, ICO_MACHINE, argv[0]);
+#else	// OS_WIN32
+	return UnixService(argc, argv, "vpnclient", StartProcess, StopProcess);
+#endif	// OS_WIN32
+}
+
+#ifdef __ANDROID__
+extern int VpnClientMain(int argc, char *argv[]) {
+	return main(argc,argv);
+}
+#endif
